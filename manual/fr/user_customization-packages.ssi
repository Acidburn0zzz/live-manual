:B~ Personnalisation de l'installation de paquets

1~customizing-package-installation Personnalisation de l'installation de
paquets

La personnalisation la plus fondamentale d'un système Debian Live peut-être
la sélection de paquets à inclure dans l'image. Ce chapitre vous guide tout
au long des différentes options dans certains moments de la construction
pour personnaliser l'installation des paquets avec live-build. Le plus large
choix influençant les paquets qui sont disponibles pour l'installation dans
l'image sont les zones de distribution et les sections (archive areas). Afin
de garantir des vitesses de téléchargement décentes, vous devez choisir un
miroir de distribution proche. Vous pouvez également ajouter vos propres
dépôts pour les backports, paquets expérimentaux ou personnalisés, ou
inclure des paquets directement en tant que fichiers. Vous pouvez définir
des listes de paquets, incluant les métapaquets qui installent nombreux
paquets liés à la fois, telles que les paquets pour un ordinateur de bureau
ou langue particulière. Enfin, un certain nombre d'options donnent un
certain contrôle sur /{apt}/, ou si vous préférez, /{aptitude}/, au moment
de la construction quand les paquets sont installés. Vous pouvez trouver ces
très pratique si vous utilisez un proxy, vous voulez désactiver
l'installation des paquets recommandés pour économiser l'espace, ou avez
besoin de contrôler quels versions des paquets sont installés via APT
pinning, pour n'en nommer quelques possibilités.

2~ Sources des paquets

3~ Distribution, archive areas et mode

La distribution que vous choisissez a le plus large impact sur les paquets
qui sont disponibles à inclure dans votre image live. Indiquez le nom de
code, qui est par défaut wheezy pour la version de live-build dans
wheezy. Toute distribution actuelle dans l'archive Debian peut être spécifié
par son nom de code ici. (Voir {Termes}#terms pour plus de détails.)
L'option #{--distribution}# non seulement influence la source des paquets
dans l'archive, mais aussi dit live-build comme it doit construire chaque
distribution soutenue. Par exemple, pour construire contre *{unstable}*,
sid, précisez: 

code{

 $ lb config --distribution sid

}code

Dans l'archive de distribution, les «archive areas» sont les principales
divisions de l'archive. Dans Debian, ce sont #{main}#, #{contrib}# et
#{non-free}#. Seulement #{main}# contient des logiciels qui font partie de
la distribution Debian, donc qui est la valeur par défaut. Une ou plusieurs
valeurs peuvent être spécifiées, par exemple

code{

 $ lb config --archive-areas "main contrib"

}code

Soutien expérimental est disponible pour certains dérivés de Debian grâce à
l'option #{--mode}#. L'option #{debian}# est définie par défaut, même si
vous êtes en créant sur un système non-Debian. Si vous spécifiez #{--mode
ubuntu}# ou #{--mode emdebian}#, les noms de distribution et des areas des
archives pour les dérivés spécifiés sont soutenues au lieu de ceux de
Debian.  Le mode modifie également le comportement de live-build en fonction
des dérivés.

*{Remarque:}* Les projets pour lesquels ces modes ont été ajoutés sont principalement responsables d'aider les utilisateurs de ces options. Le projet Debian Live, à son tour, fournit un soutien de développement sur une base des meilleurs efforts seulement, en fonction des commentaires sur les projets dérivés que nous n'avons pas développé ou soutenu nous-mêmes.

3~ Miroirs de distribution

L'archive Debian est répliqué sur un grand réseau de miroirs autour du monde
pour que les habitants dans chaque région puissent choisir un miroir proche
avec la meilleur vitesse de téléchargement. Chacune des options
#{--mirror-*}# régissent quel miroir de distribution est utilisée à
différentes étapes de la construction. Rappelez-vous de {Étapes de la
construction}#stages-of-the-build que l'étape *{bootstrap}* c'est quand le
chroot est initialement peuplée par /{debootstrap}/ avec un système minimal,
et l'étape *{chroot}* c'est quand le chroot utilisé pour construire le
système de fichiers du système live est construit. Ainsi, les commutateurs
des miroirs correspondants sont utilisées pour ces étapes, et plus tard,
dans l'étape *{binary}* les valeurs #{--mirror-binary}# et
#{--mirror-binary-security}# sont utilisées, remplaçant tout miroir utilisé
dans une étape antérieure. 

3~distribution-mirrors-build-time Miroirs de distribution utilisés au temps
de construction

Pour définir les miroirs de distribution utilisés au temps de construction
pour pointer vers un miroir local, il suffit de fixer #{--mirror-bootstrap}#
, #{--mirror-chroot-security}# et #{--mirror-chroot-backports}# comme suit.

code{

 $ lb config --mirror-bootstrap http://localhost/debian/ \
             --mirror-chroot-security http://localhost/debian-security/ \
	     --mirror-chroot-backports http://localhost/debian-backports/

}code

Le miroir chroot, spécifié par #{--mirror-chroot}#, par défaut, c'est la
valeur #{--mirror-bootstrap}#.

3~ Miroirs de distribution utilisés au moment de l'exécution

Les options #{--mirror-binary*}# régissent les miroirs de distribution
placés dans l'image binaire. Ils peuvent être utilisés pour installer des
paquets supplémentaires lors de l'exécution du système live. Les valeurs par
défaut emploient #{cdn.debian.net}#, un service qui choisit un miroir
géographiquement proche basé sur le numéro IP de l'utilisateur. C'est un
choix approprié lorsque vous ne pouvez pas prédire quel miroir sera mieux
pour tous vos utilisateurs. Ou vous pouvez spécifier vos propres valeurs,
comme indiqué dans l'exemple ci-dessous. Une image construite avec cette
configuration seulement serait appropriée pour les utilisateurs sur un
réseau où "#{mirror}#" est accessible.

code{

 $ lb config --mirror-binary http://mirror/debian/ \
             --mirror-binary-security http://mirror/debian-security/

}code

3~additional-repositories Dépôts additionnels

Vous pouvez ajouter d'autres dépôts, élargissant votre choix de paquets
au-delà ceux disponibles dans votre distribution cible. Il peut être, par
exemple, pour backports, expérimentaux ou des paquets personnalisés. Pour
configurer des dépôts supplémentaires, créer les fichiers
#{config/archives/your-repository.list.chroot}#, et/ou
#{config/archives/your-repository.list.binary}#. Comme avec les options
#{--mirror-*}#, elles gouvernent les dépôts utilisés dans l'étape *{chroot}*
lors de la construction de l'image, et dans l'étape *{binary}*, c'est à dire
pour les utiliser au moment de l'exécution du système live.

Par exemple, #{config/archives/live.list.chroot}# vous permet d'installer
les paquets du dépôt des instantanés debian live au moment de la
construction du système live.

code{

 deb http://live.debian.net/ sid-snapshots main contrib non-free

}code

Si vous ajoutez la même ligne à #{config/archives/live.list.binary}#, le
dépôt sera ajouté au répertoire #{/etc/apt/sources.list.d/}# de votre
système live.

Si ces fichiers existent, ils seront sélectionnés automatiquement.

Vous devriez également mettre la clé GPG utilisée pour signer le dépôt dans
fichiers #{config/archives/your-repository.key.{binary,chroot}}#

*{Remarque:}* certains dépôts de paquets préconfigurés sont disponibles pour une sélection facile grâce à l'option #{--archives}#, par exemple pour activer les instantanés live, il suffit une simple commande:

code{

 $ lb config --archives live.debian.net

}code

2~choosing-packages-to-install Choisir les paquets à installer

Il y a un certain nombre de façons pour choisir quels paquets live-build
installera dans votre image, couvrant une variété de besoins
différentes. Vous pouvez tout simplement nommer les paquets individuels à
installer dans une liste de paquets. Vous pouvez également choisir
métapaquets dans ces listes, ou sélectionner-les en utilisant des champs de
paquets de contrôle de fichiers. Et enfin, vous pouvez placer paquets dans
votre arbre #{config/}# qui est bien adapté aux essais de nouveaux paquets
ou expérimentaux avant qu'ils ne soient disponibles sur un dépôt.

3~package-lists Listes de paquets

Les listes de paquets sont un excellent moyen d'exprimer quels paquets
doivent être installés. La syntaxe de la liste soutient les fichiers inclus
et sections conditionnelles qui les rend faciles de construire à partir
d'autres listes et de les adapter pour une utilisation dans configurations
multiples. Les noms des paquets peuvent également être injectés dans la
liste en utilisant assistants de shell au moment de la construction.

*{Remarque:}* Le comportement de live-build pour spécifier un paquet qui n'existe pas est déterminé par votre choix de l'utilité APT. Voir {Choisir apt ou aptitude}#choosing-apt-or-aptitude pour plus de détails.

3~ Utilisation de métapaquets

La façon la plus simple pour remplir votre liste de paquets consiste à
utiliser une tâche métapaquet maintenue par votre distribution. Par exemple:

code{

 $ lb config
 $ echo task-gnome-desktop > config/package-lists/gnome-desktop.list.chroot

}code

Ceci remplace l'ancienne méthode des listes prédéfinies soutenue dans
#{live-build}# 2.x. Contrairement aux listes prédéfinies, les métapaquets ne
sont pas spécifiques du projet Debian Live. Au lieu de cela, ils sont
maintenus par des groupes de travail spécialisés dans la distribution et
reflètent donc le consensus de chaque groupe sur les paquets pour mieux
servir les besoins des utilisateurs. Ils couvrent également une gamme
beaucoup plus large des cas d'utilisation que les listes prédéfinies qu'ils
remplacent.

Tous les métapaquets de tâches sont préfixés avec #{task-}#, donc un moyen
rapide pour déterminer lesquels sont disponibles (même si elle peut contenir
une poignée de faux résultats qui correspondent avec le nom, mais ne sont
pas métapaquets) est de faire correspondre le nom du paquet avec:

code{

 $ apt-cache search --names-only ^task-

}code

En plus, vous trouverez d'autres métapaquets à des fins diverses. Certains
sont sous-ensembles de paquets de tâches plus larges, comme #{gnome-core}#,
tandis que d'autres sont pièces individuelles spécialisées d'un Debian Pure
Blend, comme les métapaquets #{education-*}#. Pour lister tous les
métapaquets dans l'archive, installer le paquet #{debtags}# et lister tous
les paquets avec le tag #{role::metapackage}# comme suit:

code{

 $ debtags search role::metapackage

}code

3~ Listes de paquets locaux

Si vous ajoutez métapaquets dans une liste, des paquets individuels ou une
combinaison des deux, toutes les listes de paquets locaux sont stockées dans
#{config/package-lists/}#. Comme plus d'une liste peut être utilisée, cela
se prête bien à une conception modulaire. Par exemple, vous pouvez décider
de consacrer une liste à un choix particulier de bureau, l'autre à une
collection de packages connexes qui pourraient aussi bien être utilisés
au-dessus d'un bureau différent. Cela vous permet d'expérimenter avec
différentes combinaisons d'ensembles de paquets avec un minimum de tracas en
utilisant des listes communes entre les différents projets d'images live.

Les listes de paquets qui existent dans ce répertoire ont besoin d'avoir un
suffixe #{.list}# pour être traitées, puis un suffixe d'étape supplémentaire
#{.chroot}# ou #{.binary}# pour indiquer à quelle étape la liste est
destinée.

*{Remarque:}* Si vous ne spécifiez pas le suffixe de l'étape, la liste sera utilisée pour les deux étapes. Normalement, vous voulez spécifier #{.list.chroot}# de sorte que les paquets seront seulement installés dans le système de fichiers live et ne pas avoir une copie supplémentaire des #{.deb}# placée sur le support.

3~ Listes locaux de paquets binaires

Pour faire une liste pour l'étape binary, placez un fichier avec le suffixe
#{.list.binary}# dans #{config/package-lists/}#. Ces paquets ne sont pas
installés dans le système de fichiers live, mais sont inclus sur les
supports live sous #{pool/}#. Vous utiliserez généralement cette liste avec
une des variantes d'installation non-live. Comme mentionné ci-dessus, si
vous voulez que cette liste soit la même que votre liste pour l'étape
chroot, utilisez simplement le suffixe #{.list}#. 

3~generated-package-lists Générer listes de paquets

Il arrive parfois que la meilleure façon de composer une liste est de la
générer avec un script. Toute ligne commençant par un point d'exclamation
indique une commande à exécuter dans le chroot lorsque l'image est
construite. Par exemple, on pourrait inclure la ligne #{! grep-aptavail -n
-sPackage -FPriority standard | sort}# dans une liste de paquets qui permet
de produire une liste triée des paquets disponibles avec

En fait, la sélection des paquets avec la commande #{grep-aptavail}# (du
paquet #{dctrl-tools}#) est si utile que #{live-build}# fournit un script
#{Packages}# à titre de commodité. Ce script accepte deux arguments:
#{field}# et #{pattern}#. Ainsi, vous pouvez créer une liste avec le contenu
suivant:

code{

 $ lb config
 $ echo '! Packages Priority standard' > config/package-lists/standard.list.chroot

}code

3~ Utilisant des conditionnels dans les listes de paquets

Toutes les variables de configuration de live-build stockées dans
#{config/*}# (sans le préfixe #{LB_}#) peuvent être utilisées dans
instructions conditionnelles dans les listes de paquets. Généralement, cela
signifie une option #{lb config}# majuscule et avec tirets changés en
caractères de soulignement. Mais en pratique, c'est seulement ceux qui
influencent la sélection des paquets qui font sens, comme #{DISTRIBUTION}#,
#{ARCHITECTURES}# ou #{ARCHIVE_AREAS}#.

Par exemple, pour installer #{ia32-libs}# si #{--architectures amd64}# est
spécifié:

code{

 #if ARCHITECTURES amd64
 ia32-libs
 #endif

}code

Vous pouvez tester pour un certain nombre de valeurs, par exemple pour
installer /{memtest86+}/ si #{--architectures i386}# ou #{--architectures
amd64}# est spécifié:

code{

 #if ARCHITECTURES i386 amd64
 memtest86+
 #endif

}code

Vous pouvez également tester contre des variables qui peuvent contenir plus
d'une valeur, par exemple pour installer /{vrms}/ si #{contrib}# ou
#{non-free}# est spécifié via #{--archive-areas}#:

code{

 #if ARCHIVE_AREAS contrib non-free
 vrms
 #endif

}code

Un conditionnel peut entourer une directive #{#include}#:

code{

 #if ARCHITECTURES amd64
 #include <gnome-full>
 #endif

}code

L'imbrication des conditionnels n'est pas soutenu.

3~desktop-and-language-tasks Tâches de bureau et de la langue

Les tâches de bureau et de la langue sont des cas particuliers qui ont
besoin d'une certaine planification et de configuration supplémentaire
. Dans l'installateur Debian, si le support a été préparé pour un
environnement de bureau particulier, la tâche correspondante sera
automatiquement installée. Ainsi, il y a tâches internes #{gnome-desktop}#,
#{kde-desktop}#, #{lxde-desktop}# et #{xfce-desktop}#, dont aucun n'est
offert dans le menu #{tasksel}#. De même, il n'y a pas éléments de menu pour
les tâches des langues, mais le choix de la langue de l'utilisateur lors de
l'installation influence le choix des tâches de la langue correspondante.

Lors du développement d'une image de bureau live, l'image généralement
amorce directement à un bureau de travail, le choix du environnement de
bureau et la langue par défaut ayant été fait au moment de la construction,
non pas au moment de l'exécution comme dans le cas de l'installateur de
Debian. Cela ne veut pas dire qu'une image live ne pourrait être construite
pour soutenir plusieurs environnements de bureau ou de plusieurs langues et
offrir à l'utilisateur un choix, mais ce n'est pas le comportement par
défaut de live-build.

Parce qu'il n'y a pas aucune disposition faite automatiquement pour les
tâches de la langue, qui comprennent des éléments tels que des polices
spécifiques de la langue et des paquets de méthodes de saisie, si vous les
voulez, vous devez les spécifier dans votre configuration. Par exemple, une
image de bureau GNOME contenant soutien pour le japonais pourrait inclure
les tâches suivantes:

code{

 $ lb config
 $ echo "gnome-desktop desktop standard laptop" >> config/task-lists/my.list.chroot
 $ echo "japanese japanese-desktop japanese-gnome-desktop" >> config/task-lists/my.list.chroot

}code

Comme les tâches de bureau sont des tâches «internes», pour chaque tâche de
saveur de bureau incluse dans l'image, la valeur correspondante, si elle
diffère de la valeur par défaut, "gnome", doit être préconfigurée dans la
variable debconf «tasksel/desktop", ou bien tasksel ne la reconnaîtra pas et
ne l'installera pas. Ainsi:

code{

 $ lb config
 $ echo 'tasksel tasksel/desktop multiselect kde' >> config/preseed/my.preseed.chroot

}code

Ce paramètre peut prendre plusieurs valeurs, par exemple "lxde xfce" au lieu
de "kde".

2~installing-modified-or-third-party-packages Installation des paquets
modifiés ou de tiers

Tandis qu'il est contre la philosophie de Debian Live, il peut parfois être
nécessaire de construire un système live avec des versions modifiées des
paquets qui sont dans le dépôt Debian. C'est peut-être pour modifier ou
soutenir des fonctionnalités supplémentaires, des langues et branding, ou
même pour supprimer des éléments dans les paquets existants qui sont
indésirables. De même, les paquets "de tiers" peuvent être utilisés pour
ajouter des fonctionnalités sur mesure et/ou propriétaires.

Cette section ne couvre pas les conseils concernant la construction ou la
maintenance des paquets modifiés. La méthode de Joachim Breitner 'How to
fork privately'
http://www.joachim-breitner.de/blog/archives/282-How-to-fork-privately.html
peut, cependant, être d'intérêt. La création de paquets sur mesure est
traité dans le Debian New Maintainers' Guide at
http://www.debian.org/doc/maint-guide/ et ailleurs

Il y a deux façons d'installer des paquets personnalisés modifiés:

_* #{packages.chroot}#

_* Utiliser un dépôt APT personnalisé

Utilisant #{packages.chroot}# est plus simple à réaliser et utile pour les
personnalisations ponctuels mais a un certain nombre d'inconvénients, tout
en utilisant un dépôt personnalisé APT est plus fastidieux à mettre en
place.

3~ Utilisant #{packages.chroot}# pour installer paquets personnalisés

Pour installer un paquet personnalisé, il suffit de le copier dans le
répertoire #{config/packages.chroot/}#. Les paquets qui sont dans ce
répertoire seront automatiquement installés dans le système live pendant la
construction du systéme - vous n'avez pas besoin de les spécifier ailleurs.

Les paquets *{doivent}* être nommés de la manière prescrite. Une façon
simple de le faire consiste à utiliser #{dpkg-name}#.

L'utilisation de #{packages.chroot}# pour l'installation de paquets
personnalisés a des inconvénients:

_* Il n'est pas possible d'utiliser secure APT.

_* Vous devez installer tous les paquets appropriés dans le répertoire
#{config/packages.chroot/}#.

_* Il ne se prête pas au stockage de configurations Debian Live dans le
contrôle de révision.

3~ Utiliser un dépôt APT pour installer des paquets personnalisés.

Contrairement à l'utilisation de #{packages.chroot}#, lorsque vous utilisez
un dépôt personnalisé APT vous devez vous assurer que vous spécifiez les
paquets ailleurs. Voir {Choisir les paquets à
installer}#choosing-packages-to-install pour plus de détails.

Si créer un dépôt APT pour installer des paquets personnalisés peut sembler
un effort inutile, l'infrastructure peut être facilement ré-utilisée à une
date ultérieure pour offrir les mises à jour des paquets modifiés.

3~ Les paquets personnalisés et APT

live-build utilise apt pour installer tous les paquets dans le système live
donc il héritera les comportements de ce logiciel. Un exemple pertinent est
que (en supposant une configuration par défaut), s'il y a un paquet
disponible dans deux dépôts différents avec différents numéros de version,
APT choisira d'installer le paquet avec la numéro de version supérieur.

Pour cette raison, vous pouvez incrémenter le numéro de version dans les
fichiers #{debian/changelog}# de vos paquets personnalisés pour s'assurer
que votre version modifiée est installée en lieu d'une dans les dépôts
officiels Debian. Cela peut aussi être atteint en modifiant les préférences
d'APT pinning dans le système live - voir {APT pinning}#apt-pinning pour
plus d'informations.

2~ Configuration d'APT au moment de la construction

Vous pouvez configurer APT par un certain nombre d'options appliquées
uniquement au moment de la construction. (La configuration d'APT utilisé
dans le système live en fonctionnement peut être configurée de façon normale
pour un système live, qui est, en incluant les configurations appropriées
dans #{config/includes.chroot/}#.) Pour une liste complète, regardez les
options commençant par #{apt}# dans la page de manuel de #{lb_config}#.

3~choosing-apt-or-aptitude Choisir apt ou aptitude

Vous pouvez choisir d'utiliser soit /{apt}/ ou /{aptitude}/. Quel logiciel
est utilisé est régi par l'argument #{--apt}# de #{lb config}#. Choisissez
la méthode du comportement préférée pour l'installation de paquets, la
différence notable étant la manière dont les paquets manquants sont traités.

_* #{apt}#: Avec cette méthode, si un paquet manquant est spécifié,
l'installation va échouer. C'est le réglage par défaut.

_* #{aptitude}#: Avec cette méthode, si un paquet manquant est spécifié,
l'installation va réussir.

3~ Utilisation d'un proxy avec APT

Une configuration communément requis par APT est pour faire face à la
construction d'une image derrière un proxy. Vous pouvez spécifier votre
proxy APT avec les options #{--apt-ftp-proxy}# ou #{--apt-http-proxy}# si
nécessaire, par exemple

code{

 $ lb config --apt-http-proxy http://proxy/

}code

3~ Régler APT pour économiser de l'espace

Vous pouvez avoir besoin d'économiser de l'espace sur les supports d'images,
auquel cas l'un ou l'autre ou les deux options suivantes peuvent être
d'intérêt.

Si vous ne voulez pas inclure les indices d'APT dans l'image, vous les
pouvez omettre avec:

code{

 $ lb config --apt-indices false

}code

Cela ne influencera les entrées dans #{/etc/apt/sources.list}#, mais
simplement de savoir si #{/var/lib/apt}# contient les fichiers indices ou
non. La contrepartie est que APT a besoin de ces indices afin d'opérer dans
le système live, alors avant de procéder à #{apt-cache search}# ou #{apt-get
install}#, par exemple, l'utilisateur doit faire #{apt-get update}# pour
créer ces indices.

Si vous trouvez que l'installation des paquets recommandés gonfle votre
image trop, vous pouvez désactiver l'option par défaut d'APT avec:

code{

 $ lb config --apt-recommends false

}code

La contrepartie ici est que si vous n'installez pas les paquets recommandés
par un paquet, c’est-à-dire, "paquets qu'on trouverai avec celui-ci dans
toute installation standard" (Debian Policy Manual, section 7.2), certains
paquets que vous avez vraiment besoin peuvent être omis. Par conséquent,
nous vous suggérons d'examiner la différence que désactiver recommends rend
à votre liste de paquets (voir le fichier #{binary.packages}# généré par
#{lb build}#) et re-incluez dans votre liste tous les paquets manquants que
vous souhaitez toujours installés. Alternativement, si vous trouvez que vous
voulez seulement un petit nombre de paquets recommandés exclus, laissez
recommends activé et définissez une priorité APT pin négative sur les
paquets sélectionnés pour éviter les installér, comme expliqué dans {APT
pinning}#apt-pinning.

3~ Passer des options à apt ou aptitude

S'il n'y a pas une option #{lb config}# pour modifier le comportement d'APT
dans la façon dont vous avez besoin, utiliser #{--apt-options}# ou
#{--aptitude-options}# pour passer des options à votre outil APT
configuré. Voir les pages de manuel #{apt}# et #{aptitude}# pour plus de
détails

3~apt-pinning APT pinning

Pour le contexte, s'il vous plaît lire d'abord la page de manuel
#{apt_preferences(5)}#. APT pinning peut être configuré soit au temps de
construction, ou encore pendant l'exécution. Pour le premier, créez
#{config/chroot_apt/preferences}#. Pour ce dernier, créez
#{config/includes.chroot/etc/apt/preferences}#.

Imaginons que vous voulez construire un système live wheezy mais il faut
installer tous les paquets live qui finissent dans l'image binaire de sid au
moment de la construction. Vous devez ajouter sid à votre APT sources et le
fixer de sorte que seulement les paquets que vous voulez sont installés au
temps de construction et tous les autres sont de la distribution du système
cible, wheezy. Ce qui suit devrait accomplir ça:

code{

 $ echo "deb http://mirror/debian sid main" > config/archives/sid.list.chroot
 $ cat >> config/chroot_apt/preferences << END
 Package: live-boot live-boot-initramfs-tools live-config live-config-sysvinit
 Pin: release n=sid
 Pin-Priority: 600

 Package: *
 Pin: release n=sid
 Pin-Priority: 1
 END

}code

*{Remarque:}* Caractères génériques peuvent être utilisés dans les noms des paquets (par exemple *{Package: live-*}*) avec la version 0.8.14 ou supérieure d'Apt. Cela signifie qu'il fonctionne avec wheezy en utilisant:

code{

$ lb config --distribution wheezy

}code

Une priorité pin négative évitera installér un paquet, comme dans le cas où
vous ne voulez pas un paquet qui est recommandé par un autre
paquet. Supposons que vous construisez une image LXDE en utilisant
#{task-lxde-desktop}# dans #{config/package-lists/lxde-desktop.list.chroot}#
mais ne veulez pas que l'utilisateur soit invité à stocker les mots de passe
wifi dans le trousseau de clés. Cette liste comprend /{lxde-core}/, qui
recommande /{gksu}/, que à son tour recommande /{gnome-keyring}/. Donc, vous
voulez omettre le paquet recommandé /{gnome-keyring}/. Cela peut être fait
en ajoutant la strophe suivante à #{config/chroot_apt/preferences}#:

code{

 Package: gnome-keyring
 Pin: version *
 Pin-Priority: -1

}code
