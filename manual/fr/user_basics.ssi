:B~ Les bases 

1~the-basics Les bases

This chapter contains a brief overview of the build process and instructions
for using the three most commonly used image types. The most versatile image
type, #{iso-hybrid}#, may be used on a virtual machine, optical media or USB
portable storage device. In certain special cases, such as the use of
persistence, #{hdd}# may be more suitable for USB devices. The chapter
finishes with instructions for building and using a #{net}# type image,
which is a bit more involved due to the setup required on the server. This
is a slightly advanced topic for anyone who is not familiar already with
netbooting, but is included here because once the setup is done, it is a
very convenient way to test and deploy images for booting on the local
network without the hassle of dealing with image media.

Tout au long du chapitre, nous ferons souvent référence à la valeur par
défaut des noms de fichiers produits par live-build. Si vous téléchargez une
image précompilée les noms de fichiers peuvent varier.

2~what-is-live Qu'est-ce qu'un système live?

Un système live signifie généralement un système d'exploitation démarré sur
un ordinateur à partir d'un support amovible, tel qu'un CD-ROM ou une clé
USB, ou d'un réseau prêt à l'emploi sans aucune installation sur le disque
habituel(s), avec auto-configuration fait lors de l'exécution (voir
{Termes}#terms).

Avec Debian Live, c'est un système Debian GNU/Linux, construit pour une des
architectures supportées (actuellement amd64, i386, PowerPC et SPARC). Il
est fait à partir des éléments suivants:

_* *{Linux kernel image}*, d'habitude appelé #{vmlinuz*}#

_* *{Initial RAM disk image (initrd)}*: Un disque virtuel RAM configuré pour
le démarrage de Linux, contenant possiblement des modules nécessaires pour
monter l'image du système et certains scripts pour le faire.

_* *{System image}*: L'image du système de fichiers du système
d'exploitation. Habituellement, un système de fichiers SquashFS comprimé est
utilisé pour réduire au minimum la taille de l'image Debian Live. Notez
qu'il est en lecture seulement. Ainsi, lors du démarrage du système Debian
Live nous allons utiliser un disque RAM et un mécanisme  "union" pour
permettre l'écriture de fichiers dans le système en marche. Cependant,
toutes les modifications seront perdues lors de l'arrêt à moins que l'option
persistance est utilisée (voir {Persistance}#persistence).

_* *{Bootloader}*: Un petit morceau de code conçu pour démarrer à partir du
support choisi, il peut présenter un menu rapide ou permettre la sélection
des options/configuration. Il charge le kernel Linux et son initrd pour
fonctionner avec un système de fichiers associé. Différentes solutions
peuvent être utilisées, selon le support de destination et le format du
système de fichiers contenant les composants mentionnés précédemment:
isolinux pour démarrer à partir d'un CD ou DVD au format ISO9660, syslinux
pour démarrer le disque dur ou clé USB à partir d'une partition VFAT,
extlinux pour ext2/3/4 et partitions btrfs, pxelinux pour netboot PXE, GRUB
pour ext2/3/4 partitions, etc.

Vous pouvez utiliser live-build pour construire l'image du système à partir
de vos spécifications, configurer un kernel Linux, son initrd, et un
chargeur de démarrage pour les exécuter, tout dans un format en fonction du
support (image ISO9660,  disque image, etc.)

2~building-iso-hybrid Premières étapes: la construction d'une image ISO
hybride

Quel que soit le type d'image, vous devrez effectuer les mêmes étapes de
base pour créer une image chaque fois. Comme premier exemple, exécuter la
séquence suivante de commandes  live-build pour créer une image ISO hybride
de base contenant tout le système Debian standard sans X.org. Elle est
appropriée pour être gravée sur CD ou DVD, et également peut être copiée sur
une clé USB.

Tout d'abord, exécutez la commande #{lb config}#. Cela va créer une
hiérarchie "config /" dans le répertoire courant pour l'utilisation par
d'autres commandes:

code{

 $ lb config

}code

Aucun paramètre n'est passé à #{lb config}#, donc défauts seront utilisés
pour l'ensemble de ses diverses options. Voir {La commande lb
config}#lb-config pour plus de détails.

Maintenant que la hiérarchie "config /" existe, créez l'image avec la
commande #{lb build}# :

code{

 # lb build

}code

Ce processus peut prendre un certain temps, en fonction de la vitesse de
votre connexion réseau. Quand il est complet, il devrait y avoir un fichier
image #{binary-hybrid.iso}# prêt à l'emploi, dans le répertoire courant.

2~using-iso-hybrid Utilisation d'une image ISO hybride live

Après la construction ou le téléchargement d'une image ISO hybride, qui peut
être obtenue à http://www.debian.org/CD/live/, l'étape suivante est
d'habitude préparer votre support pour le démarrage, soit sur CD-R(W) ou DVD
-R(W) des supports optiques ou une clé USB.

3~burning-iso-image Graver une image ISO sur un support physique

Graver une image ISO est facile. Il suffit d'installer wodim et l'utiliser à
partir de la ligne de commande pour graver l'image. Par exemple:

code{

 # apt-get install wodim

 $ wodim binary-hybrid.iso

}code

3~copying-iso-hybrid-to-usb Copie d'un image ISO hybride sur une clé USB

Les images ISO préparées avec la commande #{isohybrid}# comme les images
#{iso-hybrid}# produites par défaut, peuvent être simplement copiées sur une
clé USB avec #{dd}# ou un programme équivalent. Brancher une clé USB avec
une capacité suffisamment grande pour votre fichier image et déterminez quel
dispositif il est, que nous appellons ci-dessous #{${USBSTICK}}#. C'est le
fichier de périphérique de votre clé, tel que #{/dev/sdb}#, pas une
partition, tel que #{/dev/sdb1}#! Vous pouvez trouver le nom du périphérique
en regardant dans la sortie de #{dmesg}# après avoir branché le dispositif,
ou mieux encore, #{ls -l /dev/disk/by-id}#.

Une fois que vous êtes sûr d'avoir le nom correct de l'appareil, utilisez la
commande #{dd}# pour copier l'image sur le clé. *{Ceci écrasera tout fichier
déjà existant sur votre clé!}*

code{

 $ dd if=binary-hybrid.iso of=${USBSTICK}

}code


3~booting-live-media Démarrer le support live

La première fois que vous démarrez votre support live, qu'il s'agisse de CD,
DVD, clé USB, ou le démarrage PXE, une certaine configuration dans le BIOS
de votre ordinateur peut être d'abord nécessaire. Depuis les BIOS varient
grandement en fonctionnalités et raccourcis clavier, on ne peut pas pénétrer
dans le sujet en profondeur ici. Certains BIOS fournissent une clé pour
ouvrir un menu d'amorçage au démarrage, qui est le moyen le plus facile si
elle est disponible sur votre système. Sinon, vous avez besoin d'entrer dans
le menu de configuration du BIOS et modifier l'ordre de démarrage pour
placer le dispositif de démarrage pour le système live devant votre
périphérique de démarrage normal.

Une fois que vous avez démarré le support, vous êtes présenté avec un menu
de démarrage. Si vous appuyez simplement sur enter ici, le système va
démarrer en utilisant l'entrée par défaut, #{Live}# Pour plus d'informations
sur les options de démarrage, consultez l'entrée «Help» dans le menu et
aussi les pages de manuel de #{live-boot}# et #{live-config}# dans le
système live.

En supposant que vous avez sélectionné #{Live}# et démarré une image de
bureau live par défaut, après les messages de démarrage défilent, vous
devriez être automatiquement connecté au compte #{user}# et voir un bureau,
prêt à l'emploi. Si vous avez démarré une image de la console uniquement,
tels que saveurs #{standard}# ou #{sauvetage}# des images prédéfinies, vous
devriez être automatiquement connecté à la console pour le compte #{user}#
et voir une invite du shell, prêt à l'emploi.

2~using-virtual-machine Utiliser une machine virtuelle pour les tests

Il peut être un gain de temps important pour le développement des images
live les faire fonctionner dans une machine virtuelle (VM). Ce n'est pas
sans ses avertissements:

_* L'exécution d'une VM demande assez de RAM pour l'OS client et l'hôte et
un CPU avec support matériel pour la virtualisation est recommandée.

_* Il ya quelques limitations inhérentes à l'exécution sur une VM, par
exemple performance de vidéo médiocre, ou choix limité de matériel émulé.

_* Lors du développement d'un matériel spécifique, il n'existe aucun
substitut pour l'exécution que le matériel lui-même.

_* Parfois il ya des bogues que deviennent visibles uniquement pendant
l'exécution dans une VM. En cas de doute, testez votre image directement sur
le matériel.

À condition que vous pouvez travailler avec ces obstacles, examinez les
logiciels VM disponibles et choisissez celui qui convient à vos besoins.

3~testing-iso-with-qemu Test d'une image ISO avec QEMU

La VM la plus polyvalente de Debian est QEMU. Si votre processeur possède un
support matériel pour la virtualisation, vouz pouvez utiliser le paquet
#{qemu-kvm}#; La description du paquet #{qemu-kvm}# énumère brièvement les
exigences.

Tout d'abord, installez #{qemu-kvm}# si votre processeur le supporte. Sinon,
installez #{qemu}#, dans ce cas, le nom du programme est #{qemu}# au lieu de
#{kvm}# dans les exemples suivants. Le paquet #{qemu-utils}# est également
valuable pour créer des images disque virtuels avec #{qemu-img}#.

code{

 # apt-get install qemu-kvm qemu-utils

}code

Démarrer une image ISO est simple:

code{

 $ kvm -cdrom binary-hybrid.iso

}code

Voir les pages de manuel pour plus de détails.

3~testing-iso-with-virtualbox  Test d'une image ISO avec virtualbox-ose

Afin de tester l'ISO avec #{virtualbox-ose}#:

code{

 # apt-get install virtualbox-ose virtualbox-ose-dkms

 $ virtualbox

}code

Créer une nouvelle machine virtuelle, modifiez les paramètres de stockage
pour utiliser #{binary-hybrid.iso}# comme le périphérique CD/DVD et démarrer
la machine.

Remarque: Pour les systèmes live contenant X.org que vous voulez essayer
avec #{virtualbox-ose}#, vous pouvez inclure le paquet des pilotes
VirtualBox X.org, #{virtualbox-ose-guest-x11}#, dans votre configuration de
live-build. Sinon, la résolution est limitée à 800x600.

code{

 $ echo virtualbox-ose-guest-x11 >> config/package-lists/my.list.chroot

}code

2~building-hdd Building an HDD image

Building an HDD image is similar to ISO hybrid in all respects except you
specify #{-b hdd}# and the resulting filename is #{binary.img}# which cannot
be burnt to optical media. It is suitable for booting from USB sticks, USB
hard drives, and various other portable storage devices. Normally, an ISO
hybrid image can be used for this purpose instead, but if you have a BIOS
which does not handle hybrid images properly, or want to use the remaining
space on the media for some purpose, such as a persistence partition, you
need an HDD image.

Remarque: si vous avez créé une image ISO hybride avec l'exemple précédent,
vous devrez nettoyer votre répertoire de travail avec la commande #{lb
clean}# (voir {La commande lb clean}#lb-clean):

code{

 # lb clean --binary

}code

Run the #{lb config}# command as before, except this time specifying the HDD
image type:

code{

 $ lb config -b hdd

}code

Maintenant construire l'image avec la commande #{lb build}#

code{

 # lb build

}code

Quand la création de l'image est finie, un fichier #{binary.img}# doit être
présent dans le répertoire courant.

2~using-hdd-image Using an HDD image

The generated binary image contains a VFAT partition and the syslinux
bootloader, ready to be directly written on a USB stick. Since using an HDD
image is just like using an ISO hybrid image on USB, follow the instructions
in {Using an ISO hybrid live image}#using-iso-hybrid, except use the
filename #{binary.img}# instead of #{binary-hybrid.iso}#.

3~testing-hdd-with-qemu Testing an HDD image with Qemu

D'abord, installer QEMU comme décrit ci-dessus dans {Test d'une image ISO
avec QEMU}#testing-iso-with-qemu. Ensuite, exécutez #{kvm}# ou #{qemu}#,
selon la version de vos besoins du système hôte, précisant #{binary.img}#
comme le premier disque dur.

code{

 $ kvm -hda binary.img

}code

3~using-usb-extra-space Utilisation de l'espace disponible sur une clé USB

Pour utiliser l'espace libre restant après avoir copié #{binary.img}# sur
une clé USB, utilisez un outil de partitionnement tels que #{gparted}# ou
#{parted}# afin de créer une nouvelle partition sur la clé. La première
partition sera utilisée par le système Debian Live.

code{

 # gparted ${USBSTICK}

}code

Après la partition est créée, où #{${PARTITION}}# est le nom de la
partition, tel que #{/dev/sdb2}#, vous devez créer un système de fichiers
sur elle. Un choix possible serait ext4.

code{

 # mkfs.ext4 ${PARTITION}

}code

Remarque: Si vous voulez utiliser l'espace supplémentaire avec Windows,
apparemment cet OS ne peut normalement pas accéder à n'importe quel
partition, mais la première. Certaines solutions à ce problème ont été
discutés sur notre {liste de diffusion}#contact, mais il semble qu'il n'y a
pas de réponses faciles.

*{Rappelez-vous: Chaque fois que vous installez une nouvelle binary.img sur la clé, toutes les données sur la clé seront perdues parce que la table de partition est écrasé par le contenu de l'image, vous devez sauvegarder votre partition supplémentaire d'abord la restaurer à nouveau après la mise à jour du live image.}*

2~building-netboot-image Construction d'une image netboot

La séquence de commandes suivante va créer une image NetBoot de base
contenant le système Debian standard sans X.org. Elle peur être démarrée sur
le réseau.

Remarque: Si vous avez réalisé tous les exemples précédents, vous aurez
besoin de nettoyer votre répertoire de travail avec la commande #{lb
clean}#:

code{

 # lb clean --binary

}code

Exécutez la commande comme suit pour configurer votre image pour démarrer
sur le réseau:

code{

 $ lb config -b net --net-root-path "/srv/debian-live" --net-root-server "192.168.0.1"

}code

In contrast with the ISO and HDD images, netbooting does not, itself, serve
the filesystem image to the client, so the files must be served via NFS. The
#{--net-root-path}# and #{--net-root-server}# options specify the location
and server, respectively, of the NFS server where the filesytem image will
be located at boot time. Make sure these are set to suitable values for your
network and server.

Maintenant construire l'image avec la commande #{lb build}#

code{

 # lb build

}code

Dans un démarrage réseau, le client exécute un petit morceau de logiciel qui
réside habituellement sur l'EPROM de la carte Ethernet. Ce programme envoie
une requête DHCP pour obtenir une adresse IP et les informations sur ce
qu'il faut faire ensuite. Typiquement, la prochaine étape est obtenir un
chargeur de démarrage de niveau supérieur via le protocole TFTP. Cela
pourrait être pxelinux, GRUB, ou démarrer directement à un système
d'exploitation comme Linux.

Par exemple, si vous décompressez le fichier généré #{binary-net.tar.gz}#
dans le répertoire #{/srv/debian-live}#, vous trouverez l'image du système
de fichiers dans #{live/filesystem.squashfs}# et le kernel, initrd et le
chargeur de démarrage pxelinux dans #{tftpboot/debian-live/i386}#.

Nous devons maintenant configurer trois services sur le serveur pour activer
netboot: le serveur DHCP, serveur TFTP et le serveur NFS.

3~ Serveur DHCP

Nous devons configurer le serveur DHCP de notre réseau pour être sûr de
donner une adresse IP au système client netboot, et pour annoncer
l'emplacement du chargeur de démarrage PXE.

Voici un exemple source d'inspiration, écrit pour le serveur ISC DHCP
#{isc-dhcp-server}# dans le fichier de configuration
#{/etc/dhcp/dhcpd.conf}#:

code{

 # /etc/dhcp/dhcpd.conf - configuration file for isc-dhcp-server

 ddns-update-style none;

 option domain-name "example.org";
 option domain-name-servers ns1.example.org, ns2.example.org;

 default-lease-time 600;
 max-lease-time 7200;

 log-facility local7;

 subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.1 192.168.0.254;
   next-server servername;
   filename "pxelinux.0";
}

}code

3~ Serveur TFTP

Cela sert le kernel et le ramdisk initial pour le système au moment de
l'exécution.

Vous devriez installer le paquet tftpd-hpa. Il peut servir tous les fichiers
contenus dans un répertoire racine, d'habitude #{/srv/tftp}#. Pour le
laisser servir des fichiers dans #{/srv/debian-live/tftpboot}#, exécuter
comme utilisateur root la commande suivante:

code{

 # dpkg-reconfigure -plow tftpd-hpa

}code

et remplissez le nuveau répertoire du serveur tftp

3~ Serveur NFS

Une fois l'ordinateur hôte a téléchargé et démarré un kernel Linux et chargé
son initrd, il va essayer de monter l'image du système de fichiers live via
un serveur NFS.

Vous devez installer le paquet #{nfs-kernel-server}#.

Ensuite, rendre l'image du système de fichiers disponible via NFS en
ajoutant une ligne comme la suivante #{/etc/exports}#:

code{

 /srv/debian-live *(ro,async,no_root_squash,no_subtree_check)

}code

et dire au serveur NFS sur cette exportation avec la commande suivante:

code{

 # exportfs -rv

}code

Mise en place ces trois services peut être un peu délicat. Vous pourriez
avoir besoin de patience pour obtenir que tous travaillent ensemble. Pour
plus d'informations, consultez le wiki syslinux à
http://syslinux.zytor.com/wiki/index.php/PXELINUX ou la section Debian
Installer Manual's TFTP Net Booting à
http://d-i.alioth.debian.org/manual/en.i386/ch04s05.html. Ils pourraient
aider parce que leurs processus sont très semblables.

3~ Guide pratique pour expérimenter avec une image Netboot

La création d'images NetBoot est facile avec la magie de live-build, mais
les essais des images sur des machines physiques peuvent prendre vraiment
beaucoup de temps. 

Afin de rendre notre vie plus facile, nous pouvons utiliser la
virtualisation. Il ya deux solutions.

3~ Qemu

_* Installer #{qemu}#, #{bridge-utils}#, #{sudo}#.

Èditer #{/etc/qemu-ifup}#:

code{

 #!/bin/sh
 sudo -p "Password for $0:" /sbin/ifconfig $1 172.20.0.1
 echo "Executing /etc/qemu-ifup"
 echo "Bringing up $1 for bridged mode..."
 sudo /sbin/ifconfig $1 0.0.0.0 promisc up
 echo "Adding $1 to br0..."
 sudo /usr/sbin/brctl addif br0 $1
 sleep 2

}code

Obtenir, ou construire un #{grub-floppy-netboot}# (dans le svn).

Lancer #{qemu}# avec "#{-net nic,vlan=0 -net tap,vlan=0,ifname=tun0}#"

3~ VMWare Player

_* Installer VMWare Player (édition "free as in beer")

_* Créer un répertoire PXETester, et créer un fichier texte appelé
#{pxe.vwx}# à l'intérieur

_* Collez ce texte à l'intérieur:

code{

 #!/usr/bin/vmware
 config.version = "8"
 virtualHW.version = "4"
 memsize = "512"
 MemAllowAutoScaleDown = "FALSE"

 ide0:0.present = "FALSE"
 ide1:0.present = "FALSE"
 floppy0.present = "FALSE"
 sound.present = "FALSE"
 tools.remindInstall = "FALSE"

 ethernet0.present = "TRUE"
 ethernet0.addressType = "generated"

 displayName = "Test Boot PXE"
 guestOS = "other"

 ethernet0.generatedAddress = "00:0c:29:8d:71:3b"
 uuid.location = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
 uuid.bios = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
 ethernet0.generatedAddressOffset = "0"

}code

_* Vous pouvez jouer avec ce fichier de configuration (par exemple, changer
la limite de mémoire à 256)

_* Double-cliquez sur ce fichier (ou exécuter VMware Player et sélectionnez
ce fichier).

_* Lors de l'exécution presse l'espace si cette question étrange arrive ...
