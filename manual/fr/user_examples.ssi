:B~ Exemples

1~examples  Exemples

Ce chapitre s'occupe d'exemples de constructions pour des cas d'utilisation
spécifiques avec Debian Live. Si vous êtes nouveau avec la construction de
vos propres images Debian Live, nous vous recommandons d'abord regarder les
trois tutoriels en séquence, parce que chacun enseigne nouvelles techniques
qui vous aideront à utiliser et à comprendre les exemples restants.

2~using-the-examples En utilisant les exemples

Pour utiliser ces exemples vous avez besoin d'un système pour les
construire, lequel répond aux exigences énumérées dans
{Exigences}#requirements et qui a live-build installé comme décrit à
{Installation de live-build}#installing-live-build.

Notez que, pour des raisons de concision, dans ces exemples, nous ne
spécifions pas un miroir local à utiliser pour la construction. Vous pouvez
accélérer considérablement les téléchargements si vous utilisez un miroir
local. Vous pouvez spécifier les options lorsque vous utilisez #{lb
config}#, tel que décrit dans {Miroirs de distribution utilisés au temps de
construction}#distribution-mirrors-build-time, ou pour plus de commodité,
fixez par défaut votre système de construction dans
#{/etc/live/build.conf}#. Il suffit de créer ce fichier et de définir les
variables #{LB_MIRROR_*}# correspondantes à votre miroir préféré. Tous les
autres miroirs utilisés dans la construction seront par défaut à partir de
ces valeurs. Par exemple:

code{

 LB_MIRROR_BOOTSTRAP="http://mirror/debian"
 LB_MIRROR_CHROOT_SECURITY="http://mirror/debian-security"
 LB_MIRROR_CHROOT_BACKPORTS="http://mirror/debian-updates"

}code

2~tutorial-1 Tutorial 1: Une image standard

*{Cas d'utilisation:}* Créer une image simple d'abord, apprenant les bases de live-build.

Dans ce tutoriel, nous construirons une image Debian Live ISO hybride par
défaut contenant uniquement paquets de base (pas de Xorg) et quelques
paquets Debian de soutien live, comme un premier exercice en utilisant
live-build.

Vous ne pouvez pas obtenir rien plus simple que cela:

code{

 $ mkdir tutorial1 ; cd tutorial1 ; lb config

}code

Examinez le contenu du répertoire #{config/}# si vous le souhaitez. Vous
verrez stockés ici une arborescence de configuration, pour être personnalise
ou, dans ce cas, utiliser immédiatement pour construire une image par
défaut.

Maintenant, en tant que superutilisateur, construire l'image en enregistrant
un journal avec #{tee}#.

code{

 # lb build 2>&1 | tee binary.log

}code

En supposant que tout se passe bien, après un certain temps, le répertoire
courant contient #{binary-hybrid.iso}#. Cette image ISO hybride peut être
démarré directement dans une machine virtuelle comme décrit dans {Test d'une
image ISO avec QEMU}#testing-iso-with-qemu et {Test d'une image ISO avec
virtualbox-ose}#testing-iso-with-virtualbox, ou bien copiée sur un support
optique ou un périphérique USB comme décrit dans {Graver une image ISO sur
un support physique}#burning-iso-image et {Copie d'un image ISO hybride sur
une clé USB}#copying-iso-hybrid-to-usb, respectivement.

2~tutorial-2 Tutoriel 2: Un utilitaire de navigateur Web

*{Cas d'utilisation:}* Créer une image d'un utilitaire de navigateur Web, en apprenant à appliquer des personnalisations. 

Dans ce tutoriel, nous allons créer une image utilisable comme un utilitaire
de navigateur Web, en servant d'introduction à la personnalisation d'images
Debian Live.

code{

 $ mkdir tutorial2
 $ cd tutorial2
 $ lb config -p lxde
 $ echo iceweasel >> config/package-lists/my.list.chroot

}code

Notre choix de LXDE pour cet exemple reflète notre volonté de fournir un
environnement de bureau minime, puisque le point de l'image est
l'utilisation unique que nous avons à l'esprit, le navigateur web. On
pourrait aller encore plus loin et offrir une configuration par défaut pour
le navigateur web dans #{config/includes.chroot/etc/iceweasel/profile/}#, ou
des paquets de soutien supplémentaires pour visualiser différents types de
contenu web, mais nous laissons cela comme une exercice pour le lecteur.

Construire l'image, encore une fois en tant que superutilisateur, garder un
journal comme dans {Tutoriel 1}#tutorial-1:

code{

 # lb build 2>&1 | tee binary.log

}code

Encore une fois, vérifiez que l'image est OK et faire un test, comme dans
{Tutoriel 1}#tutorial-1:

2~tutorial-3 Tutoriel 3: Une image personnalisée

*{Cas d'utilisation:}* Créer un projet pour construire une image personnalisée, contenant vos logiciels préférés à emporter avec vous sur une clé USB où que vous alliez, et évoluant dans des révisions successives selon vos besoins et vos préférences changent.

Puisque nous allons changer notre image personnalisée pendant un certain
nombre de révisions, et nous voulons suivre ces changements, d'essayer des
choses expérimentalement et éventuellement de les revenir si les choses ne
fonctionnent pas, nous garderons notre configuration dans le populaire
système de contrôle de version #{git}#. Nous allons également utiliser les
meilleures pratiques d'autoconfiguration via #{auto}# scripts tel que décrit
dans {Gestion d'une configuration}#managing-a-configuration.

3~ Première révision

code{

 $ mkdir -p tutorial3/auto
 $ cp /usr/share/live/build/examples/auto/* tutorial3/auto/
 $ cd tutorial3

}code

Éditer #{auto/config}# pour lire comme suit: 

code{

 #!/bin/sh

 lb config noauto \
     --architectures i386 \
     --linux-flavours 686-pae \
     --package-lists lxde \
     "${@}"

}code

Maintenant remplir votre liste de paquets locaux:

code{

 $ echo "iceweasel xchat" >> config/package-lists/my.list.chroot

}code

Tout d'abord, #{--architectures i386}# assure que sur notre système de
construction #{amd64}#, nous construisons une version 32 bits qui peut être
utilisé sur la plupart des machines. Deuxièmement, nous utilisons
#{--linux-flavours 686-pae}# parce que nous ne prévoyons pas utiliser cette
image sur des systèmes beaucoup plus anciens. Troisièmement, nous avons
choisi la liste de paquets /{lxde}/ pour nous donner un bureau minimal. Et
enfin, nous avons ajouté deux premiers paquets préférés: /{iceweasel}/ et
/{xchat}/.

Maintenant, construire l'image:

code{

 # lb build

}code

Notez que contrairement aux deux premiers tutoriels, nous n'avons plus
besoin de taper #{2>&1 | tee binary.log}# parce que cela est maintenant
inclus dans #{auto/build}#.

Une fois que vous avez testé l'image (comme dans {Tutoriel 1}#tutorial-1) et
êtes satisfait avec son fonctionnement, il est temps pour initialiser notre
dépôt #{git}#, ajoutant que les scripts d'auto que nous avons juste créé, et
ensuite faire le premier commit: 

code{

 $ git init
 $ git add auto
 $ git commit -a -m "Initial import."

}code

3~ Deuxième révision

Dans cette révision, nous allons nettoyer à partir de la première
construction, ajouter le paquet /{vlc}/ à notre configuration, reconstruire,
tester et faire le commit.

La commande #{lb clean}# va nettoyer tous les fichiers générés par la
construction précédente à l'exception du cache, ça évite d'avoir à
re-télécharger les paquets. Cela garantit que la #{lb build}# suivante
ré-exécutera toutes les étapes pour régénérer les fichiers de notre nouvelle
configuration.

code{

 # lb clean

}code

Maintenant ajouter le paquet /{vlc}/ à votre liste de paquets local dans
#{config/package-lists/my.list.chroot}#:

code{

 $ echo vlc >> config/package-lists/my.list.chroot

}code

Construire à nouveau:

code{

# lb build

}code

Tester, et quand vous êtes satisfaits, commit la prochaine révision:

code{

 $ git commit -a -m "Adding vlc media player."

}code

Bien sûr, des changements plus compliqués à la configuration sont possibles,
peut-être l'ajout de fichiers dans les sous-répertoires de
#{config/}#. Quand vous livrez des nouvelles révisions, on doit prendre soin
de ne pas modifier à la main ou envoyer au dépôt les fichiers de niveau
supérieur dans #{config}# contenant variables #{LB_*}#, car ce sont des
produits de creation, aussi, et sont toujours nettoyés par #{lb clean}# et
re-créés avec #{lb config}# via leur respectives #{auto}# scripts.

Nous sommes arrivés à la fin de notre série de tutoriels. Alors que de
nombreux types de personnalisations sont possibles, même juste en utilisant
les fonctionnalités explorées dans ces exemples simples, une variété presque
infinie d'images différentes peuvent être crées. Les autres exemples de
cette section couvrent plusieurs autres cas d'utilisation tirés des
expériences recueillies des utilisateurs de Debian Live.

2~ Un client Kiosk VNC 

*{Cas d'utilisation:}* Créer une image avec live-build pour démarrer directement à un serveur VNC.

Faire un répertoire de construction et créer une arborescence de fichiers
construit autour de la liste standard x11, avec /{gdm3}/, /{metacity}/ et
/{xvnc4viewer}/, désactivant «recommends» pour faire un système minimal:

code{

 $ mkdir vnc_kiosk_client
 $ cd vnc_kiosk_client
 $ lb config -a i386 -k 686-pae -p standard-x11 \
     --apt-recommends false
 $ echo "gdm3 metacity xvnc4viewer" >> config/package-lists/my.list.chroot

}code

Créez le répertoire #{/etc/skel}# avec une #{.xsession}# personnalisée pour
l'utilisateur par défaut qui va lancer /{metacity}/ et commencer
/{xvncviewer}/, en reliant le port #{5901}# sur un serveur à
#{192.168.1.2}#:

code{

 $ mkdir -p config/includes.chroot/etc/skel
 $ cat > config/includes.chroot/etc/skel/.xsession << END
 #!/bin/sh

 /usr/bin/metacity &
 /usr/bin/xvncviewer 192.168.1.2:1

 exit
 END

}code

Construire l'image:

code{

 # lb build

}code

Amusez-vous bien!

2~ Une image de base pour une clé USB de 128M

*{Cas d'utilisation:}* Créer une image standard avec certains composants éliminés afin de l'adapter sur une clé USB de 128M avec espace laissé pour l'utiliser à votre convenance.

Lorsque l'optimisation d'une image adaptée à une dimension des certains
supports, vous avez besoin de comprendre le compromis que vous faites entre
la taille et la fonctionnalité. Dans cet exemple, nous réduisons uniquement
que pour faire place à du matériel supplémentaire au sein d'une taille de
128M, mais sans rien faire pour détruire l'intégrité des paquets contenus,
telles que la purge des données de localisation via le paquet
/{localepurge}/, ou d'autres tels optimisations "intrusives". On notera en
particulier, vous ne devriez pas utiliser #{--bootstrap-flavour minimal}#
sauf si vous savez vraiment ce que vous faites, que l'omission de paquets de
priorité *{importante}* produira probablement un système live cassé.

code{

 $ lb config -k 486 -p minimal --apt-indices false \
     --memtest none --apt-recommends false --includes none

}code

Maintenant, construire l'image de la manière habituelle:

code{

 # lb build 2>&1 | tee binary.log

}code

Sur le système de l'auteur au moment de l'écriture, la configuration
ci-dessus produit une image de 78Mbyte. Cela se compare favorablement avec
l'image de 166Mbyte produite par la configuration par défaut dans {Tutoriel
1}#tutorial-1.

Le plus grand espace-économiseur ici, par rapport à la construction d'une
image standard sur une architecture #{i386}#, est de sélectionner uniquement
le saveur du noyau #{486}# au lieu de la valeur par défaut #{-k "486
686-pae"}#. Laissant hors indices APT avec #{--apt-indices false}# permet
aussi d'économiser une bonne quantité d'espace, le compromis étant que vous
devez faire  #{apt-get update}# avant d'utiliser apt dans le système
live. Le choix de la liste #{minimal}# laisse de côté les grands paquets de
#{locales}# et les services associés. Laissant hors les paquets recommandés
avec #{--apt-recommends false}# économise de l'espace supplémentaire, au
détriment d'omettre certains paquets vous pourriez autrement attendre à être
là, tel que /{firmware-linux-free}/ qui peuvent être nécessaires pour
soutenir certains supports matériels. Les options restantes économisent
petites quantités d'espace supplémentaires. C'est à vous de décider si la
fonctionnalité qui est sacrifié avec chaque optimisation est en vaut la
perte de fonctionnalité.

2~ Un bureau KDE localisé et installateur 

*{Cas d'utilisation:}* Créer une image de bureau KDE, localisé pour le portugais brésilien et incluant un installateur.

Nous voulons faire une image iso-hybride pour l'architecture i386 en
utilisant notre bureau préféré, dans ce cas, KDE, contenant tous les paquets
mêmes qui seraient installés par l'installateur Debian standard pour KDE.

Notre premier problème est la découverte des noms des tâches
appropriées. Actuellement, live-build ne peut pas aider. Alors que nous
pourrions être chanceux et trouver ce par essais et erreurs, il y a un
outil, #{grep-dctrl}#, qui peut être utilisé pour découvrir des descriptions
de tâches dans tasksel-data, de sorte à préparer, assurez-vous que vous avez
ces deux choses:

code{

 # apt-get install dctrl-tools tasksel-data

}code

Maintenant, nous pouvons rechercher les tâches appropriées, d'abord avec:

code{

 $ grep-dctrl -FTest-lang pt_BR /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: brazilian-portuguese

}code

Par cette commande, nous découvrons la tâche est appelée, assez clairement,
brazilian-portuguese. Maintenant, pour trouver les tâches liées:

code{

 $ grep-dctrl -FEnhances brazilian-portuguese /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: brazilian-portuguese-desktop
 Task: brazilian-portuguese-kde-desktop

}code

Au démarrage nous allons générer les paramètres régionaux pt_BR.UTF-8 et
sélectionner la configuration du clavier pt-latin1. Nous aurons aussi besoin
de préconfigurer notre choix de bureau, "kde" de sorte que tasksel
installera la tâche de bureau correcte, car elle diffère de la valeur par
défaut (Voir {Tâches de bureau et de la
langue}#desktop-and-language-tasks). Maintenant, nous allons assembler les
pièces:

code{

 $ mkdir live-pt_BR-kde
 $ cd live-pt_BR-kde
 $ lb config \
     -a i386 \
     -k 486 \
     --bootappend-live "locales=pt_BR.UTF-8 keyboard-layouts=pt-latin1" \
     --debian-installer live
 $ echo kde-desktop brazilian-portuguese brazilian-portuguese-desktop \
     brazilian-portuguese-kde-desktop >> config/task-lists/my.list.chroot
 $ echo debian-installer-launcher >> config/package-lists/my.list.chroot
 $ echo tasksel tasksel/desktop multiselect kde >> config/preseed/my.preseed.chroot

}code

Notez que nous avons inclus le paquet debian-installer-launcher pour lancer
l'installateur à partir du bureau live, nous avons également précisé le
noyau 486, parce qu'il est actuellement nécessaire faire que l'installateur
et le noyau du systéme live coïncident pour que le lanceur fonctionne
correctement.
