:B~ Exemples

1~examples  Exemples

Ce chapitre s'occupe d'exemples de constructions pour les cas d'utilisation
spécifiques avec Debian Live. Si vous êtes nouveau avec la construction de
vos propres images Debian Live, nous vous recommandons d'abord regarder les
trois tutoriels en séquence, comme chacun apprend nouvelles techniques qui
vous aideront à utiliser et à comprendre les exemples restants.

2~using-the-examples En utilisant les exemples

Pour utiliser ces exemples vous avez besoin d'un système pour les
construire, lequel répond aux exigences énumérées dans
{Exigences}#requirements et qui a live-build installé comme décrit à
{Installation de live-build}#installing-live-build.

Notez que, pour des raisons de concision, dans ces exemples, nous ne
spécifions pas un miroir local à utiliser pour la construction. Vous pouvez
accélérer considérablement les téléchargements si vous utilisez un miroir
local. Vous pouvez spécifier les options lorsque vous utilisez #{lb
config}#, tel que décrit dans {Miroirs de distribution utilisés au temps de
construction}#distribution-mirrors-build-time, ou pour plus de commodité,
fixez par défaut votre système de construction dans
#{/etc/live/build.conf}#. Il suffit de créer ce fichier et de définir les
variables #{LB_MIRROR_*}# correspondantes à votre miroir préféré. Tous les
autres miroirs utilisés dans la construction seront par défaut à partir de
ces valeurs. Par exemple:

code{

 LB_MIRROR_BOOTSTRAP="http://mirror/debian"
 LB_MIRROR_CHROOT_SECURITY="http://mirror/debian-security"
 LB_MIRROR_CHROOT_BACKPORTS="http://mirror/debian-updates"

}code

2~tutorial-1 Tutorial 1: Une image standard

*{Cas d'utilisation:}* Créer une image simple d'abord, apprenant les bases de live-build.

Dans ce tutoriel, nous construirons une image Debian Live ISO hybride par
défaut contenant uniquement paquets de base (pas de Xorg) et quelques
paquets Debian de soutien live, comme un premier exercice en utilisant
live-build.

Vous ne pouvez pas obtenir beaucoup plus simple que cela:

code{

 $ mkdir tutorial1 ; cd tutorial1 ; lb config

}code

Examinez le contenu du répertoire #{config/}# si vous le souhaitez. Vous
verrez stockés ici une configuration du squelette, pour être personnalise
ou, dans ce cas, utiliser immédiatement pour construire une image par
défaut.

Maintenant, en tant que superutilisateur, construire l'image en enregistrant
un journal avec #{tee}#.

code{

 # lb build 2>&1 | tee binary.log

}code

En supposant que tout se passe bien, après un certain temps, le répertoire
courant contient #{binary-hybrid.iso}#. Cette image ISO hybride peut être
démarré directement dans une machine virtuelle comme décrit dans {Test d'une
image ISO avec QEMU}#testing-iso-with-qemu et {Test d'une image ISO avec
virtualbox-ose}#testing-iso-with-virtualbox, ou bien copiés sur un support
optique ou un périphérique USB comme décrit dans {Graver une image ISO sur
un support physique}#burning-iso-image et {Copie d'un image ISO hybride sur
une clé USB}#copying-iso-hybrid-to-usb, respectivement.

2~tutorial-2 Tutoriel 2: Un utilitaire de navigateur Web

*{Cas d'utilisation:}* Créer une image d'un utilitaire de navigateur Web, en apprenant à appliquer des personnalisations. 

Dans ce tutoriel, nous allons créer une image utilisable comme un utilitaire
de navigateur Web, en servant d'introduction à la personnalisation d'images
Debian Live.

code{

 $ mkdir tutorial2
 $ cd tutorial2
 $ lb config -p lxde
 $ echo iceweasel >> config/package-lists/my.list.chroot

}code

Notre choix de LXDE pour cet exemple reflète notre volonté de fournir un
environnement de bureau minime, puisque le point de l'image est
l'utilisation unique, nous avons à l'esprit, le navigateur web. On pourrait
aller encore plus loin et offrir une configuration par défaut pour le
navigateur web dans #{config/includes.chroot/etc/iceweasel/profile/}#, ou
des paquets de soutien supplémentaires pour visualiser différents types de
contenu web, mais nous laissons cela comme une exercice pour le lecteur.

Construire l'image, encore une fois en tant que superutilisateur, tenir un
journal comme dans {Tutoriel 1}#tutorial-1:

code{

 # lb build 2>&1 | tee binary.log

}code

Encore une fois, vérifiez que l'image est OK et faire un test, comme dans
{Tutoriel 1}#tutorial-1:

2~tutorial-3 Tutoriel 3: Une image personnalisée

*{Cas d'utilisation:}* Créer un projet pour construire une image personnalisée, contenant vos logiciels préférés à emporter avec vous sur une clé USB où que vous alliez, et évoluant dans des révisions successives selon vos besoins et vos préférences changent.

Puisque nous allons changer notre image personnalisée pendant un certain
nombre de révisions, et nous voulons suivre ces changements, d'essayer des
choses expérimentalement et éventuellement de les revenir si les choses ne
fonctionnent pas, nous garderons notre configuration dans le populaire
système de contrôle de version #{git}#. Nous allons également utiliser les
meilleures pratiques d'autoconfiguration via #{auto}# scripts tel que décrit
dans {Gestion d'une configuration}#managing-a-configuration.

3~ Première révision

code{

 $ mkdir -p tutorial3/auto
 $ cp /usr/share/live/build/examples/auto/* tutorial3/auto/
 $ cd tutorial3

}code

Éditer #{auto/config}# pour lire comme suit: 

code{

 #!/bin/sh

 lb config noauto \
     --architectures i386 \
     --linux-flavours 686-pae \
     --package-lists lxde \
     "${@}"

}code

Maintenant remplir votre liste de paquets locaux:

code{

 $ echo "iceweasel xchat" >> config/package-lists/my.list.chroot

}code

Tout d'abord, #{--architectures i386}# assure que sur notre système de
construction #{amd64}#, nous construisons une version 32 bits qui peut être
utilisé sur la plupart des machines. Deuxièmement, nous utilisons
#{--linux-flavours 686-pae}# parce que nous ne prévoyons pas utiliser cette
image sur des systèmes beaucoup plus anciens. Troisièmement, nous avons
choisi la liste des paquets #{lxde}# pour nous donner un bureau minimal. Et
enfin, nous avons ajouté deux premiers paquets préférés: #{iceweasel}# et
#{xchat}#.

Maintenant, construire l'image:

code{

 # lb build

}code

Notez que contrairement aux deux premiers tutoriels, nous n'avons plus
besoin de taper #{2>&1 | tee binary.log}# parce que cela est maintenant
inclus dans #{auto/build}#.

Une fois que vous avez testé l'image (comme dans {Tutoriel 1}#tutorial-1) et
êtes satisfait avec son fonctionnement, il est temps pour initialiser notre
référentiel #{git}#, ajoutant que les scripts d'auto que nous avons juste
créé, et ensuite faire le premier commit: 

code{

 $ git init
 $ git add auto
 $ git commit -a -m "Initial import."

}code

3~ Deuxième révision

In this revision, we're going to clean up from the first build, add the
/{vlc}/ package to our configuration, rebuild, test and commit.

La commande #{lb clean}# va nettoyer tous les fichiers générés par la
construction précédente à l'exception du cache, ça évite d'avoir à
re-télécharger les paquets. Cela garantit que le #{lb build}# postérieure
ré-exécutera toutes les étapes pour régénérer les fichiers de notre nouvelle
configuration.

code{

 # lb clean

}code

Now append the /{vlc}/ package to our local package list in
#{config/package-lists/my.list.chroot}#:

code{

 $ echo vlc >> config/package-lists/my.list.chroot

}code

Construire à nouveau:

code{

# lb build

}code

Tester, et quand vous êtes satisfaits, commit la prochaine révision:

code{

 $ git commit -a -m "Adding vlc media player."

}code

Bien sûr, des changements plus compliqués à la configuration sont possibles,
peut-être l'ajout de fichiers dans les sous-répertoires de
#{config/}#. Quand vous livrez des nouvelles révisions, on doit prendre soin
de ne pas modifier à la main ou envoyer au dépôt les fichiers de niveau
supérieur dans #{config}# contenant variables #{LB_*}#, car ce sont des
produits de creation, aussi, et sont toujours nettoyés par #{lb clean}# et
re-créés avec #{lb config}# via leur respectives #{auto}# scripts.

Nous sommes arrivés à la fin de notre série de tutoriels. Alors que de
nombreux types de personnalisations sont possibles, même juste en utilisant
les fonctionnalités explorées dans ces exemples simples, une variété presque
infinie d'images différentes peuvent être crées. Les autres exemples de
cette section couvrent plusieurs autres cas d'utilisation tirés des
expériences recueillies des utilisateurs de Debian Live.

2~ Un client Kiosk VNC 

*{Cas d'utilisation:}* Créer une image avec live-build pour démarrer directement à un serveur VNC.

Make a build directory and create a skeletal configuration in it built
around the standard-x11 list, including /{gdm3}/, /{metacity}/ and
/{xvnc4viewer}/, disabling recommends to make a minimal system:

code{

 $ mkdir vnc_kiosk_client
 $ cd vnc_kiosk_client
 $ lb config -a i386 -k 686-pae -p standard-x11 \
     --apt-recommends false
 $ echo "gdm3 metacity xvnc4viewer" >> config/package-lists/my.list.chroot

}code

Create the directory #{/etc/skel}# and put a custom #{.xsession}# in it for
the default user that will launch /{metacity}/ and start /{xvncviewer}/,
connecting to port #{5901}# on a server at #{192.168.1.2}#:

code{

 $ mkdir -p config/includes.chroot/etc/skel
 $ cat > config/includes.chroot/etc/skel/.xsession << END
 #!/bin/sh

 /usr/bin/metacity &
 /usr/bin/xvncviewer 192.168.1.2:1

 exit
 END

}code

Construire l'image:

code{

 # lb build

}code

Amusez-vous bien!

2~ Une image de base pour une clé USB de 128M

*{Cas d'utilisation:}* Créer une image standard avec certains composants éliminés afin de s'adapter sur une clé USB avec 128M avec espace laissé pour l'utiliser à votre convenance.

When optimizing an image to fit a certain media size, you need to understand
the tradeoffs you are making between size and functionality. In this
example, we trim only so much as to make room for additional material within
a 128M media size, but without doing anything to destroy integrity of the
packages contained within, such as the purging of locale data via the
/{localepurge}/ package, or other such "intrusive" optimizations. Of
particular note, you should not use #{--bootstrap-flavour minimal}# unless
you really know what you're doing, as omitting priority #{important}#
packages will most likely produce a broken live system.

code{

 $ lb config -k 486 -p minimal --apt-indices false \
     --memtest none --apt-recommends false --includes none

}code

Maintenant, construire l'image de la manière habituelle:

code{

 # lb build 2>&1 | tee binary.log

}code

Sur le système de l'auteur au moment de l'écriture, la configuration
ci-dessus produit une image de 78Mbyte. Cela se compare favorablement avec
l'image de 166Mbyte produite par la configuration par défaut dans {Tutoriel
1}#tutorial-1.

The biggest space-saver here, compared to building a standard image on an
#{i386}# architecture system, is to select only the #{486}# kernel flavour
instead of the default #{-k "486 686-pae"}#. Leaving off APT's indices with
#{--apt-indices false}# also saves a fair amount of space, the tradeoff
being that you need to #{apt-get update}# before using apt in the live
system. Choosing the #{minimal}# package list leaves out the large
#{locales}# package and associated utilities. Dropping recommended packages
with #{--apt-recommends false}# saves some additional space, at the expense
of omitting some packages you might otherwise expect to be there, such as
/{firmware-linux-free}/ which may be needed to support certain hardware. The
remaining options shave off additional small amounts of space. It's up to
you to decide if the functionality that is sacrificed with each optimization
is worth the loss in functionality.

2~ Un bureau KDE localisé et installateur 

*{Cas d'utilisation:}* Créer une image de bureau KDE, localisé pour le portugais brésilien et incluant un installateur.

Nous voulons faire une image iso-hybride pour l'architecture i386 en
utilisant notre bureau préféré, dans ce cas, KDE, contenant tous les paquets
mêmes qui seraient installés par l'installateur Debian standard pour KDE.

Notre premier problème est la découverte des noms des tâches
appropriées. Actuellement, live-build ne peut pas aider. Alors que nous
pourrions être chanceux et trouver ce par essais et erreurs, il y a un
outil, #{grep-dctrl}#, qui peut être utilisé pour découvrir des descriptions
de tâches dans tasksel-data, de sorte à préparer, assurez-vous que vous avez
ces deux choses:

code{

 # apt-get install dctrl-tools tasksel-data

}code

Maintenant, nous pouvons rechercher les tâches appropriées, d'abord avec:

code{

 $ grep-dctrl -FTest-lang pt_BR /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: brazilian-portuguese

}code

Par cette commande, nous découvrons la tâche est appelée, assez clairement,
brazilian-portuguese. Maintenant, pour trouver les tâches liées:

code{

 $ grep-dctrl -FEnhances brazilian-portuguese /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: brazilian-portuguese-desktop
 Task: brazilian-portuguese-kde-desktop

}code

Au démarrage nous allons générer les paramètres régionaux pt_BR.UTF-8 et
sélectionner la configuration du clavier pt-latin1. Nous aurons aussi besoin
de préconfigurer notre choix de bureau, "kde" de sorte que tasksel
installera la tâche de bureau correcte, car elle diffère de la valeur par
défaut (Voir {Tâches de bureau et de la
langue}#desktop-and-language-tasks). Maintenant, nous allons assembler les
pièces:

code{

 $ mkdir live-pt_BR-kde
 $ cd live-pt_BR-kde
 $ lb config \
     -a i386 \
     -k 486 \
     --bootappend-live "locales=pt_BR.UTF-8 keyboard-layouts=pt-latin1" \
     --debian-installer live
 $ echo kde-desktop brazilian-portuguese brazilian-portuguese-desktop \
     brazilian-portuguese-kde-desktop >> config/task-lists/my.list.chroot
 $ echo debian-installer-launcher >> config/package-lists/my.list.chroot
 $ echo tasksel tasksel/desktop multiselect kde >> config/preseed/my.preseed.chroot

}code

Note that we have included the debian-installer-launcher package to launch
the installer from the live desktop, and have also specified the 486 flavour
kernel, as it is currently necessary to make the installer and live system
kernels match for the launcher to work properly.
