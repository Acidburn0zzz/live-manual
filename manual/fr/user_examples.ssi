:B~ Exemples

1~examples  Exemples

Ce chapitre s'occupe d'exemples de constructions pour les cas d'utilisation
spécifiques avec Debian Live. Si vous êtes nouveau avec la construction de
vos propres images Debian Live, nous vous recommandons d'abord regarder les
trois tutoriels en séquence, comme chacun apprend nouvelles techniques qui
vous aideront à utiliser et à comprendre les exemples restants.

2~using-the-examples En utilisant les exemples

Pour utiliser ces exemples vous avez besoin d'un système pour les
construire, lequel répond aux exigences énumérées dans
{Exigences}#requirements et vous avez live-build installe comme décrit à
{Installation de live-build}#installing-live-build.

Note that, for the sake of brevity, in these examples we do not specify a
local mirror to use for the build. You can speed up downloads considerably
if you use a local mirror. You may specify the options when you use #{lb
config}#, as described in {Distribution mirrors used at build
time}#distribution-mirrors-build-time, or for more convenience, set the
default for your build system in #{/etc/live/build.conf}#. Simply create
this file and in it, set the corresponding #{LB_PARENT_MIRROR_*}# variables
to your preferred mirror. All other mirrors used in the build will be
defaulted from these values. For example:

code{

 LB_PARENT_MIRROR_BOOTSTRAP="http://mirror/debian"
 LB_PARENT_MIRROR_CHROOT_SECURITY="http://mirror/debian-security"
 LB_PARENT_MIRROR_CHROOT_BACKPORTS="http://mirror/debian-updates"

}code

2~tutorial-1 Tutorial 1: Une image standard

*{Cas d'utilisation:}* Créer une image simple d'abord, apprenant les bases de live-build.

Dans ce tutoriel, nous construirons une image Debian Live ISO hybride par
défaut contenant uniquement paquets de base (pas de Xorg) et quelques
paquets Debian de soutien live, comme un premier exercice en utilisant
live-build.

Vous ne pouvez pas obtenir beaucoup plus simple que cela:

code{

 $ mkdir tutorial1 ; cd tutorial1 ; lb config

}code

Examinez le contenu du répertoire #{config/}# si vous le souhaitez. Vous
verrez stockés ici une configuration du squelette, pour être personnalise
ou, dans ce cas, utiliser immédiatement pour construire une image par
défaut.

Maintenant, en tant que superutilisateur, construire l'image en enregistrant
un journal avec #{tee}#.

code{

 # lb build 2>&1 | tee binary.log

}code

En supposant que tout se passe bien, après un certain temps, le répertoire
courant contient #{binary-hybrid.iso}#. Cette image ISO hybride peut être
démarré directement dans une machine virtuelle comme décrit dans {Test d'une
image ISO avec QEMU}#testing-iso-with-qemu et {Test d'une image ISO avec
virtualbox-ose}#testing-iso-with-virtualbox, ou bien copiés sur un support
optique ou un périphérique USB comme décrit dans {Graver une image ISO sur
un support physique}#burning-iso-image et {Copie d'un image ISO hybride sur
une clé USB}#copying-iso-hybrid-to-usb, respectivement.

2~tutorial-2 Tutoriel 2: Un utilitaire de navigateur Web

*{Cas d'utilisation:}* Créer une image d'un utilitaire de navigateur Web, en apprenant à appliquer des personnalisations. 

Dans ce tutoriel, nous allons créer une image utilisable comme un utilitaire
de navigateur Web, en servant d'introduction à la personnalisation d'images
Debian Live.

code{

 $ mkdir tutorial2 ; cd tutorial2 ; lb config -p lxde --packages iceweasel

}code

Notre choix de LXDE pour cet exemple reflète notre volonté de fournir un
environnement de bureau minime, puisque le point de l'image est
l'utilisation unique, nous avons à l'esprit, le navigateur web. On pourrait
aller encore plus loin et offrir une configuration par défaut pour le
navigateur web dans #{config/chroot_local-includes/etc/iceweasel/profile/}#,
ou des paquets de soutien supplémentaires pour visualiser différents types
de contenu web, mais nous laissons cela comme une exercice pour le lecteur.

Construire l'image, encore une fois en tant que superutilisateur, tenir un
journal comme dans {Tutoriel 1}#tutorial-1:

code{

 # lb build 2>&1 | tee binary.log

}code

Encore une fois, vérifiez que l'image est OK et faire un test, comme dans
{Tutoriel 1}#tutorial-1:

2~tutorial-3 Tutoriel 3: Une image personnalisée

*{Cas d'utilisation:}* Créer un projet pour construire une image personnalisée, contenant vos logiciels préférés à emporter avec vous sur une clé USB où que vous alliez, et évoluant dans des révisions successives selon vos besoins et vos préférences changent.

Puisque nous allons changer notre image personnalisée pendant un certain
nombre de révisions, et nous voulons suivre ces changements, d'essayer des
choses expérimentalement et éventuellement de les revenir si les choses ne
fonctionnent pas, nous garderons notre configuration dans le populaire
système de contrôle de version #{git}#. Nous allons également utiliser les
meilleures pratiques d'autoconfiguration via #{auto}# scripts tel que décrit
dans {Gestion d'une configuration}#managing-a-configuration.

3~ Première révision

code{

 $ mkdir -p tutorial3/auto
 $ cp /usr/share/live/build/examples/auto/* tutorial3/auto/
 $ cd tutorial3

}code

Éditer #{auto/config}# pour lire comme suit: 

code{

 #!/bin/sh

 lb config noauto \
     --architecture i386 \
     --linux-flavours 686 \
     --packages-lists lxde \
     --packages "iceweasel xchat" \
     "${@}"

}code

Tout d'abord, #{--architecture i386}# assure que sur notre système de
construction #{amd64}#, nous construisons une version 32 bits qui peut être
utilisé sur la plupart des machines. Deuxièmement, nous utilisons
#{--linux-flavours 686}# parce que nous ne prévoyons pas utiliser cette
image sur des systèmes beaucoup plus anciens. Troisièmement, nous avons
choisi la liste des paquets #{lxde}# pour nous donner un bureau minimal. Et
enfin, nous avons ajouté deux premiers paquets préférés: #{iceweasel}# et
#{xchat}#.

Maintenant, construire l'image:

code{

 # lb build

}code

Notez que contrairement aux deux premiers tutoriels, nous n'avons plus
besoin de taper #{2>&1 | tee binary.log}# parce que cela est maintenant
inclus dans #{auto/build}#.

Une fois que vous avez testé l'image (comme dans {Tutoriel 1}#tutorial-1) et
êtes satisfait avec son fonctionnement, il est temps pour initialiser notre
référentiel #{git}#, ajoutant que les scripts d'auto que nous avons juste
créé, et ensuite faire le premier commit: 

code{

 $ git init
 $ git add auto
 $ git commit -a -m "Initial import."

}code

3~ Deuxième révision

Dans cette révision, nous allons nettoyer à partir de la première
construction, ajouter le paquet #{vlc}# à notre configuration, reconstruire,
tester et faire le commit.

La commande #{lb clean}# va nettoyer tous les fichiers générés par la
construction précédente à l'exception du cache, ça évite d'avoir à
re-télécharger les paquets. Cela garantit que le #{lb build}# postérieure
ré-exécutera toutes les étapes pour régénérer les fichiers de notre nouvelle
configuration.

code{

 # lb clean

}code

Maintenant, éditez #{auto/config}# pour ajouter le paquet #{vlc}#:

code{

 #!/bin/sh

 lb config noauto \
     --architecture i386 \
     --linux-flavours 686 \
     --packages-lists lxde \
     --packages "iceweasel xchat vlc" \
     "${@}"

}code

Construire à nouveau:

code{

# lb build

}code

Tester, et quand vous êtes satisfaits, commit la prochaine révision:

code{

 $ git commit -a -m "Adding vlc media player."

}code

Bien sûr, des changements plus compliqués à la configuration sont possibles,
peut-être l'ajout de fichiers dans les sous-répertoires de
#{config/}#. Quand vous livrez des nouvelles révisions, il suffit de prendre
soin de ne pas modifier à la main ou commit les fichiers de niveau supérieur
dans #{config}# contenant variables #{LB_*}#, car ce sont des produits de
creation, aussi, et sont toujours nettoyés par #{lb clean}# et re-créés avec
#{lb config}# via leur respectives #{auto}# scripts.

Nous sommes arrivés à la fin de notre série de tutoriels. Alors que de
nombreux types de personnalisations sont possibles, même juste en utilisant
les fonctionnalités explorées dans ces exemples simples, une variété presque
infinie d'images différentes peuvent être crées. Les autres exemples de
cette section couvrent plusieurs autres cas d'utilisation tirés des
expériences recueillies des utilisateurs de Debian Live.

2~ Un client Kiosk VNC 

*{Cas d'utilisation:}* Créer une image avec live-build pour démarrer directement à un serveur VNC.

Faire un répertoire de construction et créer une configuration du squelette
construit autour de la liste standard x11, avec #{gdm3}#, #{metacity}# et
#{xtightvncviewer}#, désactivant «recommends» pour faire un système minimal:

code{

 $ mkdir vnc_kiosk_client
 $ cd vnc_kiosk_client
 $ lb config -a i386 -k 686 -p standard-x11 \
     --packages "gdm3 metacity xvnc4viewer" \
     --apt-recommends false

}code

Créez le répertoire #{/etc/skel}# avec une #{.xsession}# personnalisée pour
l'utilisateur par défaut qui va lancer metacity et commencer xvncviewer, en
reliant le port #{5901}# sur un serveur à  #{192.168.1.2}#:

code{

 $ mkdir -p config/chroot_local-includes/etc/skel
 $ cat >config/chroot_local-includes/etc/skel/.xsession <<END
 #!/bin/sh

 /usr/bin/metacity &
 /usr/bin/xvncviewer 192.168.1.2:1

 exit
 END

}code

Construire l'image:

code{

 # lb build

}code

Amusez-vous bien!

2~ Une image de base pour une clé USB de 128M

*{Cas d'utilisation:}* Créer une image standard avec certains composants éliminés afin de s'adapter sur une clé USB avec 128M avec espace laissé pour l'utiliser à votre convenance.

Lorsque l'optimisation d'une image adaptée à une dimension des certains
supports, vous avez besoin de comprendre le compromis que vous faites entre
la taille et la fonctionnalité. Dans cet exemple, nous réduisons uniquement
que pour faire place à du matériel supplémentaire au sein d'une taille de
128M, mais sans rien faire pour détruire l'intégrité des paquets contenus,
telles que la purge des données de localisation via le paquet
#{localepurge}#, ou d'autres tels optimisations "intrusives". On notera en
particulier, vous ne devriez pas utiliser #{--bootstrap-flavour minimal}#
sauf si vous savez vraiment ce que vous faites, que l'omission de paquets de
priorité #{importants}# produira probablement un système live cassé.

code{

 $ lb config -k 486 -p minimal --binary-indices false \
     --memtest none --apt-recommends false --includes none

}code

Maintenant, construire l'image de la manière habituelle:

code{

 # lb build 2>&1 | tee binary.log

}code

Sur le système de l'auteur au moment de l'écriture, la configuration
ci-dessus produit une image de 78Mbyte. Cela se compare favorablement avec
l'image de 166Mbyte produite par la configuration par défaut dans {Tutoriel
1}#tutorial-1.

Le plus grand espace-économiseur ici, par rapport à la construction d'une
image standard sur une architecture #{i386}#, est de sélectionner uniquement
le saveur du noyau #{486}# au lieu de la valeur par défaut #{-k "486
686"}#. Laissant hors indices APT avec #{--binary-indices false}# permet
aussi d'économiser une bonne quantité d'espace, le compromis étant que vous
devez faire  #{apt-get update}# avant d'utiliser apt dans le système
live. Le choix de la liste #{minimal}# laisse de côté les grands paquets de
#{locales}# et les services associés. Laissant hors les paquets recommandés
économise de l'espace supplémentaire, au détriment d'omettre certains
paquets vous pourriez autrement s'attendre à être là, tel que
#{firmware-linux-free}# qui peuvent être nécessaires pour prise en charge
matérielle de certains supports matériels. Les options restantes économisent
petites quantités d'espace supplémentaires. C'est à vous de décider si la
fonctionnalité qui est sacrifié avec chaque optimisation est en vaut la
perte de fonctionnalité.

2~ Un bureau KDE localisé et installateur 

*{Cas d'utilisation:}* Créer une image de bureau KDE, localisé pour le portugais brésilien et incluant un installateur.

Nous voulons faire une image iso-hybride pour l'architecture i386 en
utilisant notre bureau préféré, dans ce cas, KDE, contenant tous les paquets
mêmes qui seraient installés par l'installateur Debian standard pour KDE.

Notre premier problème est la découverte des noms des tâches
appropriées. Actuellement, live-build ne peut pas aider. Alors que nous
pourrions être chanceux et trouver ce par essais et erreurs, il y a un
outil, #{grep-dctrl}#, qui peut être utilisé pour découvrir des descriptions
de tâche dans tasksel-data, de sorte à préparer, assurez-vous que vous avez
ces deux choses:

code{

 # apt-get install dctrl-tools tasksel-data

}code

Maintenant, nous pouvons rechercher les tâches appropriées, d'abord avec:

code{

 $ grep-dctrl -FTest-lang pt_BR /usr/share/tasksel/debian-tasks.desc -sTask,Description
 Task: brazilian-portuguese
 Description: Brazilian Portuguese environment
  This task installs programs, data files, and
  documentation that make it easier for Brazilian Portuguese speakers
  to use Debian.

}code

Par cette commande, nous découvrons la tâche est appelée, assez clairement,
brazilian-portuguese. Maintenant, pour trouver les tâches liées:

code{

 $ grep-dctrl -FEnhances brazilian-portuguese /usr/share/tasksel/debian-tasks.desc -sTask,Description
 Task: brazilian-portuguese-desktop
 Description: Brazilian Portuguese desktop
  This task localises the desktop in Brasilian Portuguese.

 Task: brazilian-portuguese-kde-desktop
 Description: Brazilian Portuguese KDE desktop
  This task localises the KDE desktop in Brazilian Portuguese.

}code

Nous allons utiliser l'option expérimentale #{--language}#, comme live-build
inclut #{syslinux}# pour pt_BR  (voir {Tâches de bureau et de la
langue}#desktop-and-language-tasks pour plus de détails). Et au moment du
démarrage nous allons générer les  paramètres régionaux pt_BR.UTF-8 et
sélectionner la configuration du clavier pt-latin1. Maintenant, nous allons
mettre les pièces ensemble:

code{

 $ mkdir live-pt_BR-kde
 $ cd live-pt_BR-kde
 $ lb config \
     -a i386 \
     -k 486 \
     -p kde-desktop \
     --language pt_BR \
     --tasks "brazilian-portuguese brazilian-portuguese-desktop brazilian-portuguese-kde-desktop" \
     --bootappend-live "locales=pt_BR.UTF-8 keyboard-layouts=pt-latin1" \
     --debian-installer live \
     --packages debian-installer-launcher

}code

Notez que nous avons inclus le paquet #{debian-installer-launcher}# pour
lancer l'installateur depuis le bureau live, et ont également précisé que le
noyau 486, tel qu'il est actuellement nécessaire pour faire que
l'installateur et le noyau du systéme live matchent pour que le lanceur
fonctionne correctement.
