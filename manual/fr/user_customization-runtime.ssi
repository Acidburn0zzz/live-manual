:B~ Personnalisation des comportements au moment de l'exécution

1~customizing-run-time-behaviours Personnalisation des comportements au
moment de l'exécution

Toute la configuration qui est faite pendant l'exécution est faite par
live-config. Voici quelques options les plus courantes de live-config
d'intérêt pour les utilisateurs. Une liste complète de toutes les
possibilités peut être trouvée dans la page de manuel de live-config.

2~ Personnalisation de l'utilisateur Live

Une considération importante est que l'utilisateur live est créé par
live-boot au démarrage, non pas par live-config au moment de la
construction. Ça influence non seulement là où les documents relatifs à
l'utilisateur live sont introduits dans votre construction, tel que discuté
dans {Live/chroot local includes}#live-chroot-local-includes, mais aussi
tous les groupes et les autorisations associées à l'utilisateur live.

Vous pouvez spécifier d'autres groupes pour l'utilisateur live en
préconfigurant la valeur debconf #{passwd/user-default-groups}#. Par
exemple, pour ajouter l'utilisateur live au groupe #{fuse}# pendant l'étape
chroot, ajoutez la ligne suivante à un fichier dans le répertoire
#{config/chroot_local-preseed}#:

code{

 $ lb config
 $ echo user-setup passwd/user-default-groups string audio cdrom \
   dip floppy video plugdev netdev powerdev scanner bluetooth fuse \
   >> config/preseed/my.preseed.chroot

}code

Il est également possible de changer le nom d'utilisateur par défaut «user»
et du mot de passe par défaut "live". Si vous voulez pour quelque raison,
vous pouvez facilement faire ça comme suit:

Pour modifier le nom d'utilisateur par défaut, vous pouvez simplement le
spécifier dans votre config:

code{

 $ lb config --bootappend-live "username=live-user"

}code

Une façon possible de changer le mot de passe par défaut est au moyen d'un
hook comme décrit dans {Hooks au moment du démarrage}#boot-time-hooks. Pour
ce faire vous pouvez utiliser le hook "passwd" de
#{/usr/share/doc/live-config/examples/hooks}#, ajouter un préfixe correct
(par exemple 200-passwd) et l'ajouter à
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Personnalisation des paramètres régionaux
et la langue

Au démarrage du système live, la langue est impliqué dans trois étapes:

_* la génération des paramètres régionaux

_* réglage de la disposition du clavier pour la console

_* réglage de la disposition du clavier pour X

Les paramètres régionaux par défaut pendant la construction d'un système
Live sont "locales=en_US.UTF-8". Pour définir les paramètres régionaux qui
doivent être générés, utilisez le paramètre #{locales}# dans l'option
#{--bootappend-live}# de #{lb config}#, par exemple

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

Ce paramètre peut également être utilisé à la ligne de commande du
noyau. Vous pouvez spécifier des paramètres régionaux par
#{language_country.encoding}#.

Tant la console et la configuration du clavier X dépendent du paramètre
#{keyboard-layouts}# de l'option #{--bootappend-live}#. Options valides pour
les dispositions des claviers X peuvent être trouvés dans
#{/usr/share/X11/xkb/rules/base.xml}# (plutôt limitées à des codes des pays
à deux lettres). Pour trouver la valeur (les deux caractères), correspondant
à une langue essayez de rechercher le nom anglais de la nation où la langue
est parlée, par exemple:

code{

 $ grep -i sweden -C3 /usr/share/X11/xkb/rules/base.xml | grep name
 <name>se</name>

}code

Pour obtenir les fichiers des paramètres régionaux de l'allemand et la
disposition du clavier suisse allemand dans X utiliser:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

Une liste des valeurs valides des claviers pour la console peut être figuré
avec la commande suivante:

code{

 $ for i in $(find /usr/share/keymaps/ -iname "*kmap.gz"); \
     do basename $i | head -c -9; echo; done | sort | less

}code

Alternativement, vous pouvez utiliser le paquet #{console-setup}#, un outil
pour vous permettre de configurer la disposition de la console en utilisant
définitions X (XKB), vous pouvez alors définir votre clavier plus
précisément avec variables #{keyboard-layouts}#, #{keyboard-variant}#,
#{keyboard-options}# et #{keyboard-model}#; live-boot pourra également
utiliser ces paramètres pour la configuration de X. Par exemple, pour mettre
en place un système français avec une disposition Français Dvorak (appelée
Bepo) sur un clavier TypeMatrix, à la fois dans la console et X11, utilisez:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variant=bepo keyboard-model=tm2030usb"

}code

2~persistence Persistance

Un paradigme d'un Live CD est être un système pré-installé qui amorce sur un
support en lecture seule, comme un cdrom, où les données et les
modifications ne survivent pas aux redémarrages du matériel hôte qui
l'exécute.

Un système Debian Live est une généralisation de ce paradigme et soutient
ainsi autres supports, en plus de CDs, mais encore, dans son comportement
par défaut, il doit être considéré en lecture seule et toutes les évolutions
d'exécution du système sont perdus à l'arrêt.

La persistance est un nom commun pour les différents types de solutions pour
sauver, après un redémarrage, certaines ou toutes les données, de cette
évolution pendant l'exécution du système. Pour comprendre comment cela
pourrait fonctionner il pourrait être utile de savoir que même si le système
est démarré et exécuté à partir d'un support en lecture seule, la
modification des fichiers et répertoires sont écrits sur des supports
inscriptibles, typiquement un disque ram (tmpfs) et aux disques RAM les
données ne survivent pas à un redémarrage.

The data stored on this ramdisk should be saved on a writable persistent
medium like local storage media, a network share or even a session of a
multisession (re)writable CD/DVD. All these media are supported in Debian
Live in different ways, and all but the last one require a special boot
parameter to be specified at boot time: #{persistent}#.

If the boot parameter #{persistent}# is set (and #{nopersistent}# is not
set), local storage media (e.g. hard disks, USB drives) will be probed for
persistent volumes during boot. A persistent volumes is any of the
following:

_* a partition, identified by its GPT name.

_* a filesystem, identified by its filesystem label.

_* an image/archive file located on the root of any readable filesystem
(even an NTFS partition of a foreign OS), identified by its file name. In
this case the file name must also use the containing filesystem as the file
extension, e.g. "<label>.ext3".

It is possible to restrict which types of persistent volumes to use by
specifying certain boot parameters described in the live-boot(7) man
page. The "identifying labels" referred to above can be any of the
following:

_* #{full-ov}# for full persistent overlays.

_* #{custom-ov}# for custom overlays.

_* #{live-sn}# for full system snapshots.

_* #{home-sn}# for /home snapshots.

3~ Full persistent overlays

By 'full persistence' it is meant that instead of using a tmpfs for storing
modifications to the read-only media (with the copy-on-write, COW, system) a
persistent volume is used. For this type of persistence the volume label
must be #{full-ov}#. This could, for instance, be an ext2 partition on a
hard disk or on a usb key created with, e.g.:

code{

 # mkfs.ext2 -L full-ov /dev/sdb1

}code

Voir aussi {Utilisation de l'espace disponible sur une clé
USB}#using-usb-extra-space.

Si vous avez déjà une partition sur votre dispositif, vous pouvez simplement
modifier l'étiquette avec l'un des suivants:

code{

 $ tune2fs -L full-ov /dev/sdb1 # for ext2,3,4 filesystems

}code

Here's an example of how to create an ext2-based image file used for full
persistence:

code{

 $ dd if=/dev/null of=full-ov bs=1G seek=1 # for a 1GB sized image file
 $ /sbin/mkfs.ext2 -F full-ov

}code

Then copy the #{full-ov}# file to the root of a writable partition and
reboot.

3~ Custom overlays

A volume with the label #{custom-ov}# can be configured to make arbitrary
directories persistent. The file #{live.persist}#, located on the volume's
filesystem root, controls which directories it makes persistent, and in
which way.

How custom overlay mounts are configured is described in full detail in the
live.persist(5) man page, but a simple example should be sufficient for most
uses. Let's say we want to make our home directory and APT cache persistent
in an ext3 filesystem on the /dev/sdb1 partition:

code{

 $ mkfs.ext3 -L custom-ov /dev/sdb1
 $ mount -t ext3 /dev/sdb1 /mnt
 $ echo "/home" >> /mnt/live.persist
 $ echo "/var/cache/apt" >> /mnt/live.persist

}code

Then we reboot. During the first boot the contents of /home and
/var/cache/apt will be copied into the persistent volume, and from then on
all changes to these directories will live in the persistent volume. Please
note that any paths listed in the #{live.persist}# file cannot contain white
spaces or the special "." and ".." path components. Also, neither "/live"
(or any of its sub-directories) nor "/" can be made persistent using custom
mounts (for the latter, use the #{full-ov}# type persistence described
above).

Several different custom overlay volumes (with their own #{live.persist}#
files) can be used at the same time, but if several volumes make the same
directory persistent, only one of them will be used. If any two mounts are
"nested" (i.e. one is a sub-directory of the other) the parent will be
mounted before the child so no mount will be hidden by the other. Nested
custom mounts are problematic if they are listed in the same
#{live.persist}# file. See the live.persist(5) man page for how to handle
that case if you really need it (hint: you usually don't).

3~ Instantanés

Snapshots are collections of files and directories which are not mounted
while running but which are copied from a persistent volume to the system
(tmpfs) at boot and which are resynced at reboot/shutdown of the system. The
volume must be labeled #{live-sn}#, and it defaults to a simple cpio archive
named #{live-sn.cpio.gz}#. A power interruption during run time could lead
to data loss, hence, if you have important changes, invoke #{live-snapshot
--refresh}# as often as needed. This type of persistence, since it does not
write continuously to the persistent media, is the most flash-based device
friendly and the fastest of all the persistence systems, but it occupies as
much RAM as the size of the uncompressed snapshot.

Une version instantané de /home existe aussi, et son étiquette est
#{home-sn.*}#; elle travaille le même que l'instantané principale, mais il
est seulement appliquée à /home.

Snapshots cannot currently handle file deletion.

3~ SubText persistant

If a user would need multiple persistent storage of the same type for
different locations or testing, such as #{full-ov-nonwork}# and
#{full-ov-work}#, the boot parameter #{persistent-subtext}# used in
conjunction with the boot parameter #{persistent}# will allow for multiple
but unique persistent media. An example would be if a user wanted to use a
persistent partition labeled #{live-sn-subText}# they would use the boot
parameters of: #{persistent}# #{persistent-subtext=subText}#.

3~ Remasterisation partielle

Les modifications de l'exécution du tmpfs pourraient être recueillies à
l'aide de live-snapshot dans une squashfs et ajoutés au CD en remasterisant
l'ISO dans le cas des CD-R ou en ajoutant une session à un cd/dvd(rw)
multisession; live-boot monte tous les systèmes de fichiers /live dans
l'ordre ou avec le paramètre de démarrage du module.
