:B~ Personnalisation des comportements au moment de l'exécution

1~customizing-run-time-behaviours Personnalisation des comportements au
moment de l'exécution

Toute la configuration qui est faite pendant l'exécution est faite par
live-config. Voici quelques options les plus courantes de live-config
d'intérêt pour les utilisateurs. Une liste complète de toutes les
possibilités peut être trouvée dans la page de manuel de live-config.

2~ Personnalisation de l'utilisateur Live

Une considération importante est que l'utilisateur live est créé par
live-boot au démarrage, non pas par live-config au moment de la
construction. Ça influence non seulement là où les documents relatifs à
l'utilisateur live sont introduits dans votre construction, tel que discuté
dans {Live/chroot local includes}#live-chroot-local-includes, mais aussi
tous les groupes et les autorisations associées à l'utilisateur live.

Vous pouvez spécifier d'autres groupes pour l'utilisateur live en
préconfigurant la valeur debconf #{passwd/user-default-groups}#. Par
exemple, pour ajouter l'utilisateur live au groupe #{fuse}# pendant l'étape
chroot, ajoutez la ligne suivante à un fichier dans le répertoire
#{config/chroot_local-preseed}#:

code{

 $ lb config
 $ echo user-setup passwd/user-default-groups string audio cdrom \
   dip floppy video plugdev netdev powerdev scanner bluetooth fuse \
   >> config/preseed/my.preseed.chroot

}code

Il est également possible de changer le nom de l'utilisateur par défaut
«user» et du mot de passe par défaut "live". Si vous voulez pour quelque
raison, vous pouvez facilement faire ça comme suit:

Pour modifier le nom de l'utilisateur par défaut, vous pouvez simplement le
spécifier dans votre config:

code{

 $ lb config --bootappend-live "username=live-user"

}code

Une façon possible de changer le mot de passe par défaut est au moyen d'un
hook comme décrit dans {Hooks au moment du démarrage}#boot-time-hooks. Pour
ce faire vous pouvez utiliser le hook "passwd" de
#{/usr/share/doc/live-config/examples/hooks}#, ajouter un préfixe correct
(par exemple 2000-passwd) et l'ajouter à
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Personnalisation des paramètres régionaux
et de la langue

When the live system boots, language is involved in two steps:

_* la génération des paramètres régionaux

_* setting the keyboard configuration

The default locale when building a Live system is
#{locales=en_US.UTF-8}#. To define the locale that should be generated, use
the #{locales}# parameter in the #{--bootappend-live}# option of #{lb
config}#, e.g.

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

Multiple locales may be specified as a comma-delimited list.

This parameter, as well as the keyboard configuration parameters indicated
below, can also be used at the kernel command line. You can specify a locale
by #{language_country}# (in which case the default encoding is used) or the
full #{language_country.encoding}# word. A list of supported locales and the
encoding for each can be found in #{/usr/share/i18n/SUPPORTED}#.

Both the console and X keyboard configuration are performed by
#{live-config}# using the #{console-setup}# package. To configure them, use
the #{keyboard-layouts}#, #{keyboard-variant}#, #{keyboard-options}# and
#{keyboard-model}# boot parameters via the #{--bootappend-live}#
option. Valid options for these can be found in
#{/usr/share/X11/xkb/rules/base.lst}#. To find layouts and variants for a
given language, try searching for the English name of the language and/or
the country where the language is spoken, e.g:

code{

$ egrep -i '(^!|german.*switzerland)' /usr/share/X11/xkb/rules/base.lst
 ! model
 ! layout
   ch              German (Switzerland)
 ! variant
   legacy          ch: German (Switzerland, legacy)
   de_nodeadkeys   ch: German (Switzerland, eliminate dead keys)
   de_sundeadkeys  ch: German (Switzerland, Sun dead keys)
   de_mac          ch: German (Switzerland, Macintosh)
 ! option

}code

Note that each variant lists the layout to which it applies in the
description.

Often, only the layout needs to be configured. For example, to get the
locale files for German and Swiss German keyboard layout in X use:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

However, for very specific use cases, you may wish to include other
parameters. For example, to set up a French system with a French-Dvorak
layout (called Bepo) on a TypeMatrix EZ-Reach 2030 USB keyboard, use:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variant=bepo keyboard-model=tm2030usb"

}code

Multiple values may be specified as comma-delimited lists for each of the
#{keyboard-*}# options, with the exception of #{keyboard-model}#, which
accepts only one value. Please see the #{keyboard(5)}# man page for details
and examples of #{XKBMODEL}#, #{XKBLAYOUT}#, #{XKBVARIANT}# and
#{XKBOPTIONS}# variables. If multiple #{keyboard-variant}# values are given,
they will be matched one-to-one with #{keyboard-layouts}# values (see
#{setxkbmap(1)}# #{-variant}# option). Empty values are allowed; e.g. to
define two layouts, the default being US QWERTY and the other being US
Dvorak, use:

code{

 $ lb config --bootappend-live \
     "keyboard-layouts=us,us keyboard-variant=,dvorak"

}code

2~persistence Persistance

Un paradigme d'un Live CD est être un système pré-installé qui amorce sur un
support en lecture seule, comme un cdrom, où les données et les
modifications ne survivent pas aux redémarrages du matériel hôte qui
l'exécute.

Un système Debian Live est une généralisation de ce paradigme et soutient
ainsi autres supports, en plus de CDs, mais encore, dans son comportement
par défaut, il doit être considéré en lecture seule et toutes les évolutions
pendant l'exécution du système sont perdus à l'arrêt.

La «persistance» est un nom commun pour les différents types de solutions
pour sauver, après un redémarrage, certaines ou toutes les données, de cette
évolution pendant l'exécution du système. Pour comprendre comment cela
fonctionne il peut être utile de savoir que même si le système est démarré
et exécuté à partir d'un support en lecture seule, la modification des
fichiers et répertoires sont écrits sur des supports inscriptibles,
typiquement un disque ram (tmpfs) et aux disques RAM les données ne
survivent pas à un redémarrage.

Les données stockées sur ce disque virtuel doivent être enregistrées sur un
support inscriptible persistant comme supports de stockage locaux, un
partage réseau ou même une séance d'un CD/DVD multisession
(ré)inscriptible. Tous ces supports sont pris en charge dans Debian Live de
différentes manières, et tous, moins le dernier, nécessitent un paramètre
d'amorçage spéciale à préciser au moment du démarrage: #{persistence}#.

Si le paramètre de démarrage #{persistence}# est réglé (et #{nopersistence}#
n'est pas utilisé), les supports de stockage locaux (par exemple les disques
durs, clés USB) seront examinés pour trouver des volumes persistants pendant
le démarrage. Il est possible de limiter les types de volumes persistants à
utiliser en spécifiant certains paramètres de démarrage décrits dans la page
de manuel live-boot(7). Un volume persistant est un des éléments suivants:

_* une partition, identifiée par son nom GPT.

_* un système de fichiers, identifié par son étiquette de système de
fichiers.

_* un fichier image situé sur la racine d'un système de fichiers en lecture
(même une partition NTFS d'un système d'exploitation étranger), identifié
par son nom de fichier. Dans ce cas, le nom du fichier doit contenir le nom
du système de fichiers comme extension, par exemple, "persistence.ext4".

L'étiquette du volume pour les couches de persistence doit être
#{persistence}#. Et afin de personnaliser entièrement la persistance du
volume il doit y avoir un fichier nommé #{live-persistence.conf}#. Voir {Le
fichier live-persistence.conf}#live-persistence-conf

Voici quelques exemples de comment préparer un volume à utiliser pour la
persistance. Il peut être, par exemple, une partition ext4 sur un disque dur
ou sur une clé usb créée avec, par exemple:

code{

 # mkfs.ext4 -L persistence /dev/sdb1

}code

Voir aussi {Utilisation de l'espace disponible sur une clé
USB}#using-usb-extra-space.

Si vous avez déjà une partition sur votre dispositif, vous pouvez simplement
modifier l'étiquette avec l'un des suivants:

code{

 $ tune2fs -L persistence /dev/sdb1 # for ext2,3,4 filesystems

}code

Voici un exemple de comment créer un fichier image ext4 utilisé pour la
persistance:

code{

 $ dd if=/dev/null of=persistence bs=1G seek=1 # for a 1GB sized image file
 $ /sbin/mkfs.ext4 -F persistence

}code

Ensuite, copiez le fichier #{persistence}# à la racine d'une partition
accessible en écriture.

3~live-persistence-conf Le fichier live-persistence.conf

Un volume avec l'étiquette #{persistence}# peut être configuré pour créer
des répertoires persistants arbitraires. Le fichier
#{live-persistence.conf}#, situé sur le système de fichiers racine du
volume, contrôle quels répertoires il fait persistants, et de quelle
manière.

Comment on configure monter des couches personnalisées est décrit en détail
dans la page de manuel live-persistence.conf(5), mais un simple exemple
devrait être suffisant pour la plupart des utilisations. Imaginons que nous
voulons faire notre répertoire personnel et APT cache persistants dans un
système de fichiers ext4 sur la partition /dev/sdb1:

code{

 # mkfs.ext4 -L persistence /dev/sdb1
 # mount -t ext4 /dev/sdb1 /mnt
 # echo "/home" >> /mnt/live-persistence.conf
 # echo "/var/cache/apt" >> /mnt/live-persistence.conf

}code

Alors nous redémarrons. Lors du premier démarrage les contenus du #{/home}#
et #{/var/cache/apt}# seront copiés dans le volume persistant, et à partir
de ce moment tous les changements dans ces répertoires seront stockés dans
le volume persistant. S'il vous plaît souligner que les chemins d'accès aux
répertoriés dans le fichier #{live-persistence.conf}# ne peuvent pas
contenir des espaces blancs ou les éléments spéciaux #{.}# et #{..}#. En
outre, ni #{/live}# (ou un de ses sous-répertoires), ni #{/}#  peuvent être
rendus persistants en utilisant montages personnalisés.

Plusieurs volumes de couches personnalisées différents (avec leurs propres
fichiers #{live-persistence.conf}#) peuvent être utilisés au même temps,
mais si plusieurs volumes font le même répertoire persistant, un seul
d'entre eux sera utilisé. Si les deux sont «imbriqués» (un est un
sous-répertoire de l'autre) le premier sera monté avant que le secondaire de
sorte que aucun sera caché par l'autre. Monter des éléments personnalisés
imbriqués est problématique s'ils sont énumérés dans le même fichier
#{live-persistence.conf}#. Voir la page de manuel live-persistence.conf(5)
pour savoir comment gérer ce cas, si vous avez vraiment besoin (remarque:
vous n'avez généralement pas).

3~ Using more than one persistence store

If a user would need multiple persistence store of the same type for
different locations or testing, such as #{persistence-nonwork}# and
#{persistence-work}#, the boot parameter #{persistence-label}# used in
conjunction with the boot parameter #{persistence}# will allow for multiple
but unique persistence media. An example would be if a user wanted to use a
persistence partition labeled #{persistence-subText}# they would use the
boot parameters of: #{persistence}# #{persistence-label=subText}#.
