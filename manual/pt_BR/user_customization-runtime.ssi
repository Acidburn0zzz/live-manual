:B~ Customizing run time behaviours

1~customizing-run-time-behaviours Customizing run time behaviours

All configuration that is done during run time is done by live-config. Here
are some of the most common options of live-config that users are interested
in. A full list of all possibilities can be found in the manpage of
live-config.

2~ Customizing the live user

One important consideration is that the live user is created by live-boot at
boot time, not by live-build at build time. This not only influences where
materials relating to the live user are introduced in your build, as
discussed in {Live/chroot local includes}#live-chroot-local-includes, but
also any groups and permissions associated with the live user.

You can specify additional groups that the live user will belong to by
preseeding the #{passwd/user-default-groups}# debconf value. For example, to
add the live user to the #{fuse}# group, add the following preseed under
#{config/preseed/}# for the chroot stage:

code{

 $ lb config
 $ echo user-setup passwd/user-default-groups string audio cdrom \
   dip floppy video plugdev netdev powerdev scanner bluetooth fuse \
   >> config/preseed/my.preseed.chroot

}code

It is also possible to change the default username "user" and the default
password "live". If you want to do that for any reason, you can easily
achieve it as follows:

To change the default username you can simply specify it in your config:

code{

 $ lb config --bootappend-live "username=live-user"

}code

One possible way of changing the default password is by means of a hook as
described in {Boot-time hooks}#boot-time-hooks. In order to do that you can
use the "passwd" hook from #{/usr/share/doc/live-config/examples/hooks}#,
prefix it accordingly (e.g. 200-passwd) and add it to
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Customizing locale and language

When the live system boots, language is involved in three steps:

_* the locale generation

_* setting the keyboard layout for the console

_* setting the keyboard layout for X

The default locale when building a Live system is "locales=en_US.UTF-8". To
define the locale that should be generated, use the #{locales}# parameter in
the #{--bootappend-live}# option of #{lb config}#, e.g.

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

This parameter can also be used at the kernel command line. You can specify
a locale by a full #{language_country.encoding}# word.

Both the console and X keyboard configuration depend on the
#{keyboard-layouts}# parameter of the #{--bootappend-live}# option. Valid
options for X keyboard layouts can be found in
#{/usr/share/X11/xkb/rules/base.xml}# (rather limited to two-letters country
codes). To find the value (the two characters) corresponding to a language
try searching for the english name of the nation where the language is
spoken, e.g:

code{

 $ grep -i sweden -C3 /usr/share/X11/xkb/rules/base.xml | grep name
 <name>se</name>

}code

To get the locale files for German and Swiss German keyboard layout in X
use:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

A list of the valid values of the keyboards for the console can be figured
with the following command:

code{

 $ for i in $(find /usr/share/keymaps/ -iname "*kmap.gz"); \
     do basename $i | head -c -9; echo; done | sort | less

}code

Alternatively, you can use the #{console-setup}# package, a tool to let you
configure console layout using X (XKB) definitions; you can then set your
keyboard layout more precisely with #{keyboard-layouts}#,
#{keyboard-variant}#, #{keyboard-options}# and #{keyboard-model}# variables;
live-boot will use also these parameters for X configuration. For example,
to set up a French system with a French-Dvorak layout (called Bepo) on a
TypeMatrix keyboard, both in console and X11, use:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variant=bepo keyboard-model=tm2030usb"

}code

2~persistence Persistence

A live cd paradigm is a pre-installed system which runs from read-only
media, like a cdrom, where writes and modifications do not survive reboots
of the host hardware which runs it.

A Debian Live system is a generalization of this paradigm and thus supports
other media in addition to CDs; but still, in its default behaviour, it
should be considered read-only and all the run-time evolutions of the system
are lost at shutdown.

Persistence is a common name for different kinds of solutions for saving
across reboots some, or all, of this run-time evolution of the system. To
understand how it could work it could be handy to know that even if the
system is booted and run from read-only media, modification to the files and
directories are written on writable media, typically a ram disk (tmpfs) and
ram disks' data do not survive reboots.

The data stored on this ramdisk should be saved on a writable persistent
medium like local storage media, a network share or even a session of a
multisession (re)writable CD/DVD. All these media are supported in Debian
Live in different ways, and all but the last one require a special boot
parameter to be specified at boot time: #{persistent}#.

If the boot parameter #{persistent}# is set (and #{nopersistent}# is not
set), local storage media (e.g. hard disks, USB drives) will be probed for
persistent volumes during boot. A persistent volume is any of the following:

_* a partition, identified by its GPT name.

_* a filesystem, identified by its filesystem label.

_* an image/archive file located on the root of any readable filesystem
(even an NTFS partition of a foreign OS), identified by its file name. In
this case the file name must also use the containing filesystem as the file
extension, e.g. "<label>.ext3".

It is possible to restrict which types of persistent volumes to use by
specifying certain boot parameters described in the live-boot(7) man
page. The "identifying labels" referred to above can be any of the
following:

_* #{full-ov}# for full persistent overlays.

_* #{custom-ov}# for custom overlays.

_* #{live-sn}# for full system snapshots.

_* #{home-sn}# for /home snapshots.

3~ Full persistent overlays

By 'full persistence' it is meant that instead of using a tmpfs for storing
modifications to the read-only media (with the copy-on-write, COW, system) a
persistent volume is used. For this type of persistence the volume label
must be #{full-ov}#. This could, for instance, be an ext2 partition on a
hard disk or on a usb key created with, e.g.:

code{

 # mkfs.ext2 -L full-ov /dev/sdb1

}code

See also {Using the space left on a USB stick}#using-usb-extra-space.

If you already have a partition on your device, you could just change the
label with one of the following:

code{

 $ tune2fs -L full-ov /dev/sdb1 # for ext2,3,4 filesystems

}code

Here's an example of how to create an ext2-based image file used for full
persistence:

code{

 $ dd if=/dev/null of=full-ov bs=1G seek=1 # for a 1GB sized image file
 $ /sbin/mkfs.ext2 -F full-ov

}code

Then copy the #{full-ov}# file to the root of a writable partition and
reboot.

3~ Custom overlays

A volume with the label #{custom-ov}# can be configured to make arbitrary
directories persistent. The file #{live.persist}#, located on the volume's
filesystem root, controls which directories it makes persistent, and in
which way.

How custom overlay mounts are configured is described in full detail in the
live.persist(5) man page, but a simple example should be sufficient for most
uses. Let's say we want to make our home directory and APT cache persistent
in an ext3 filesystem on the /dev/sdb1 partition:

code{

 $ mkfs.ext3 -L custom-ov /dev/sdb1
 $ mount -t ext3 /dev/sdb1 /mnt
 $ echo "/home" >> /mnt/live.persist
 $ echo "/var/cache/apt" >> /mnt/live.persist

}code

Then we reboot. During the first boot the contents of /home and
/var/cache/apt will be copied into the persistent volume, and from then on
all changes to these directories will live in the persistent volume. Please
note that any paths listed in the #{live.persist}# file cannot contain white
spaces or the special "." and ".." path components. Also, neither "/live"
(or any of its sub-directories) nor "/" can be made persistent using custom
mounts (for the latter, use the #{full-ov}# type persistence described
above).

Several different custom overlay volumes (with their own #{live.persist}#
files) can be used at the same time, but if several volumes make the same
directory persistent, only one of them will be used. If any two mounts are
"nested" (i.e. one is a sub-directory of the other) the parent will be
mounted before the child so no mount will be hidden by the other. Nested
custom mounts are problematic if they are listed in the same
#{live.persist}# file. See the live.persist(5) man page for how to handle
that case if you really need it (hint: you usually don't).

3~ Snapshots

Snapshots are collections of files and directories which are not mounted
while running but which are copied from a persistent volume to the system
(tmpfs) at boot and which are resynced at reboot/shutdown of the system. The
volume must be labeled #{live-sn}#, and it defaults to a simple cpio archive
named #{live-sn.cpio.gz}#. A power interruption during run time could lead
to data loss, hence, if you have important changes, invoke #{live-snapshot
--refresh}# as often as needed. This type of persistence, since it does not
write continuously to the persistent media, is the most flash-based device
friendly and the fastest of all the persistence systems, but it occupies as
much RAM as the size of the uncompressed snapshot.

A /home version of snapshot exists too and its label is #{home-sn.*}#; it
works the same as the main snapshot but it is only applied to /home.

Snapshots cannot currently handle file deletion.

3~ Persistent SubText

If a user would need multiple persistent storage of the same type for
different locations or testing, such as #{full-ov-nonwork}# and
#{full-ov-work}#, the boot parameter #{persistent-subtext}# used in
conjunction with the boot parameter #{persistent}# will allow for multiple
but unique persistent media. An example would be if a user wanted to use a
persistent partition labeled #{live-sn-subText}# they would use the boot
parameters of: #{persistent}# #{persistent-subtext=subText}#.

3~ Partial remastering

The run-time modification of the tmpfs could be collected using
live-snapshot in a squashfs and added to the cd by remastering the iso in
the case of cd-r or adding a session to multisession cd/dvd(rw); live-boot
mounts all /live filesystem in order or with the module boot parameter.
