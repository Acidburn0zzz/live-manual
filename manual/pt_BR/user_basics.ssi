:B~ O básico

1~the-basics O básico

This chapter contains a brief overview of the build process and instructions
for using the three most commonly used image types. The most versatile image
type, #{iso-hybrid}#, may be used on a virtual machine, optical media or USB
portable storage device. In certain special cases, as explained later, the
#{hdd}# type may be more suitable. The chapter finishes with instructions
for building and using a #{net}# type image, which is a bit more involved
due to the setup required on the server. This is an slightly advanced topic
for anyone who is not familiar already with netbooting, but it is included
here because once the setup is done, it is a very convenient way to test and
deploy images for booting on the local network without the hassle of dealing
with image media.

Throughout the chapter, we will often refer to the default filenames
produced by live-build. If you are {downloading a prebuilt
image}#downloading-prebuilt-images instead, the actual filenames may vary.

2~what-is-live O que é um sistema live?

Um sistema live normalmente significa um sistema operacional inicializado em
um computador a partir de uma mídia removível, como um CD-ROM ou dispositivo
USB, ou de uma rede, pronto a usar, sem qualquer tipo de instalação na
unidade de costume (s), com a auto-configuração feita em tempo de execução
(veja {Termos}#terms).

With Debian Live, it's a Debian GNU/Linux operating system, built for one of
the supported architectures (currently amd64 and i386). It is made from the
following parts:

_* *{Imagem do kernel do Linux }*, normalmente chamada  #{vmlinuz*}#

_* *{Initial RAM disk image (initrd) - Imagem do disco RAM inicial}*: um
disco de RAM configurado para a inicialização do Linux, que contém módulos
que podem ser necessários para montar a imagem do sistema e alguns scripts
para fazê-lo.

_* *{Imagem do sistema}*: A imagem do sistema de arquivos do sistema
operacional . Normalmente, um sistema de arquivos SquashFS comprimido é
usado para minimizar o tamanho da imagem Debian Live. Observe que é só de
leitura. Então, durante a inicialização do sistema Debian Live vai usar um
disco de RAM e um mecanismo de "união" para permitir a gravação de arquivos
dentro do sistema em funcionamento. No entanto, todas as modificações serão
perdidas no desligamento, a menos que a persistência opcional seja usada
{Persistência}#persistence).

_* *{Bootloader}*: Um pequeno pedaço de código criado para iniciar a partir
dos meios escolhidos, possivelmente apresentando uma solicitação ou menu
para permitir a seleção de opções/configuração. Ele carrega o kernel do
Linux e seu initrd para funcionar com um sistema de arquivos do sistema
associado. Diferentes soluções podem ser usadas, dependendo da mídia destino
e formato do sistema de arquivos que contém os componentes mencionados
anteriormente: isolinux para arrancar a partir de um CD ou DVD no formato
ISO9660, syslinux para HDD ou drive USB inicializar a partir de uma partição
VFAT, extlinux para ext2/3/4 e partiuções btrfs, pxelinux para inicialização
pela rede PXE, GRUB para partições ext2/3/4, etc.

Você pode usar o live-build para construir a imagem do sistema a partir de
suas especificações, criar um kernel do Linux, o seu initrd, e um bootloader
para executá-las, tudo em um formato dependendo da  mídia (imagem ISO9660,
imagem de disco, etc.)

2~downloading-prebuilt-images Downloading prebuilt images

While the focus of this manual is developing and building your own live
images, you may simply wish to try one of our prebuilt images, either as an
introduction to their use or instead of building your own. These images are
built using our {live-images git repository}#clone-configuration-via-git and
official stable releases are published at http://www.debian.org/CD/live/. In
addition, older and upcoming releases, and unofficial images containing
non-free firmware and drivers are available at
http://live.debian.net/cdimage/release/.

2~using-web-builder Using the web live image builder

As a service to the community, we run a web-based live image builder service
at http://live-build.debian.net. This site is maintained on a best effort
basis. That is, although we strive to keep it up-to-date and operational at
all times, and do issue notices for significant operational outages, we
cannot guarantee 100% availability or fast image building, and the service
may occasionally have issues that take some time to resolve. If you have
problems or questions about the service, please {contact us}#contact,
providing us with the link to your build.

3~ Web builder usage and caveats

The web interface currently makes no provision to prevent the use of invalid
combinations of options, and in particular, where changing an option would
normally (i.e. using live-build directly) change defaults of other options
listed in the web form, the web builder does not change these defaults. Most
notably, if you change #{--architectures}# from the default #{i386}# to
#{amd64}#, you must change the corresponding option #{--linux-flavours}#
from the default #{486}# to #{amd64}#. See the #{lb_config}# man page for
the version of live-build installed on the web builder for more details. The
version number of live-build is listed at the bottom of the web builder
page.

The time estimate given by the web builder is a crude estimate only and may
not reflect how long your build actually takes. Nor is the estimate updated
once it is displayed. Please be patient. Do not refresh the page you land on
after submitting the build, as this will resubmit a new build with the same
parameters. You should {contact us}#contact if you don't receive
notification of your build only once you are certain you've waited long
enough and verified the notification e-mail did not get caught by your own
e-mail spam filter.

The web builder is limited in the kinds of images it can build. This keeps
it simple and efficient to use and maintain. If you would like to make
customizations that are not provided for by the web interface, the rest of
this manual explains how to build your own images using live-build.

2~building-iso-hybrid Primeiros passos: construindo uma imagem ISO híbrida

Regardless of the image type, you will need to perform the same basic steps
to build an image each time. As a first example, create a build directory,
change to that directory and then execute the following sequence of
live-build commands to create a basic ISO hybrid image containing a default
live system without X.org. It is suitable for burning to CD or DVD media,
and also to copy onto a USB stick.

The name of the working directory is absolutely up to you, but if you take a
look at the examples used throughout live-manual, it is a good idea to use a
name that helps you identify the image you are working with in each
directory, especially if you are working or experimenting with different
image types. In this case you are going to build a default system so let's
call it, for example, live-default.

code{

 $ mkdir live-default && cd live-default

}code

Then, run the #{lb config}# command. This will create a "config/" hierarchy
in the current directory for use by other commands:

code{

 $ lb config

}code

Nenhum parâmetro é passado para #{lb config}#, então para todas as
diferentes opções serão utilizadas as padrões. Veja {O comando lb
config}#lb-config para mais detalhes.

Agora que existe a hierarquia "config/", construir a imagem com o comando
#{lb build}#:

code{

 # lb build

}code

Este processo pode demorar um pouco, dependendo da velocidade de sua conexão
de rede. Quando estiver completo, deve haver um arquivo de imagem
#{binary.hybrid.iso}#, pronto a usar, no diretório atual.

2~using-iso-hybrid Usando uma imagem live ISO hibrida

Após a construção ou o download de uma imagem ISO híbrido, que pode ser
obtida em http://www.debian.org/CD/live/, o passo seguinte é habitual é
preparar sua mídia para a inicialização, ou mídia óptica CD-R (W) ou DVD-R
(W)  ou um dispositivo USB.

3~burning-iso-image Queimar uma imagem ISO em um meio físico

Queimar uma imagem ISO é fácil. Basta instalar wodim e usá-lo a partir da
linha de comando para gravar a imagem. Por exemplo:

code{

 # apt-get install wodim

 $ wodim binary.hybrid.iso

}code

3~copying-iso-hybrid-to-usb Copiar uma imagem ISO híbrida para um
dispositivo USB

ISO images prepared with #{xorriso}#, can be simply copied to a USB stick
with the #{dd}# program or an equivalent. Plug in a USB stick with a size
large enough for your image file and determine which device it is, which we
hereafter refer to as #{${USBSTICK}}#. This is the device file of your key,
such as #{/dev/sdb}#, not a partition, such as #{/dev/sdb1}#! You can find
the right device name by looking in #{dmesg}#'s output after plugging in the
stick, or better yet, #{ls -l /dev/disk/by-id}#.

Uma vez que você tem certeza de que tem o nome correto do dispositivo, use o
comando #{dd}# para copiar a imagem para o pendrive. *{Isso definitivamente
vai substituir todo o conteúdo anterior do seu dispositivo!}*

code{

 $ dd if=binary.hybrid.iso of=${USBSTICK}

}code

3~using-usb-extra-space Using the space left on a USB stick

To use the remaining free space after copying #{binary.hybrid.iso}# to a USB
stick, use a partitioning tool such as /{gparted}/ or /{parted}/ to create a
new partition on the stick. The first partition will be used by the Debian
Live system.

code{

 # gparted ${USBSTICK}

}code

After the partition is created, where #{${PARTITION}}# is the name of the
partition, such as #{/dev/sdb2}#, you have to create a filesystem on it. One
possible choice would be ext4.

code{

 # mkfs.ext4 ${PARTITION}

}code

*{Note:}* If you want to use the extra space with Windows, apparently that OS cannot normally access any partitions but the first. Some solutions to this problem have been discussed on our {mailing list}#contact, but it seems there are no easy answers.

*{Remember: Every time you install a new binary.hybrid.iso on the stick, all data on the stick will be lost because the partition table is overwritten by the contents of the image, so back up your extra partition first to restore again after updating the live image.}*

3~booting-live-media Inicializando a media live

A primeira vez que você iniciar sua mídia live, seja CD, DVD, dispositivo
USB, ou inicializador PXE, alguma configuração na BIOS do seu computador
pode ser necessária em primeiro lugar. Uma vez que as BIOS variam muito em
características e combinações de teclas, não podemos entrar no tema em
profundidade aqui. Algumas BIOS fornecem uma chave para abrir um menu de
dispositivos de inicialização em tempo de inicialização, que é a maneira
mais fácil se estiver disponível no seu sistema. Caso contrário, você
precisa entrar no menu de configuração da BIOS e alterar a ordem de
inicialização para colocar o dispositivo de inicialização para o sistema
live antes do dispositivo de inicialização normal.

Uma vez que você tenha iniciado a mídia, você é apresentado com um menu de
inicialização. Se você apenas pressionar enter aqui, o sistema irá
inicializar usando a entrada padrão, #{Live}# e opções padrão. Para mais
informações sobre as opções de inicialização, consulte a entrada "ajuda" no
menu e também as páginas do live-boot e live-boot-config encontradas dentro
do sistema live.

Assuming you've selected #{Live}# and booted a default desktop live image,
after the boot messages scroll by, you should be automatically logged into
the #{user}# account and see a desktop, ready to use. If you have booted a
console-only image, such as #{standard}# or #{rescue}# flavour {prebuilt
images}#downloading-prebuilt-images, you should be automatically logged in
on the console to the #{user}# account and see a shell prompt, ready to use.

2~using-virtual-machine Usando uma máquina virtual para testar

It can be a great time-saver for the development of live images to run them
in a virtual machine (VM). This is not without its caveats:

_* Running a VM requires enough RAM for both the guest OS and the host and a
CPU with hardware support for virtualization is recommended.

_* There are some inherent limitations to running on a VM, e.g. poor video
performance, limited choice of emulated hardware.

_* When developing for specific hardware, there is no substitute for running
on the hardware itself.

_* Occasionally there are bugs that relate only to running in a VM. When in
doubt, test your image directly on the hardware.

Provided you can work within these constraints, survey the available VM
software and choose one that is suitable for your needs.

3~testing-iso-with-qemu Testing an ISO image with QEMU

The most versatile VM in Debian is QEMU. If your processor has hardware
support for virtualization, use the /{qemu-kvm}/ package; the /{qemu-kvm}/
package description briefly lists the requirements.

First, install /{qemu-kvm}/ if your processor supports it. If not, install
/{qemu}/, in which case the program name is #{qemu}# instead of #{kvm}# in
the following examples. The /{qemu-utils}/ package is also valuable for
creating virtual disk images with #{qemu-img}#.

code{

 # apt-get install qemu-kvm qemu-utils

}code

Booting an ISO image is simple:

code{

 $ kvm -cdrom binary.hybrid.iso

}code

See the man pages for more details.

3~testing-iso-with-virtualbox Testing an ISO image with virtualbox

In order to test the ISO with /{virtualbox}/:

code{

 # apt-get install virtualbox virtualbox-dkms

 $ virtualbox

}code

Create a new virtual machine, change the storage settings to use
#{binary.hybrid.iso}# as the CD/DVD device, and start the machine.

*{Note:}* For live systems containing X.org that you want to test with /{virtualbox}/, you may wish to include the VirtualBox X.org driver package, /{virtualbox-guest-x11}/, in your live-build configuration. Otherwise, the resolution is limited to 800x600.

code{

 $ echo virtualbox-guest-x11 >> config/package-lists/my.list.chroot

}code

2~using-hdd-image Building and using an HDD image

Building an HDD image is similar to an ISO hybrid one in all respects except
you specify #{-b hdd}# and the resulting filename is #{binary.img}# which
cannot be burnt to optical media. It is suitable for booting from USB
sticks, USB hard drives, and various other portable storage
devices. Normally, an ISO hybrid image can be used for this purpose instead,
but if you have a BIOS which does not handle hybrid images properly, you
need an HDD image.

*{Note:}* if you created an ISO hybrid image with the previous example, you will need to clean up your working directory with the #{lb clean}# command (see {The lb clean command}#lb-clean):

code{

 # lb clean --binary

}code

Run the #{lb config}# command as before, except this time specifying the HDD
image type:

code{

 $ lb config -b hdd

}code

Now build the image with the #{lb build}# command:

code{

 # lb build

}code

When the build finishes, a #{binary.img}# file should be present in the
current directory.

The generated binary image contains a VFAT partition and the syslinux
bootloader, ready to be directly written on a USB device. Once again, using
an HDD image is just like using an ISO hybrid one on USB. Follow the
instructions in {Using an ISO hybrid live image}#using-iso-hybrid, except
use the filename #{binary.img}# instead of #{binary.hybrid.iso}#.

Likewise, to test an HDD image with Qemu, install /{qemu}/ as described
above in {Testing an ISO image with QEMU}#testing-iso-with-qemu. Then run
#{kvm}# or #{qemu}#, depending on which version your host system needs,
specifying #{binary.img}# as the first hard drive.

code{

 $ kvm -hda binary.img

}code

2~building-netboot-image Building a netboot image

The following sequence of commands will create a basic netboot image
containing a default live system without X.org. It is suitable for booting
over the network.

*{Note:}* if you performed any previous examples, you will need to clean up your working directory with the #{lb clean}# command:

code{

 # lb clean --binary

}code

Run the #{lb config}# command as follows to configure your image for
netbooting:

code{

 $ lb config -b net --net-root-path "/srv/debian-live" --net-root-server "192.168.0.1"

}code

In contrast with the ISO and HDD images, netbooting does not, itself, serve
the filesystem image to the client, so the files must be served via NFS. The
#{--net-root-path}# and #{--net-root-server}# options specify the location
and server, respectively, of the NFS server where the filesytem image will
be located at boot time. Make sure these are set to suitable values for your
network and server.

Now build the image with the #{lb build}# command:

code{

 # lb build

}code

In a network boot, the client runs a small piece of software which usually
resides on the EPROM of the Ethernet card. This program sends a DHCP request
to get an IP address and information about what to do next. Typically, the
next step is getting a higher level bootloader via the TFTP protocol. That
could be pxelinux, GRUB, or even boot directly to an operating system like
Linux.

For example, if you unpack the generated #{binary.netboot.tar.xz}# archive
in the #{/srv/debian-live}# directory, you'll find the filesystem image in
#{live/filesystem.squashfs}# and the kernel, initrd and pxelinux bootloader
in #{tftpboot/debian-live/i386}#.

We must now configure three services on the server to enable netboot: the
DHCP server, the TFTP server and the NFS server.

3~ Servidor DHCP

We must configure our network's DHCP server to be sure to give an IP address
to the netbooting client system, and to advertise the location of the PXE
bootloader.

Here is an example for inspiration, written for the ISC DHCP server
#{isc-dhcp-server}# in the #{/etc/dhcp/dhcpd.conf}# configuration file:

code{

 # /etc/dhcp/dhcpd.conf - configuration file for isc-dhcp-server

 ddns-update-style none;

 option domain-name "example.org";
 option domain-name-servers ns1.example.org, ns2.example.org;

 default-lease-time 600;
 max-lease-time 7200;

 log-facility local7;

 subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.1 192.168.0.254;
   next-server servername;
   filename "pxelinux.0";
}

}code

3~ Servidor TFTP

This serves the kernel and initial ramdisk to the system at run time.

You should install the /{tftpd-hpa}/ package. It can serve all files
contained inside a root directory, usually #{/srv/tftp}#. To let it serve
files inside #{/srv/debian-live/tftpboot}#, run as root the following
command:

code{

 # dpkg-reconfigure -plow tftpd-hpa

}code

and fill in the new tftp server directory when being asked about it.

3~ Servidor NFS

Once the guest computer has downloaded and booted a Linux kernel and loaded
its initrd, it will try to mount the Live filesystem image through a NFS
server.

You need to install the /{nfs-kernel-server}/ package.

Then, make the filesystem image available through NFS by adding a line like
the following to #{/etc/exports}#:

code{

 /srv/debian-live *(ro,async,no_root_squash,no_subtree_check)

}code

and tell the NFS server about this new export with the following command:

code{

 # exportfs -rv

}code

Setting up these three services can be a little tricky. You might need some
patience to get all of them working together. For more information, see the
syslinux wiki at http://syslinux.zytor.com/wiki/index.php/PXELINUX or the
Debian Installer Manual's TFTP Net Booting section at
http://d-i.alioth.debian.org/manual/en.i386/ch04s05.html. They might help,
as their processes are very similar.

3~ Netboot testing HowTo

Netboot image creation is made easy with live-build magic, but testing the
images on physical machines can be really time consuming.

To make our life easier, we can use virtualization. There are two solutions.

3~ Qemu

_* Install /{qemu}/, /{bridge-utils}/, /{sudo}/.

Edit #{/etc/qemu-ifup}#:

code{

 #!/bin/sh
 sudo -p "Senha para $0:" /sbin/ifconfig $1 172.20.0.1
 echo "Executando /etc/qemu-ifup"
 echo "Levando o $1 para o modo bridged..."
 sudo /sbin/ifconfig $1 0.0.0.0 promisc up
 echo "Adicionando $1 to br0..."
 sudo /usr/sbin/brctl addif br0 $1
 sleep 2

}code

Obter, ou construir um #{grub-floppy-netboot}# (no svn).

Launch #{qemu}# with "#{-net nic,vlan=0 -net tap,vlan=0,ifname=tun0}#"

3~ VMWare Player

_* Instalar o VMWare Player (edição "free as in beer")

_* Create a PXETester directory, and create a text file called #{pxe.vwx}#
inside

_* Paste this text inside:

code{

 #!/usr/bin/vmware
 config.version = "8"
 virtualHW.version = "4"
 memsize = "512"
 MemAllowAutoScaleDown = "FALSE"

 ide0:0.present = "FALSE"
 ide1:0.present = "FALSE"
 floppy0.present = "FALSE"
 sound.present = "FALSE"
 tools.remindInstall = "FALSE"

 ethernet0.present = "TRUE"
 ethernet0.addressType = "generated"

 displayName = "Test Boot PXE"
 guestOS = "other"

 ethernet0.generatedAddress = "00:0c:29:8d:71:3b"
 uuid.location = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
 uuid.bios = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
 ethernet0.generatedAddressOffset = "0"

}code

_* You can play with this configuration file (e.g. change memory limit to
256)

_* Double click on this file (or run VMWare player and select this file).

_* When running just press space if that strange question comes up...
