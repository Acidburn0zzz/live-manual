<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
	<!ENTITY % commondata SYSTEM "common.ent" > %commondata;
]>

<chapter id="basics">
<title>The basics</title>

<para>
	This chapter contains a brief overview of the build process as well as
containing instructions on how to boot the various binary image types.
</para>

<section>
<title>What is a live system?</title>

<para>
	A live system usually means an OS booted on a computer from a removable
medium (such as CD-ROM, USB stick, or network), ready to use without any
installation on the usual drive(s), with an auto-configuration done at
runtime (see <xref linkend="terms" />).
</para>

<para>
	With Debian Live, it's a Debian GNU/Linux OS, built for one of the supported
architectures (currently amd64, i386, powerpc and sparc). It is made from
following parts:
</para>

<variablelist>

<varlistentry>
<term>Linux kernel</term>

<listitem>
<para>
	The Linux image, usually named <filename>vmlinuz*</filename>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Initial RAM disk image (initrd)</term>

<listitem>
<para>
	RAM disk setup for the Linux boot, containing modules possibly needed to
mount the filesystem's image and some scripts to do it.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>System image</term>

<listitem>
<para>
	The OS filesystem image. Debian Live uses SquashFS, a compressed filesystem,
to minimize its image size. Note that it's read-only. So, during boot the
Debian Live system will use a RAM disk and 'union' mechanism to enable
writing files within the running system. However, all modifications will be
lost upon shutdown unless optional persistence partition(s) are used. (See
<xref linkend="persistence" />.)
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>Bootloader</term>

<listitem>
<para>
	A small piece of code, crafted to boot up from the chosen media, possibly
presenting a prompt or menu to allow selection of options/configuration. It
then loads the Linux kernel and its initrd to run with an associated
filesystem image. Different solutions can be used depending on the target
media and format of the filesystem containing the previous components:
Isolinux to boot from a CD or DVD in ISO9660 format, syslinux for HDD or USB
drive booting from a VFAT partition, GRUB for ext2/3 partition, pxelinux for
PXE netboot, etc.
</para>
</listitem>
</varlistentry>

</variablelist>

<para>
	The Debian Live tools will build the system image from your specifications,
setup a Linux kernel and its initrd, a bootloader to run them, all in one
media-dependant format(ISO9660 image, disk image, etc.)
</para>

</section>

<section>
<title>First steps: building an ISO image</title>

<para>
	The following sequence of helper commands, provided by &live-helper;, will
create a basic ISO image containing just the Debian standard system without
X.org. It is suitable for burning to CD or DVD media.
</para>

<para>
	First, we run the <filename>lh config</filename> helper command which will
create a <filename>"config/"</filename> hierarchy in the current directory
for use by other helper commands:
</para>

<para>
	<screen>$ lh config</screen>
</para>

<para>
	By passing no parameters to <filename>lh config</filename> we indicated that
we wish to use the defaults. This will create an image of type binary (see
<xref linkend="lh-config" />).
</para>

<para>
	Now that we have a <filename>"config/"</filename> hierarchy, we may build
the image with the <filename>lh build</filename> helper command:
</para>

<para>
	<screen># lh build</screen>
</para>

<para>
	This process can take a while, depending on the speed of your network
connection (see <xref linkend="lh-build" />).
</para>

<section>
<title>Testing an ISO image with Qemu</title>

<para>
	Testing an ISO is simple:
</para>

<para>
	<screen># apt-get install qemu
$ qemu -cdrom binary.iso</screen>
</para>

</section>

<section>
<title>Testing an ISO image with virtualbox-ose</title>

<para>
	In order to test the ISO with virtualbox-ose:
</para>

<para>
	<screen># apt-get install virtualbox-ose</screen>
</para>
and either install 
<itemizedlist>
<listitem><para>the modules package for a stock kernel eg
virtualbox-ose-modules-2.6.26-1-486 or</para></listitem>
<listitem><para>the modules package compiled for your kernel using module-assistant from the
package virtualbox-ose-source </para></listitem>
</itemizedlist>
<para> Run Virtualbox:</para>
For example, in Gnome
<para>  {{{Applications -> System Tools -> VirtualBox OSE }}}</para>

<para>Create a virtual machine from your Live ISO</para>

<para>To create a virtual machine "mylive" from A CDROM ISO "binary.iso" in
VirtualBox:</para>
<para>  {{{Machine -> New }}}</para>
<para>In the Wizard: FIXME </para>
</section>

<section>
<title>Testing an ISO image with VMware Workstation</title>

<para>In order to test the ISO with VMware Workstation:</para>

<para> Run VMware Workstation:</para>
<para>Click on Edit virtual machine settings in the VM summary page. </para>
<para>Then, click on the CD-ROM device and select Use ISO image. Remeber to
connect the CD-ROM device at power on and remeber to adjust the boot order
in the bios.</para>
</section>

<section>
<title>Burning an ISO image to a physical medium</title>

<para>
	Burning an ISO image is easy:
</para>

<para>
	<screen># apt-get install wodim
$ wodim binary.iso</screen>
</para>

</section>

</section>

<section>
<title>Building an USB/HDD image</title>

<para>
	The following sequence of helper commands will create a basic USB/HDD image
containing just the Debian standard system without X.org. It is suitable for
booting from USB sticks, USB hard drives, and various other portable storage
devices.
</para>

<para>
	Note if you created an iso image with the previous example, you will need to
clean up your working directory with the <filename>lh clean</filename>
helper command (see <xref linkend="lh-clean" />):
</para>

<para>
	<screen>$ lh clean --binary</screen>
</para>

<para>
	Run the <filename>lh config</filename> helper command with the parameters to
configure the <filename>"config/"</filename> hierarchy to create a USB/HDD
image type:
</para>

<para>
	<screen>$ lh config -b usb-hdd</screen>
</para>

<para>
	Now build the image with the <filename>lh build</filename> helper command:
</para>

<para>
	<screen># lh build</screen>
</para>

<section  id="image_copying">
<title>Copying USB/HDD image to a USB stick</title>

<para>
	The generated binary image contains a <acronym>VFAT</acronym> partition and
the <command>syslinux</command> bootloader, ready to be directly written on
an USB stick. Plug in an USB stick with a size larger than that of
<filename>binary.img</filename> and type:
</para>

<para>
	<screen>$ dd if=binary.img of=${USBSTICK}</screen>
</para>

<para>
	where <replaceable>${USBSTICK}</replaceable> is the device file of your key,
like <filename>/dev/sdb</filename> (not a partition like
<filename>/dev/sdb1</filename>!); you can find the right device name by
looking in <command>dmesg</command>'s output after plugging in the stick,
for example.
</para>

<para>
	<important>This will definitely overwrite any previous contents on your
	stick!</important>
</para>

</section>

<section>
<title>Testing a USB/HDD image with Qemu</title>

<para>
	<screen># apt-get install qemu
$ qemu -hda binary.img</screen>
</para>

</section>
<section>
<title>Testing an USB/HDD image with VMware Workstation</title>

<para>
	In order to test the USB/HDD image with VMware Workstation:
</para>

<para> Run VMware Workstation:</para>
<para>Write the image to an usb stick. In VMware, click on Edit virtual machine
settings in VM summary page. Then, add a new physical harddisk device and
enter the device node of your usb stick.</para>
</section>

<section>
<title>Using the space left on a USB stick</title>

<para>
	If you want to use the remaining free space after you have installed the
<filename>binary.img</filename>, you can use a partitioning tool such as
gparted or parted to create a new partition on the stick. The first
partition will be used by the Debian Live system.
</para>

<para>
	<screen># gparted ${USBSTICK}</screen>
</para>

<para>
	After the creation of the partition you have to create a filsystem on
it. One possible choice would be ext2 (ext3 isn't recommended because the
journaling causes too many writes to the stick).
</para>

<para>
	<screen># mkfs.ext2 ${USBSTICK}</screen>
</para>

<para>
	If you want to use this data partition with Windows, use FAT32.
</para>

<para>
	<screen># mkfs.vfat -F 32</screen>
</para>

<para>
	<important>Remember: Every time you install a new binary.img on the
	stick, all your data will be lost because the image includes a complete
	partition table.</important>
</para>

<para>
	FIXME: Describe installing Debian Live to a partition (e.g. /dev/sdc1)  AND
using a bootloader to boot this.
</para>

</section>

</section>

<section>
<title>Building a netboot image</title>

<para>
	The following sequence of helper commands will create a basic netboot image
containing the Debian standard system without X.org. It is suitable for
booting over the network.
</para>

<para>
	Note if you performed any previous examples, you will need to clean up your
working directory with the <filename>lh clean</filename> helper command:
</para>

<para>
	<screen>$ lh clean --binary</screen>
</para>

<para>
	Run the <filename>lh config</filename> helper command with the parameters to
configure the <filename>"config/"</filename> hierarchy to create our netboot
image:
</para>

<para>
	<screen>$ lh config -b net --net-root-path "/srv/debian-live" --net-root-server "192.168.0.1"</screen>
</para>

<para>
	In contrast with the ISO and USB hdd images, netbooting does not support
serving a filesystem image with the client so the files must be served via
NFS. The <replaceable>net-root-path</replaceable> and
<replaceable>net-root-server</replaceable> options specify the location and
server, respectively, of the NFS server where the filesytem image will be
located at boot-time.
</para>

<para>
	Now build the image with the <filename>lh build</filename> helper command:
</para>

<para>
	<screen># lh build</screen>
</para>

<para>
	In a network boot the client runs a small piece of software, which usually
resides on the <acronym>EEPROM</acronym> of the Ethernet card.  This program
sends a <abbrev>DHCP</abbrev> request to get an <abbrev>IP</abbrev> address
and information about what to do next.  Typically the next step is getting a
higher level boot loader via the <abbrev>TFTP</abbrev> protocol. That could
be <application>Grub</application>, <application>PXELINUX</application>, or
even boot directly to an operating system like
<application>Linux</application>.
</para>

<para>
	For example, if you unpack the generated
<filename>binary-net.tar.gz</filename> archive in the
<filename>/srv/debian-live</filename> directory, you'll find the filesystem
image in <filename>live/filesystem.squashfs</filename> and the kernel,
initrd and PXE Linux bootloader in
<filename>tftpboot/debian-live/i386</filename>.
</para>

<para>
	We must now configure three services on the server to enable netboot:
</para>

<variablelist>

<varlistentry>
<term>DHCP server</term>

<listitem>
<para>
	We must configure our network's DHCP server to be sure to give an
<abbrev>IP</abbrev> address to the computer netbooting, and to advertise the
location of the PXE bootloader.
</para>

<para>
	Here is an example for inspiration, written for the ISC DHCP server (package
<literal>dhcp3-server</literal>) in the
<filename>/etc/dhcp3/dhcpd.conf</filename> configuration file:
</para>

<para>
	<screen># Options DHCP spécifiques à Pxelinux:
option space pxelinux;
option pxelinux.magic      code 208 = string;
option pxelinux.configfile code 209 = text;
option pxelinux.pathprefix code 210 = text;
option pxelinux.reboottime code 211 = unsigned integer 32;


subnet 192.168.1.0 netmask 255.255.255.0 {   # 192.168.1.0/24

  # IP addresses available for guests
  range 192.168.1.100 192.168.1.149;

  # allow booting from the net
  allow bootp;

  # for net booting, server where the first file to be loaded (by TFTP
  # protocol) ("filename" following definition) lies : so the TFTP
  # server's name.
  next-server myserver;

  # net boot configuration for guests with a PXE client :
  if substring (option vendor-class-identifier, 0, 9) = "PXEClient" {
    # Note : all files for PXE are relatives to the TFTP server's root
    # path, as usually defined in /etc/inetd.conf.

    # PXE boot loader (first program to be loaded, by TFTP)
    filename "pxelinux.0";

    # describe some specific pxelinux's options through DHCP options :
    site-option-space "pxelinux";
    option pxelinux.magic f1:00:74:7e;
    if exists dhcp-parameter-request-list {
      # Always send the PXELINUX options (specified in hexadecimal)
      option dhcp-parameter-request-list = concat(option dhcp-parameter-request-list,d0,d1,d2,d3);
    }

    # For a PXE boot menu, different versions are available : simple
    # text, text with curses, graphic (VESA)
    #option pxelinux.configfile "pxelinux/config_simple";
    #option pxelinux.configfile "pxelinux/config_curses";
    option pxelinux.configfile "pxelinux/config_vesa";

    # automatically reboot after 10 minutes of no activity
    option pxelinux.reboottime 600;
  }
}</screen>
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>TFTPd server</term>

<listitem>
<para>
	This serves the kernel and initial ramdisk to the system at run-time.
</para>

<para>
	You should install the <command>tftpd-hpa</command> package. It can serve
all files contained inside a root directory, usually
<filename>/var/lib/tftpboot/</filename>, as defined with its
<option>-s</option> option. To let it serve files inside
<filename>/srv/debian-live/tftpboot</filename>, modify its start definition
in <filename>/etc/inetd.conf</filename> with:
</para>

<para>
	<screen>tftp           dgram   udp     wait    root  /usr/sbin/in.tftpd /usr/sbin/in.tftpd -s /srv/debian-live/tftpboot -r blksize -v -v</screen>
</para>

<para>
	and reload the super server with <command>/etc/init.d/openbsd-inetd
reload</command>.
</para>
</listitem>
</varlistentry>

<varlistentry>
<term>NFS server</term>

<listitem>
<para>
	Once the guest computer has downloaded and booted a Linux kernel and loaded
its initrd, it will try to mount the Live filesystem image through a NFS
server.
</para>

<para>
	You should install the <command>nfs-kernel-server</command> package --
<command>nfs-user-server</command> does not function correctly with netboot.
</para>

<para>
	Then, make the filesystem image available through NFS by adding a line like
the following to <filename>/etc/exports</filename>:
</para>

<para>
	<screen>/srv/debian-live *(ro,async,subtree_check,no_root_squash)</screen>
</para>

<para>
	and tell the NFS server about this new export with the following command:
</para>

<para>
	<screen># exportfs -rv</screen>
</para>
</listitem>
</varlistentry>

</variablelist>

<para>
	Setting up these three services can be a little tricky. You might need some
patience to get all of them working together. The Debian Installer Manual's
<ulink url="http://d-i.alioth.debian.org/manual/en.i386/ch04s05.html" >TFTP
Net Booting</ulink> section might help as that process is very similar.
</para>

</section>

<section>
<title> Netboot testing HowTo </title>

<para>
	Netboot image creation is made easy with live-helper magic, but testing the
images on physical machines can be really time consuming.
</para>

<para>
	To make our life easier, we can use virtualization. There are two solutions:
</para>

<variablelist>

<varlistentry>
<term>VMWare Player</term>

<listitem>
<para>
	Install VMWare Player ("free as in beer" edition)
</para>

<para>
	Create a PXETester directory, and create a text file called pxe.vwx inside
</para>

<para>
	Paste this text inside:
</para>

<para>
	<screen>#!/usr/bin/vmware
config.version = "8"
virtualHW.version = "4"
memsize = "512"
MemAllowAutoScaleDown = "FALSE"

ide0:0.present = "FALSE"
ide1:0.present = "FALSE"
floppy0.present = "FALSE"
sound.present = "FALSE"
tools.remindInstall = "FALSE"

ethernet0.present = "TRUE"
ethernet0.addressType = "generated"

displayName = "Test Boot PXE"
guestOS = "other"

ethernet0.generatedAddress = "00:0c:29:8d:71:3b"
uuid.location = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
uuid.bios = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
ethernet0.generatedAddressOffset = "0"</screen>
</para>

<para>
	You can play with this configuration file (i.e. change memory limit to 256)
</para>

<para>
	Double click on this file (or run VMWare player and selecet this file).
</para>

<para>
	When running just press space if that strange question comes up...
</para>
</listitem>
</varlistentry>

</variablelist>

<variablelist>

<varlistentry>
<term>Qemu</term>

<listitem>
<para>
	Install qemu, bridge-utils, sudo.
</para>

<para>
	Edit <filename>/etc/qemu-ifup</filename>:
</para>

<para>
	<screen>#!/bin/sh
sudo -p "Password for $0:" /sbin/ifconfig $1 172.20.0.1
echo "Executing /etc/qemu-ifup"
echo "Bringing up $1 for bridged mode..."
sudo /sbin/ifconfig $1 0.0.0.0 promisc up
echo "Adding $1 to br0..."
sudo /usr/sbin/brctl addif br0 $1
sleep 2</screen>
</para>

<para>
	Get, or build a grub-floppy-netboot (in the svn).
</para>

<para>
	Launch qemu with "-net nic,vlan=0 -net tap,vlan=0,ifname=tun0"
</para>
</listitem>
</varlistentry>

</variablelist>

</section>

</chapter>
