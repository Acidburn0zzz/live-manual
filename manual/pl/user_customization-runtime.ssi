:B~ Dostosowywanie zdarzeń podczas uruchamiania systemu

1~customizing-run-time-behaviours Dostosowywanie zdarzeń podczas
uruchamiania systemu

Cała konfiguracja, która odbywa się w czasie pracy systemu jest wykonywana
przez live-config. Oto niektóre z najbardziej popularnych opcji live-config,
którymi mogą być zainteresowani użytkownicy. Pełną listę wszystkich
możliwości można znaleźć w podręczniku man pakietu live-config.

2~ Personalizacja użytkownika live

One important consideration is that the live user is created by live-boot at
boot time, not by live-build at build time. This not only influences where
materials relating to the live user are introduced in your build, as
discussed in {Live/chroot local includes}#live-chroot-local-includes, but
also any groups and permissions associated with the live user.

You can specify additional groups that the live user will belong to by using
any of the possibilities to configure live-config. For example, to add the
live user to the #{fuse}# group, you can either add the following file in
#{config/includes.chroot/etc/live/config/user-setup.conf}#:

code{

 LIVE_USER_DEFAULT_GROUPS="audio cdrom dip floppy video plugdev netdev powerdev scanner bluetooth fuse"

}code

lub użyj
#{live-config.user-default-groups=audio,cdrom,dip,floppy,video,plugdev,netdev,powerdev,scanner,bluetooth,fuse}#
jako parametru startowego.

It is also possible to change the default username "user" and the default
password "live". If you want to do that for any reason, you can easily
achieve it as follows:

Aby zmienić domyślną nazwę użytkownika należy po prostu określić ją w
konfiguracji:

code{

 $ lb config --bootappend-live "boot=live components username=live-user"

}code

One possible way of changing the default password is by means of a hook as
described in {Boot-time hooks}#boot-time-hooks. In order to do that you can
use the "passwd" hook from #{/usr/share/doc/live-config/examples/hooks}#,
prefix it accordingly (e.g. 2000-passwd) and add it to
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Ustawianie lokalizacji i języka

Podczas uruchamiania systemu live, język jest definiowany przez dwa etapy:

_* generowanie plików lokalizacji

_* ustawienie konfiguracji klawiatury

The default locale when building a Live system is
#{locales=en_US.UTF-8}#. To define the locale that should be generated, use
the #{locales}# parameter in the #{--bootappend-live}# option of #{lb
config}#, e.g.

code{

 $ lb config --bootappend-live "boot=live components locales=de_CH.UTF-8"

}code

Wiele lokalizacji może być określone w postaci listy rozdzielonej
przecinkami.

This parameter, as well as the keyboard configuration parameters indicated
below, can also be used at the kernel command line. You can specify a locale
by #{language_country}# (in which case the default encoding is used) or the
full #{language_country.encoding}# word. A list of supported locales and the
encoding for each can be found in #{/usr/share/i18n/SUPPORTED}#.

Both the console and X keyboard configuration are performed by
#{live-config}# using the #{console-setup}# package. To configure them, use
the #{keyboard-layouts}#, #{keyboard-variants}#, #{keyboard-options}# and
#{keyboard-model}# boot parameters via the #{--bootappend-live}#
option. Valid options for these can be found in
#{/usr/share/X11/xkb/rules/base.lst}#. To find layouts and variants for a
given language, try searching for the English name of the language and/or
the country where the language is spoken, e.g:

code{

$ egrep -i '(^!|german.*switzerland)' /usr/share/X11/xkb/rules/base.lst
 ! model
 ! layout
   ch              German (Switzerland)
 ! variant
   legacy          ch: German (Switzerland, legacy)
   de_nodeadkeys   ch: German (Switzerland, eliminate dead keys)
   de_sundeadkeys  ch: German (Switzerland, Sun dead keys)
   de_mac          ch: German (Switzerland, Macintosh)
 ! option

}code

Należy pamiętać, że każdy wariant wymienia układ, którego dotyczy w opisie.

Często tylko układ klawiatury musi być skonfigurowany. Na przykład, aby
uzyskać listę plików lokalizacyjnych dla niemieckiego i szwajcarskiego
niemieckiego układu klawiatury w systemie X użyj:

code{

 $ lb config --bootappend-live "boot=live components locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

However, for very specific use cases, you may wish to include other
parameters. For example, to set up a French system with a French-Dvorak
layout (called Bepo) on a TypeMatrix EZ-Reach 2030 USB keyboard, use:

code{

 $ lb config --bootappend-live \
     "boot=live components locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variants=bepo keyboard-model=tm2030usb"

}code

Multiple values may be specified as comma-delimited lists for each of the
#{keyboard-*}# options, with the exception of #{keyboard-model}#, which
accepts only one value. Please see the #{keyboard(5)}# man page for details
and examples of #{XKBMODEL}#, #{XKBLAYOUT}#, #{XKBVARIANT}# and
#{XKBOPTIONS}# variables. If multiple #{keyboard-variants}# values are
given, they will be matched one-to-one with #{keyboard-layouts}# values (see
#{setxkbmap(1)}# #{-variant}# option). Empty values are allowed; e.g. to
define two layouts, the default being US QWERTY and the other being US
Dvorak, use:

code{

 $ lb config --bootappend-live \
     "boot=live components keyboard-layouts=us,us keyboard-variants=,dvorak"

}code

2~persistence Persistence

A live cd paradigm is a pre-installed system which runs from read-only
media, like a cdrom, where writes and modifications do not survive reboots
of the host hardware which runs it.

A live system is a generalization of this paradigm and thus supports other
media in addition to CDs; but still, in its default behaviour, it should be
considered read-only and all the run-time evolutions of the system are lost
at shutdown.

'Persistence' is a common name for different kinds of solutions for saving
across reboots some, or all, of this run-time evolution of the system. To
understand how it works it would be handy to know that even if the system is
booted and run from read-only media, modifications to the files and
directories are written on writable media, typically a ram disk (tmpfs) and
ram disks' data do not survive reboots.

The data stored on this ramdisk should be saved on a writable persistent
medium like local storage media, a network share or even a session of a
multisession (re)writable CD/DVD. All these media are supported in live
systems in different ways, and all but the last one require a special boot
parameter to be specified at boot time: #{persistence}#.

If the boot parameter #{persistence}# is set (and #{nopersistence}# is not
set), local storage media (e.g. hard disks, USB drives) will be probed for
persistence volumes during boot. It is possible to restrict which types of
persistence volumes to use by specifying certain boot parameters described
in the live-boot(7) man page. A persistence volume is any of the following:

_* partycja, identyfikowana po nazwie GPT.

_* system plików, identyfikowany po etykiecie.

_* plik obrazu zlokalizowany na każdym obsługiwanym systemie plików (nawet
na partycji NTFS innego systemu), identyfikowany po nazwie pliku.

The volume label for overlays must be #{persistence}# but it will be ignored
unless it contains in its root a file named #{persistence.conf}# which is
used to fully customize the volume's persistence, this is to say, specifying
the directories that you want to save in your persistence volume after a
reboot. See {The persistence.conf file}#persistence-conf for more details.

Here are some examples of how to prepare a volume to be used for
persistence. It can be, for instance, an ext4 partition on a hard disk or on
a usb key created with, e.g.:

code{

 # mkfs.ext4 -L persistence /dev/sdb1

}code

Zobacz również {Wykorzystanie przestrzeni pozostałej na nośniku
USB}#using-usb-extra-space.

Jeśli masz już partycję na urządzeniu, można po prostu zmienić jego etykietę
używając następującego polecenia:

code{

 # tune2fs -L persistence /dev/sdb1 # for ext2,3,4 filesystems

}code

Oto przykład, jak stworzyć plik obrazu opartego na ext4 do zastosowania z
opcją persistance:

code{

 $ dd if=/dev/null of=persistence bs=1 count=0 seek=1G # for a 1GB sized image file
 $ /sbin/mkfs.ext4 -F persistence

}code

Once the image file is created, as an example, to make #{/usr}# persistent
but only saving the changes you make to that directory and not all the
contents of #{/usr}#, you can use the "union" option. If the image file is
located in your home directory, copy it to the root of your hard drive's
filesystem and mount it in #{/mnt}# as follows:

code{

 # cp persistence /
 # mount -t ext4 /persistence /mnt

}code

Następnie utwórz plik #{persistence.conf}# dodając zawartość i odmontowując
plik obrazu.

code{

 # echo "/usr union" >> /mnt/persistence.conf
 # umount /mnt

}code

Teraz uruchom ponownie i wybierz nośnik live, a następnie uruchom dodając
parametr startowy "persistence".

3~persistence-conf Plik persistence.conf

A volume with the label #{persistence}# must be configured by means of the
#{persistence.conf}# file to make arbitrary directories persistent. That
file, located on the volume's filesystem root, controls which directories it
makes persistent, and in which way.

How custom overlay mounts are configured is described in full detail in the
persistence.conf(5) man page, but a simple example should be sufficient for
most uses. Let's say we want to make our home directory and APT cache
persistent in an ext4 filesystem on the /dev/sdb1 partition:

code{

# mkfs.ext4 -L persistence /dev/sdb1
 # mount -t ext4 /dev/sdb1 /mnt
 # echo "/home" >> /mnt/persistence.conf
 # echo "/var/cache/apt" >> /mnt/persistence.conf
 # umount /mnt

}code

Then we reboot. During the first boot the contents of #{/home}# and
#{/var/cache/apt}# will be copied into the persistence volume, and from then
on all changes to these directories will live in the persistence
volume. Please note that any paths listed in the #{persistence.conf}# file
cannot contain white spaces or the special #{.}# and #{..}# path
components. Also, neither #{/lib}#, #{/lib/live}# (or any of their
sub-directories) nor #{/}# can be made persistent using custom mounts. As a
workaround for this limitation you can add #{/ union}# to your
#{persistence.conf}# file to achieve full persistence.

3~ Używanie więcej niż jednego magazynu persistence

There are different methods of using multiple persistence store for
different use cases. For instance, using several volumes at the same time or
selecting only one, among various, for very specific purposes.

Several different custom overlay volumes (with their own
#{persistence.conf}# files) can be used at the same time, but if several
volumes make the same directory persistent, only one of them will be
used. If any two mounts are "nested" (i.e. one is a sub-directory of the
other) the parent will be mounted before the child so no mount will be
hidden by the other. Nested custom mounts are problematic if they are listed
in the same #{persistence.conf}# file. See the persistence.conf(5) man page
for how to handle that case if you really need it (hint: you usually don't).

One possible use case: If you wish to store the user data i.e. #{/home}# and
the superuser data i.e. #{/root}# in different partitions, create two
partitions with the #{persistence}# label and add a #{persistence.conf}#
file in each one like this, #{# echo "/home" > persistence.conf}# for the
first partition that will save the user's files and #{# echo "/root" >
persistence.conf}# for the second partition which will store the superuser's
files. Finally, use the #{persistence}# boot parameter.

If a user would need multiple persistence store of the same type for
different locations or testing, such as #{private}# and #{work}#, the boot
parameter #{persistence-label}# used in conjunction with the boot parameter
#{persistence}# will allow for multiple but unique persistence media. An
example would be if a user wanted to use a persistence partition labeled
#{private}# for personal data like browser bookmarks or other types, they
would use the boot parameters: #{persistence}#
#{persistence-label=private}#. And to store work related data, like
documents, research projects or other types, they would use the boot
parameters: #{persistence}# #{persistence-label=work}#.

It is important to remember that each of these volumes, #{private}# and
#{work}#, also needs a #{persistence.conf}# file in its root. The live-boot
man page contains more information about how to use these labels with legacy
names.

2~ Używanie opcji persistence z szyfrowaniem

Using the persistence feature means that some sensible data might get
exposed to risk. Especially if the persistent data is stored on a portable
device such as a usb stick or an external hard drive. That is when
encryption comes in handy. Even if the entire procedure might seem
complicated because of the number of steps to be taken, it is really easy to
handle encrypted partitions with live-boot. In order to use *{luks}*, which
is the supported encryption type, you need to install /{cryptsetup}/ both on
the machine you are creating the encrypted partition with and also in the
live system you are going to use the encrypted persistent partition with.

Aby zainstalować /{cryptsetup}/ na twoim komputerze:

code{

 # apt-get install cryptsetup

}code

Aby zainstalować /{cryptsetup}/ na twoim systemie live dodaj go do listy
pakietów:

code{

 $ echo "cryptsetup" > config/package-lists/encryption.list.chroot

}code

Once you have your live system with /{cryptsetup}/, you basically only need
to create a new partition, encrypt it and boot with the #{persistence}# and
#{persistence-encryption=luks}# parameters. We could have already
anticipated this step and added the boot parameters at build time following
the usual procedure:

code{

 $ lb config --bootappend-live "boot=live components persistence persistence-encryption=luks"

}code

przejdzmy do szczegółów dla tych wszystkich, którzy nie są zaznajomieni z
szyfrowaniem. W poniższym przykładzie mamy zamiar użyć partycji na dysku
USB, która odpowiada #{/dev/sdc2}#. Należy zaznaczyć, że należy ustalić,
która partycja jest jeden tą, którą masz zamiar używać w tym konkretnym
przypadku.

Pierwszym krokiem jest podłączenie dysku USB i określenie, którym jest
urządzeniem. Zalecaną metodą tworzenia listy urządzeń w live-manual jest
#{ls -l /dev/disk/by-id}#. Następnie utworzymy nową partycję, a następnie
zaszyfrujemy ją hasłem w następujący sposób:

code{

 # cryptsetup --verify-passphrase luksFormat /dev/sdc2

}code

Następnie otwieramy partycję LUKS w wirtualnym elemencie odwzorowującym
urządzenia *{/dev/mapper}*. Można tu użyć dowolnej nazww. Używamy *{live}*
jako przykład:

code{

 # cryptsetup luksOpen /dev/sdc2 live

}code

Następnym krokiem jest wypełnienie urządzenia zerami przed utworzeniem
systemu plików:

code{

 # dd if=/dev/zero of=/dev/mapper/live

}code

Teraz jesteśmy gotowi do stworzenia systemu plików. Warto zauważyć, że
dodajemy etykietę #{persistence}# tak, aby urządzenie zotało zamontowane w
jako persistence store (magazyn persistence) w czasie startu systemu.

code{

 # mkfs.ext4 -L persistence /dev/mapper/live

}code

Aby kontynuować naszą konfigurację, musimy zamontować urządzenie, na
przykład w #{/mnt}#.

code{

 # mount /dev/mapper/live /mnt

}code

I stwórz plik #{persistence.conf}# w katalogu głównym partycji. To jest, jak
wyjaśniono wyżej, absolutnie konieczne. Zobacz {Plik
persistence.conf}#persistence-conf.

code{

 # echo "/ union" > /mnt/persistence.conf

}code

Potem odmontuj punkt montowania:

code{

 # umount /mnt

}code

I opcjonalnie, choć może to być dobry sposób na zabezpieczenie danych, które
właśnie dodaliśmy do partycji, możemy zamknąć urządzenie:

code{

 # cryptsetup luksClose live

}code

Podsumujmy proces. Do tej pory stworzyliśmy system live z możliwością
szyfrowania, który można skopiować na nośnik usb, jak wyjaśniono w
{kopiowaniu hybrydowego obrazu ISO na nośnik pamięci
USB}#copying-iso-hybrid-to-usb. Stworzyliśmy również zaszyfrowaną partycję,
która może znajdować się na tym samym nośniku usb, aby można było go nosić
ze sobą wszędzie i mamy skonfigurowaną zaszyfrowaną partycję, stosowaną jako
magazyn persistence. Więc teraz, musimy tylko uruchomić system live. W
czasie startu systemu, na live-boot poprosi nas o wpisanie hasła i zamontuje
zaszyfrowaną partycję używaną przez opcję persistence.
