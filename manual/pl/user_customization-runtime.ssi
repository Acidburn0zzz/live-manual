:B~ Dostosowywanie zdarzeń podczas uruchamiania systemu

1~customizing-run-time-behaviours Dostosowywanie zdarzeń podczas
uruchamiania systemu

Cała konfiguracja, która odbywa się w czasie pracy systemu jest wykonywana
przez live-config. Oto niektóre z najbardziej popularnych opcji live-config,
którymi mogą być zainteresowani użytkownicy. Pełną listę wszystkich
możliwości można znaleźć w podręczniku man pakietu live-config.

2~ Personalizacja użytkownika live

Jednym ważnym czynnikiem jest to, że użytkownik jest tworzony przez
live-boot w czasie startu systemu, a nie live-build w czasie kompilacji. To
wpływa nie tylko, na to gdzie materiały dotyczące użytkownika live są
wprowadzone w kompilacji, jak to opisano w {Uwzględnianie lokalne
Live/chroot}#live-chroot-local-includes, ale również na wszelkie grupyi
uprawnienia związane z użytkownikiem live.

Można określić dodatkowe grupy, do których użytkownik live będzie należeć
korzystając z jednej z możliwości, aby skonfigurować live-config. Na
przykład, aby dodać użytkownika live do grupy #{fuse}#, można dodać
następujący plik w
#{config/includes.chroot/etc/live/config/user-setup.conf}#:

code{

 LIVE_USER_DEFAULT_GROUPS="audio cdrom dip floppy video plugdev netdev powerdev scanner bluetooth fuse"

}code

lub użyj
#{live-config.user-default-groups=audio,cdrom,dip,floppy,video,plugdev,netdev,powerdev,scanner,bluetooth,fuse}#
jako parametru startowego.

Możliwe jest również, aby zmienić domyślną nazwę użytkownika "user" i
domyślne hasło "live". Jeśli chcesz to zrobić, z jakiegokolwiek powodu,
można to łatwo osiągnąć w następujący sposób:

Aby zmienić domyślną nazwę użytkownika należy po prostu określić ją w
konfiguracji:

code{

 $ lb config --bootappend-live "boot=live components username=live-user"

}code

Jednym z możliwych sposobów zmiany domyślnego hasła jest użycie
odpowiedniego haka, jak opisano w {Haki podczas uruchamiania
systemu}#boot-time-hooks. W tym celu można użyć haka "passwd" z
#{/usr/share/doc/live-config/examples/hooks}#, przedrostkiem jest
odpowiednio (np. 2000-passwd), należy go dodać do
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Ustawianie lokalizacji i języka

Podczas uruchamiania systemu live, język jest definiowany przez dwa etapy:

_* generowanie plików lokalizacji

_* ustawienie konfiguracji klawiatury

Domyślne ustawieniem lokalnym podczas budowania systemu live jest
#{locales=en_US.UTF-8}#. Aby określić ustawienia regionalne, które powinny
być wygenerowane, użyj parametru #{locales}# w opcji #{--bootappend-live}#
polecenia #{lb config}#, np.

code{

 $ lb config --bootappend-live "boot=live components locales=de_CH.UTF-8"

}code

Wiele lokalizacji może być określone w postaci listy rozdzielonej
przecinkami.

Parametr ten, jak również parametr konfiguracyjny klawiatury jak wskazano
poniżej, może być również używany w linii poleceń jądra. Można określić
ustawienia regionalne poprzez #{language_country}# (w tym przypadku używane
jest kodowanie domyślne) lub pełnej nazwy z kodowaniem
#{language_country.encoding}#. Lista obsługiwanych lokalizacji i kodowań
można znaleźć w #{/usr/share/i18n/SUPPORTED}#.

Both the console and X keyboard configuration are performed by
#{live-config}# using the #{console-setup}# package. To configure them, use
the #{keyboard-layouts}#, #{keyboard-variants}#, #{keyboard-options}# and
#{keyboard-model}# boot parameters via the #{--bootappend-live}#
option. Valid options for these can be found in
#{/usr/share/X11/xkb/rules/base.lst}#. To find layouts and variants for a
given language, try searching for the English name of the language and/or
the country where the language is spoken, e.g:

code{

$ egrep -i '(^!|german.*switzerland)' /usr/share/X11/xkb/rules/base.lst
 ! model
 ! layout
   ch              German (Switzerland)
 ! variant
   legacy          ch: German (Switzerland, legacy)
   de_nodeadkeys   ch: German (Switzerland, eliminate dead keys)
   de_sundeadkeys  ch: German (Switzerland, Sun dead keys)
   de_mac          ch: German (Switzerland, Macintosh)
 ! option

}code

Należy pamiętać, że każdy wariant wymienia układ, którego dotyczy w opisie.

Często tylko układ klawiatury musi być skonfigurowany. Na przykład, aby
uzyskać listę plików lokalizacyjnych dla niemieckiego i szwajcarskiego
niemieckiego układu klawiatury w systemie X użyj:

code{

 $ lb config --bootappend-live "boot=live components locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

Jednak dla bardzo konkretnych przypadków użycia, można dodać inne
parametry. Na przykład, aby ustawić francuski system z układem klawiatury
French-Dvorak (zwany Bepo) na klawiaturze USB TypeMatrix EZ-Reach 2030,
użyj:

code{

 $ lb config --bootappend-live \
     "boot=live components locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variants=bepo keyboard-model=tm2030usb"

}code

Multiple values may be specified as comma-delimited lists for each of the
#{keyboard-*}# options, with the exception of #{keyboard-model}#, which
accepts only one value. Please see the #{keyboard(5)}# man page for details
and examples of #{XKBMODEL}#, #{XKBLAYOUT}#, #{XKBVARIANT}# and
#{XKBOPTIONS}# variables. If multiple #{keyboard-variants}# values are
given, they will be matched one-to-one with #{keyboard-layouts}# values (see
#{setxkbmap(1)}# #{-variant}# option). Empty values are allowed; e.g. to
define two layouts, the default being US QWERTY and the other being US
Dvorak, use:

code{

 $ lb config --bootappend-live \
     "boot=live components keyboard-layouts=us,us keyboard-variants=,dvorak"

}code

2~persistence Persistence

A live cd paradigm is a pre-installed system which runs from read-only
media, like a cdrom, where writes and modifications do not survive reboots
of the host hardware which runs it.

A live system is a generalization of this paradigm and thus supports other
media in addition to CDs; but still, in its default behaviour, it should be
considered read-only and all the run-time evolutions of the system are lost
at shutdown.

'Persistence' is a common name for different kinds of solutions for saving
across reboots some, or all, of this run-time evolution of the system. To
understand how it works it would be handy to know that even if the system is
booted and run from read-only media, modifications to the files and
directories are written on writable media, typically a ram disk (tmpfs) and
ram disks' data do not survive reboots.

The data stored on this ramdisk should be saved on a writable persistent
medium like local storage media, a network share or even a session of a
multisession (re)writable CD/DVD. All these media are supported in live
systems in different ways, and all but the last one require a special boot
parameter to be specified at boot time: #{persistence}#.

If the boot parameter #{persistence}# is set (and #{nopersistence}# is not
set), local storage media (e.g. hard disks, USB drives) will be probed for
persistence volumes during boot. It is possible to restrict which types of
persistence volumes to use by specifying certain boot parameters described
in the live-boot(7) man page. A persistence volume is any of the following:

_* partycja, identyfikowana po nazwie GPT.

_* system plików, identyfikowany po etykiecie.

_* plik obrazu zlokalizowany na każdym obsługiwanym systemie plików (nawet
na partycji NTFS innego systemu), identyfikowany po nazwie pliku.

The volume label for overlays must be #{persistence}# but it will be ignored
unless it contains in its root a file named #{persistence.conf}# which is
used to fully customize the volume's persistence, this is to say, specifying
the directories that you want to save in your persistence volume after a
reboot. See {The persistence.conf file}#persistence-conf for more details.

Here are some examples of how to prepare a volume to be used for
persistence. It can be, for instance, an ext4 partition on a hard disk or on
a usb key created with, e.g.:

code{

 # mkfs.ext4 -L persistence /dev/sdb1

}code

Zobacz również {Wykorzystanie przestrzeni pozostałej na nośniku
USB}#using-usb-extra-space.

Jeśli masz już partycję na urządzeniu, można po prostu zmienić jego etykietę
używając następującego polecenia:

code{

 # tune2fs -L persistence /dev/sdb1 # for ext2,3,4 filesystems

}code

Oto przykład, jak stworzyć plik obrazu opartego na ext4 do zastosowania z
opcją persistance:

code{

 $ dd if=/dev/null of=persistence bs=1 count=0 seek=1G # for a 1GB sized image file
 $ /sbin/mkfs.ext4 -F persistence

}code

Po utworzeniu pliku obrazu, na przykład, aby sprawić by katalog #{/usr}# był
prwały, ale tylko zapisywał zmiany wprowadzone w tym katalogu, a nie całą
zawartość #{/usr}#, można użyć opcji "union". Jeśli plik obrazu znajduje się
w katalogu domowym, należy skopiować go do katalogu głównego systemu plików
na dysku twardym i zamontować go w #{/mnt}# w następujący sposób:

code{

 # cp persistence /
 # mount -t ext4 /persistence /mnt

}code

Następnie utwórz plik #{persistence.conf}# dodając zawartość i odmontowując
plik obrazu.

code{

 # echo "/usr union" >> /mnt/persistence.conf
 # umount /mnt

}code

Teraz uruchom ponownie i wybierz nośnik live, a następnie uruchom dodając
parametr startowy "persistence".

3~persistence-conf Plik persistence.conf

Partycję z etykietą #{persistence}# należy skonfigurować za pomocą pliku
#{persistence.conf}#, aby dowolne katalogi stały się trwałe. Ten plik,
znajdujący się w głównym katalogu systemu plików partycji, kontroluje które
katalogi są trwałe i w jaki sposób.

To jak niestandardowe wierzchnie zamontowania są skonfigurowane jest opisane
w szczegółach w podręczniku man persistence.conf(5), ale ten prosty przykład
powinien być wystarczający dla większości zastosowań. Powiedzmy, że chcemy,
aby nasz katalog domowy i cache APT było trwałe w pamięci podręcznej systemu
plików ext4 na partycji /dev/sdb1:

code{

# mkfs.ext4 -L persistence /dev/sdb1
 # mount -t ext4 /dev/sdb1 /mnt
 # echo "/home" >> /mnt/persistence.conf
 # echo "/var/cache/apt" >> /mnt/persistence.conf
 # umount /mnt

}code

Then we reboot. During the first boot the contents of #{/home}# and
#{/var/cache/apt}# will be copied into the persistence volume, and from then
on all changes to these directories will live in the persistence
volume. Please note that any paths listed in the #{persistence.conf}# file
cannot contain white spaces or the special #{.}# and #{..}# path
components. Also, neither #{/lib}#, #{/lib/live}# (or any of their
sub-directories) nor #{/}# can be made persistent using custom mounts. As a
workaround for this limitation you can add #{/ union}# to your
#{persistence.conf}# file to achieve full persistence.

3~ Używanie więcej niż jednego magazynu persistence

Istnieją różne sposoby korzystania z wielu magazynów trwałości
(ang. persistence) dla różnych zastosowań. Na przykład, przy używanie kilku
magazynów w tym samym czasie lub wybranie tylko jednego, spośród różnych, do
bardzo specyficznych zastosowań.

Several different custom overlay volumes (with their own
#{persistence.conf}# files) can be used at the same time, but if several
volumes make the same directory persistent, only one of them will be
used. If any two mounts are "nested" (i.e. one is a sub-directory of the
other) the parent will be mounted before the child so no mount will be
hidden by the other. Nested custom mounts are problematic if they are listed
in the same #{persistence.conf}# file. See the persistence.conf(5) man page
for how to handle that case if you really need it (hint: you usually don't).

One possible use case: If you wish to store the user data i.e. #{/home}# and
the superuser data i.e. #{/root}# in different partitions, create two
partitions with the #{persistence}# label and add a #{persistence.conf}#
file in each one like this, #{# echo "/home" > persistence.conf}# for the
first partition that will save the user's files and #{# echo "/root" >
persistence.conf}# for the second partition which will store the superuser's
files. Finally, use the #{persistence}# boot parameter.

Jeśli użytkownik będzie potrzebował wiele magazynów trwałości tego samego
typu dla różnych miejsc lub dla celów testowych, takich jak magazyny
#{private}# i ​​#{work}# parametr startowy #{persistence-label}# użyty w
połączeniu z parametrem #{persistence}# pozwoli na wiele unikatowych
magazynów trwałości. Przykładem może być, jeśli użytkownik chciałby użyć
partycji trwałości oznaczonej #{private}# dla prywatnych danych, takich jak
zakładki w przeglądarce lub innych typów danych, to mógłby użyć parametrów
startowych:#{persistence}# #{persistence-label=private}#. A do
przechowywania danych związanych z pracą, takich jak dokumenty, projekty
badawcze lub inne rodzaje, mógłby skorzystać z parametrów startowych:
#{persistence}# #{persistence-label=work}#.

Ważne jest, aby pamiętać, że każda z tych partycji, #{private}# i
​​#{work}#, także potrzebuje pliku #{persistence.conf}#. Podręcznik man
pakietu live-boot zawiera więcej informacji o tym, jak korzystać z tych
etykiet z zapisanymi nazwami.

2~ Używanie opcji persistence z szyfrowaniem

Korzystanie z funkcji trwałości (ang. persistence) oznacza, że ​​niektóre
poufne dane mogą zostać narażone na ryzyko. Zwłaszcza jeśli trwałe dane są
przechowywane na urządzeniu przenośnym, takim jak pamięci USB lub zewnętrzne
dyski twarde. To jest miejsce, gdzie przydatne staje się  szyfrowanie. Nawet
jeśli cała procedura może wydawać się skomplikowana, ze względu na liczbę
kroków, które należy podjąć, to jest bardzo łatwo obsługiwać szyfrowane
partycje z live-boot. Aby móc korzystać z *{luks}*, który jest obsługiwanym
typem szyfrowania, musisz zainstalować /{cryptsetup}/ zarówno na maszynie
tworzenia zaszyfrowanych partycji, a także w systemie live, który będzie
używał szyfrowanej trwałej partycji.

Aby zainstalować /{cryptsetup}/ na twoim komputerze:

code{

 # apt-get install cryptsetup

}code

Aby zainstalować /{cryptsetup}/ na twoim systemie live dodaj go do listy
pakietów:

code{

 $ lb init
 $ echo "cryptsetup" > config/package-lists/encryption.list.chroot

}code

Once you have your live system with /{cryptsetup}/, you basically only need
to create a new partition, encrypt it and boot with the #{persistence}# and
#{persistence-encryption=luks}# parameters. We could have already
anticipated this step and added the boot parameters following the usual
procedure:

code{

 $ lb config --bootappend-live "boot=live components persistence persistence-encryption=luks"

}code

przejdzmy do szczegółów dla tych wszystkich, którzy nie są zaznajomieni z
szyfrowaniem. W poniższym przykładzie mamy zamiar użyć partycji na dysku
USB, która odpowiada #{/dev/sdc2}#. Należy zaznaczyć, że należy ustalić,
która partycja jest jeden tą, którą masz zamiar używać w tym konkretnym
przypadku.

Pierwszym krokiem jest podłączenie dysku USB i określenie, którym jest
urządzeniem. Zalecaną metodą tworzenia listy urządzeń w live-manual jest
#{ls -l /dev/disk/by-id}#. Następnie utworzymy nową partycję, a następnie
zaszyfrujemy ją hasłem w następujący sposób:

code{

 # cryptsetup --verify-passphrase luksFormat /dev/sdc2

}code

Następnie otwieramy partycję LUKS w wirtualnym elemencie odwzorowującym
urządzenia *{/dev/mapper}*. Można tu użyć dowolnej nazww. Używamy *{live}*
jako przykład:

code{

 # cryptsetup luksOpen /dev/sdc2 live

}code

Następnym krokiem jest wypełnienie urządzenia zerami przed utworzeniem
systemu plików:

code{

 # dd if=/dev/zero of=/dev/mapper/live

}code

Teraz jesteśmy gotowi do stworzenia systemu plików. Warto zauważyć, że
dodajemy etykietę #{persistence}# tak, aby urządzenie zotało zamontowane w
jako persistence store (magazyn persistence) w czasie startu systemu.

code{

 # mkfs.ext4 -L persistence /dev/mapper/live

}code

Aby kontynuować naszą konfigurację, musimy zamontować urządzenie, na
przykład w #{/mnt}#.

code{

 # mount /dev/mapper/live /mnt

}code

I stwórz plik #{persistence.conf}# w katalogu głównym partycji. To jest, jak
wyjaśniono wyżej, absolutnie konieczne. Zobacz {Plik
persistence.conf}#persistence-conf.

code{

 # echo "/ union" > /mnt/persistence.conf

}code

Potem odmontuj punkt montowania:

code{

 # umount /mnt

}code

I opcjonalnie, choć może to być dobry sposób na zabezpieczenie danych, które
właśnie dodaliśmy do partycji, możemy zamknąć urządzenie:

code{

 # cryptsetup luksClose live

}code

Podsumujmy proces. Do tej pory stworzyliśmy system live z możliwością
szyfrowania, który można skopiować na nośnik usb, jak wyjaśniono w
{kopiowaniu hybrydowego obrazu ISO na nośnik pamięci
USB}#copying-iso-hybrid-to-usb. Stworzyliśmy również zaszyfrowaną partycję,
która może znajdować się na tym samym nośniku usb, aby można było go nosić
ze sobą wszędzie i mamy skonfigurowaną zaszyfrowaną partycję, stosowaną jako
magazyn persistence. Więc teraz, musimy tylko uruchomić system live. W
czasie startu systemu, na live-boot poprosi nas o wpisanie hasła i zamontuje
zaszyfrowaną partycję używaną przez opcję persistence.
