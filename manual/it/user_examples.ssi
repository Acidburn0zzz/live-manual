:B~ Esempi

1~examples Esempi

Questo capitolo affronta alcune costruzioni di esempio per specifici casi
d'uso con Debian Live. Se si è nuovi nella costruzione di immagini Debian
Live, raccomandiamo di dare innanzitutto un'occhiata ai tre tutorial in
sequenza, dato che ciascuno insegna nuove tecniche che aiuteranno nell'uso e
nella comprensione degli esempi rimanenti.

2~using-the-examples Usare gli esempi

Per usare questi esempi è necessario un sistema per costruirveli sopra che
soddisfi i requisiti elencati in {Requirements}#requirements e avere
live-build installato come descritto in {Installing
live-build}#installing-live-build.

Si noti che, for the sake of brevity, in questi esempi non specifichiamo un
mirror locale da usare per la costruzione. Si può accelerare i download
considerevolmente se si usa un mirror locale. Si possono specificare le
opzioni quando si usa #{lb config}#, come descritto in {Distribution mirrors
used at build time}#distribution-mirrors-build-time, o più convenientemente
impostare il default per il proprio sistema di generazione in
#{/etc/live/build.conf}#. Semplicemente si crei questo file ed in esso si
impostino le corrispondenti variabili #{LB_MIRROR_*}# per il proprio mirror
preferito. Ad esempio:

code{

LB_MIRROR_BOOTSTRAP="http://mirror/debian"
LB_MIRROR_CHROOT="http://mirror/debian"
LB_MIRROR_CHROOT_SECURITY="http://mirror/debian-security"

}code

2~tutorial-1 Tutorial 1: un'immagine standard

*{Caso d'uso:}* Creazione di una semplice prima immagine, imparando le basi di live-build.

In questo tutorial genereremo un'immagine ISO ibrida Debian Live di default
contenente solo pacchetti di base (niente Xorg) e alcuni pacchetti Debian
Live di supporto, come primo esercizio sull'uso di live-build.

Non si può fare in modo molto più semplice di così:

code{

$ mkdir tutorial1 ; cd tutorial1 ; lb config

}code

Si esaminino i contenuti della directory #{config/}# se si desidera. Si
vedrà qui immagazzinato uno scheletro di configurazione, pronto per essere
personalizzato o, in questo caso, usato immediatamente per costruire
un'immagine di default.

Ora, come super-utente, si generi l'immagine, salvando un log con #{tee}#.

code{

# lb build 2>&1 | tee binary.log

}code

Assumendo che tutto vada per il verso giusto, dopo un po' la directory
corrente conterrà #{binary-hybrid.iso}#. Questa immagine ISO ibrida può
essere avviata direttamente in una macchina virtuale come descritto in
{Testing an ISO image with Qemu}#testing-iso-with-qemu e{Testing an ISO
image with virtualbox-ose}#testing-iso-with-virtualbox, oppure masterizzata
su un supporto ottico o ancora su una chiavetta USB come descritto
rispettivamente in {Burning an ISO image to a physical
medium}#burning-iso-image e {Copying USB/HDD image to a USB
stick}#copying-usb-hdd-image.

2~tutorial-2 Tutorial 2: servizio browser web

*{Caso d'uso:}* Creazione di un'immagine per servizio browser web, che insegna come applicare personalizzazioni.

In questo tutorial creeremo un'immagine adatta all'uso come servizio browser
web, che ci serve come introduzione alla personalizzazione delle immagini
Debian Live.

code{

mkdir tutorial2 ; cd tutorial2 ; lb config -p lxde --packages iceweasel

}code

La scelta di LXDE per questo esempio riflette il nostro desiderio di fornire
un ambiente desktop minimale, dato che il punto focale dell'immagine è il
singolo uso che abbiamo in mente, il browser web. Potremmo anche spingerci
oltre e fornire una configurazione di default per il browser web in
#{config/chroot_local-includes/etc/iceweasel/profile/}#, o pacchetti
addizionali di supporto per la fruizione di vari tipi di contenuti web, ma
lasciamo questo come esercizio per il lettore.

Si generi l'immagine, ancora come super-utente, conservando un log come in
{Tutorial 1}#tutorial-1:

code{

# lb build 2>&1 | tee binary.log

}code

Di nuovo, si verifichi che l'immagine sia a posto e la si collaudi, come in
{Tutorial 1}#tutorial-1.

2~tutorial-3 Tutorial 3: un'immagine personalizzata

*{Caso d'uso:}* creare un progetto per costruire un'immagine personalizzata, contenete i pacchetti preferiti da portare con sé in una chiavetta USB ovunque si vada, in continua evoluzione nelle revisioni successive allorché i bisogni o le preferenze cambino.

Dal momento che la nostra immagine personalizzata cambierà in un certo
numero di revisioni, e che vogliamo tener traccia di questi cambiamenti,
cercando cose sperimentalmente ed eventualmente tornando indietro se
qualcosa non funziona, conserveremo la nostra configurazione nel popolare
sistema di controllo di versione #{git}#. Useremo anche le migliori pratiche
di auto-configurazione tramite gli script #{auto}# come descritto in
{Managing a configuration}#managing-a-configuration.

3~ Prima revisione

code{

$ mkdir -p tutorial3/auto $ cp /usr/share/live/build/examples/auto/*
tutorial3/auto/ $ cd tutorial3

}code

Modificare #{auto/config}# come segue:

code{

#!/bin/sh

lb config noauto \
    --architecture i386 \
    --linux-flavours 686 \
    --packages-lists lxde \
    --packages "iceweasel xchat" \
    "${@}"

}code

Per prima cosa, #{--architecture i386}# ci assicura che sul nostro sistema
di build #{amd64}#, costruiamo una versione a 32-bit utilizzabile sulla
maggior parte delle macchine. In secondo luogo, usiamo #{--linux-flavours
686}# dato che non prevediamo di usare questa immagine su sistemi troppo
vecchi. Terzo, abbiamo scelto la lista di pacchetti #{lxde}# per avere un
desktop minimale. Infine, abbiamo aggiunto due pacchetti preferiti per
cominciare: #{iceweasel}# e #{xchat}#.

Ora, costruire l'immagine:

code{

# lb build

}code

Si noti che diversamente dai primi due tutorial, non abbiamo più da digitare
#{2>&1 | tee binary.log}# dato che questo è ora incluso in #{auto/build}#.

Una volta che si sia collaudata l'immagine (come in {Tutorial 1}#tutorial-1)
e che si sia persuasi che funzioni correttamente, è il momento di
inizializzare il nostro repository #{git}#, aggiungendo solo gli script auto
che abbiamo appena creato, e poi di fare il primo commit:

code{

$ git init $ git add auto $ git commit -a -m "Initial import."

}code

3~ Seconda revisione

In questa revisione ripuliremo il primo build, aggiungeremo il pacchetto
#{vlc}# alla nostra configurazione, faremo un nuovo build, test e commit.

Il comando #{lb clean}# ripulirà tutti i file generati dalla precedente
costruzione eccetto che per la cache, che ci evita un nuovo download dei
pacchetti. Ciò assicura che il seguente #{lb build}# eseguirà di nuovo tutti
i passaggi per rigenerare i file dalla nostra nuova configurazione.

code{

# lb clean

}code

Si editi ora #{auto/config}# per aggiungere il pacchetto #{vlc}#:

code{

#!/bin/sh

lb config noauto \
    --architecture i386 \
    --linux-flavours 686 \
    --packages-lists lxde \
    --packages "iceweasel xchat vlc" \
    "${@}"

}code

Costruire nuovamente:

code{

# lb build

}code

Verificare, e quando soddisfatti, eseguire il commit della revisione
successiva:

code{

$ git commit -a -m "Adding vlc media player."

}code

Ovviamente sono possibili cambiamenti della configurazione più complicati,
magari aggiungendo file in sottodirectory di #{config/}#. Quando si esegue
il commit di nuove revisioni, si faccia solo attenzione a non editare
manualmente o fare un commit dei file al più alto livello di #{config}# che
contengono variabili #{LB_*}#, dato che si tratta di prodotti della
costruzione, anche, e che sono sempre ripuliti da #{lb clean}# e ricreati
con #{lb config}# attraversi i loro rispettivi script #{auto}#.

Siamo arrivati alla fine di questa nostra serie di tutorial. Molti altri
tipi di personalizzazioni sono possibili, anche solo usando i pochi
strumenti esplorati i questi semplici esempi; di conseguenza può essere
creata una varietà quasi infinita di immagini. Gli esempi rimanenti in
questa sezione coprono diversi altri casi d'uso estrapolati dalle esperienze
raccolte degli utenti Debian Live.

2~ A VNC Kiosk Client

*{Use case:}* Create an image with live-build to boot directly to a VNC server.

_* Make a build directory: #{$ mkdir vncBuild}#

_* Move to the build directory: #{$ cd vncBuild}#

Example to config the build directory to include gdm metacity
xtightvncviewer: #{$ lb config --packages "gdm3 metacity xtightvncviewer"}#

Create a folder /etc/skel folder for a custom .xsession for the default
user: #{$ mkdir -p config/chroot_local-includes/etc/skel}#

Create the .xsession for the default user: #{$ touch
config/chroot_local-includes/etc/skel/.xsession}#

Edit the .xsession file to launch metacity and start xvncviewer with
something similar to the below:

code{

#!/bin/sh

/usr/bin/metacity & /usr/bin/vncviewer xxx.xxx.xxx.xxx:PORT

exit

}code

_* Build the image: #{# lb build}#

_* Enjoy.

2~ A base image for a 128M USB key

*{Use case:}* Create a standard image with some components removed in order to fit on a 128M USB key with space left over to use as you see fit.

When optimizing an image to fit a certain media size, you need to understand
the tradeoffs you are making between size and functionality. In this
example, we trim only so much as to make room for additional material within
a 128M media size, but without doing anything to destroy integrity of the
packages contained within, such as the purging of locale data via the
#{localepurge}# package, or other such "intrusive" optimizations. Of
particular note, you should not use #{--bootstrap-flavour minimal}# unless
you really know what you're doing, as omitting priority #{important}#
packages will most likely produce a broken live system.

code{

$ lb config -k 486 -p minimal --binary-indices false --memtest none
--apt-recommends false --includes none

}code

Now, build the image in the usual way:

code{

# lb build 2>&1 | tee binary.log

}code

On the author's system at time of writing, the above configuration produced
a 78Mbyte image. This compares favourably with the 166Mbyte image produced
by the default configuration in {Tutorial 1}#tutorial-1.

The biggest space-saver here, compared to building a standard image on an
#{i386}# architecture system, is to select only the #{486}# kernel flavour
instead of the default #{-k "486 686"}#. Leaving off APT's indices with
#{--binary-indices false}# also saves a fair amount of space, the tradeoff
being that you need to #{apt-get update}# before using apt in the live
system. Choosing the #{minimal}# package list leaves out the large
#{locales}# package and associated utilities. Dropping recommended packages
with #{--apt-recommends false}# saves some additional space, at the expense
of omitting some packages you might otherwise expect to be there, such as
#{firmware-linux-free}# which may be needed to support certain hardware. The
remaining options shave off additional small amounts of space. It's up to
you to decide if the functionality that is sacrificed with each optimization
is worth the loss in functionality.

2~ A localized KDE desktop and installer

*{Use case:}* Create a KDE desktop image, localized for Brazilian Portuguese and including an installer.

We want to make an iso-hybrid image for i386 architecture using our
preferred desktop, in this case KDE, containing all of the same packages
that would be installed by the standard Debian installer for KDE.

Our initial problem is the discovery of the names of the appropriate
tasks. Currently, live-build cannot help with this. While we might get lucky
and find this by trial-and-error, there is a tool, #{grep-dctrl}#, which can
be used to dig it out of the task descriptions in tasksel-data, so to
prepare, make sure you have both of those things:

code{

# apt-get install dctrl-tools tasksel-data

}code

Now we can search for the appropriate tasks, first with:

code{

$ grep-dctrl -FTest-lang pt_BR /usr/share/tasksel/debian-tasks.desc -sTask,Description
Task: brazilian-portuguese
Description: Brazilian Portuguese environment
 This task installs programs, data files, and
 documentation that make it easier for Brazilian Portuguese speakers
 to use Debian.

}code

By this command, we discover the task is called, plainly enough,
brazilian-portuguese. Now to find the related tasks:

code{

$ grep-dctrl -FEnhances brazilian-portuguese /usr/share/tasksel/debian-tasks.desc -sTask,Description
Task: brazilian-portuguese-desktop
Description: Brazilian Portuguese desktop
 This task localises the desktop in Brasilian Portuguese.

Task: brazilian-portuguese-kde-desktop
Description: Brazilian Portuguese KDE desktop
 This task localises the KDE desktop in Brazilian Portuguese.

}code

We will use the experimental #{--language}# option, as live-build happens to
include #{syslinux}# templates for pt_BR (see {Desktop and language
tasks}#desktop-and-language-tasks for details). And at boot time we will
generate the pt_BR.UTF-8 locale and select the pt-latin1 keyboard
layout. Now let's put the pieces together:

code{

$ mkdir live-pt_BR-kde
$ cd live-pt_BR-kde
$ lb config \
     -a i386 \
     -k 486 \
     -p kde-desktop \
     --language pt_BR \
     --tasks "brazilian-portuguese brazilian-portuguese-desktop brazilian-portuguese-kde-desktop" \
     --bootappend-live "locales=pt_BR.UTF-8 keyboard-layouts=pt-latin1" \
     --debian-installer live \
     --packages debian-installer-launcher

}code

Note that we have included the #{debian-installer-launcher}# package to
launch the installer from the live desktop, and have also specified the 486
flavour kernel, as it is currently necessary to make the installer and live
system kernels match for the launcher to work properly.

