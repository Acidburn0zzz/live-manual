:B~ Esempi

1~examples Esempi

Questo capitolo affronta alcune costruzioni di esempio per specifici casi
d'uso con Debian Live. Se si è nuovi nella costruzione di immagini Debian
Live, raccomandiamo di dare innanzitutto un'occhiata ai tre tutorial in
sequenza, dato che ciascuno insegna nuove tecniche che aiuteranno nell'uso e
nella comprensione degli esempi rimanenti.

2~using-the-examples Usare gli esempi

Per usare questi esempi è necessario un sistema per costruirveli sopra che
soddisfi i requisiti elencati in {Requisiti}#requirements e avere live-build
installato come descritto in {Installare live-build}#installing-live-build.

Si noti che, per brevità, in questi esempi non specifichiamo un mirror
locale da usare per la costruzione. Usando un mirror locale, si possono
accelerare considerevolmente i download. Si possono specificare le opzioni
quando si usa #{lb config}#, come descritto in {Mirror delle distribuzioni
usati in fase di compilazione}#distribution-mirrors-build-time o, più
convenientemente, impostare il predefinito per il proprio sistema in
#{/etc/live/build.conf}#. Si crei semplicemente questo file e si impostino
in esso le corrispondenti variabili #{LB_MIRROR_*}# per il mirror
desiderato. Tutti gli altri mirror utilizzati nella costruzione avranno
questi valori, ad esempio:

code{

 LB_MIRROR_BOOTSTRAP="http://mirror/debian"
 LB_MIRROR_CHROOT_SECURITY="http://mirror/debian-security"
 LB_MIRROR_CHROOT_BACKPORTS="http://mirror/debian-updates"

}code

2~tutorial-1 Tutorial 1: un'immagine standard

*{Caso d'uso:}* creazione di una prima semplice immagine, imparando i fondamenti di live-build.

In questo tutorial genereremo un'immagine ISO ibrida di Debian Live
contenente solo pacchetti base (senza Xorg) e alcuni pacchetti Debian Live
di supporto, come primo esercizio sull'uso di live-build.

Non può essere più semplice:

code{

 $ mkdir tutorial1 ; cd tutorial1 ; lb config

}code

Esaminare i contenuti della directory #{config/}#; si noterà uno scheletro
di configurazione pronto per essere personalizzato o, in questo caso, usato
immediatamente per costruire un'immagine predefinita.

Ora, come utente root, si generi l'immagine salvando un log con #{tee}#.

code{

 # lb build 2>&1 | tee build.log

}code

Assuming all goes well, after a while, the current directory will contain
#{binary.hybrid.iso}#. This ISO hybrid image can be booted directly in a
virtual machine as described in {Testing an ISO image with
Qemu}#testing-iso-with-qemu and {Testing an ISO image with
virtualbox}#testing-iso-with-virtualbox, or else imaged onto optical media
or a USB flash device as described in {Burning an ISO image to a physical
medium}#burning-iso-image and {Copying an ISO hybrid image to a USB
stick}#copying-iso-hybrid-to-usb, respectively.

2~tutorial-2 Tutorial 2: servizio browser web

*{Caso d'uso:}* creazione di un'immagine per servizio browser web, imparando come applicare le personalizzazioni.

In questo tutorial verrà creata un'immagine adatta all'uso come browser web,
che serve come introduzione alla personalizzazione delle immagini Debian
Live.

code{

 $ mkdir tutorial2
 $ cd tutorial2
 $ echo "task-lxde-desktop iceweasel" >> config/package-lists/my.list.chroot

}code

La scelta di LXDE per questo esempio riflette il desiderio di fornire un
ambiente desktop minimale, dato che il punto focale dell'immagine è il
singolo uso che abbiamo in mente, il browser web. Potremmo anche spingerci
oltre e fornire una configurazione predefinita per il browser web in
#{config/includes.chroot/etc/iceweasel/profile/}#, o pacchetti addizionali
di supporto per la fruizione di vari tipi di contenuti web, ma lasciamo
questo come esercizio per il lettore.

Si generi l'immagine, ancora come utente root, conservando un log come in
{Tutorial 1}#tutorial-1:

code{

 # lb build 2>&1 | tee build.log

}code

Di nuovo, si verifichi che l'immagine sia a posto e la si collaudi, come in
{Tutorial 1}#tutorial-1.

2~tutorial-3 Tutorial 3: un'immagine personalizzata

*{Caso d'uso:}* creazione di un progetto per costruire un'immagine personalizzata che contiene i pacchetti preferiti da portare con sé in una chiavetta USB ovunque si vada, e che evolve in revisioni successive allorché i bisogni o le preferenze cambino.

Dal momento che la nostra immagine personalizzata cambierà con le successive
revisioni, e che vogliamo tener traccia di questi cambiamenti, andando per
tentativi ed eventualmente tornando indietro se qualcosa non funziona,
conserveremo la nostra configurazione nel popolare sistema di controllo di
versione #{git}#. Useremo anche le migliori pratiche di auto-configurazione
tramite gli script #{auto}# come descritto in {Gestire una
configurazione}#managing-a-configuration.

3~ Prima revisione

code{

 $ mkdir -p tutorial3/auto
 $ cp /usr/share/doc/live-build/examples/auto/* tutorial3/auto/
 $ cd tutorial3

}code

Modificare #{auto/config}# come segue:

code{

 #!/bin/sh

 lb config noauto \
     --architectures i386 \
     --linux-flavours 686-pae \
     "${@}"

}code

Perform #{lb config}# to generate the config tree, using the #{auto/config}#
script you just created:

code{

 $ lb config

}code

Popolare ora l'elenco locale dei pacchetti:

code{

 $ echo "task-lxde-desktop iceweasel xchat" >> config/package-lists/my.list.chroot

}code

First, #{--architectures i386}# ensures that on our #{amd64}# build system,
we build a 32-bit version suitable for use on most machines. Second, we use
#{--linux-flavours 686-pae}# because we don't anticipate using this image on
much older systems. Third, we have chosen the /{lxde}/ task metapackage to
give us a minimal desktop. And finally, we have added two initial favourite
packages: /{iceweasel}/ and /{xchat}/.

Costruire quindi l'immagine:

code{

 # lb build

}code

Si noti che diversamente dai primi due tutorial, non occorre più digitare
#{2>&1 | tee build.log}# dato che questo è ora incluso in #{auto/build}#.

Una volta che l'immagine è stata collaudata (come in {Tutorial
1}#tutorial-1) e che si è sicuri che funzioni correttamente, è il momento di
inizializzare il repository #{git}#, aggiungendo solo gli script auto appena
creati, e di fare poi il primo commit:

code{

 $ git init
 $ git add auto
 $ git commit -a -m "Initial import."

}code

3~ Seconda revisione

In questa revisione ripuliremo la prima compilazione, aggiungeremo il
pacchetto /{vlc}/ alla configurazione, dunque avverrà una ricompilazione,
verifica e commit.

Il comando #{lb clean}# ripulirà tutti i file ottenuti con la precedente
generazione eccetto la cache, che ci evita un nuovo download dei
pacchetti. Ciò assicura che il successivo #{lb build}# eseguirà di nuovo
tutti i passaggi per rigenerare i file dalla nuova configurazione.

code{

 # lb clean

}code

Ora inserire il pacchetto /{vlc}/ all'elenco locale dei pacchetti
#{config/package-lists/my.list.chroot}#:

code{

 $ echo vlc >> config/package-lists/my.list.chroot

}code

Rigenerare nuovamente:

code{

# lb build

}code

Verificare, e quando soddisfatti, eseguire il commit della revisione
successiva:

code{

 $ git commit -a -m "Adding vlc media player."

}code

Ovviamente sono possibili cambiamenti alla configurazione più complicati,
magari aggiungendo file in sottodirectory di #{config/}#. Quando si esegue
il commit di nuove revisioni, si faccia solo attenzione a non modificare
manualmente o fare un commit dei file al livello superiore di #{config}# che
contengono le variabili #{LB_*}#, giacché sono anche prodotti
dell'assemblaggio, e che sono sempre ripuliti da #{lb clean}# e ricreati con
#{lb config}# attraverso i loro rispettivi script #{auto}#.

Siamo arrivati alla fine di questa serie di tutorial. Mentre sono possibili
molti altri tipi di personalizzazioni, anche solo usando le poche
caratteristiche esplorate in questi semplici esempi, può essere creata una
varietà quasi infinita di immagini. Gli esempi rimanenti in questa sezione
coprono diversi altri casi d'uso estrapolati dalle esperienze raccolte degli
utenti Debian Live.

2~ Un client Kiosk VNC

*{Caso d'uso:}* creazione di un'immagine con live-build per avviare direttamente un server VNC.

Make a build directory and create an skeletal configuration inside it,
disabling recommends to make a minimal system. And then create two initial
package lists: the first one generated with a script provided by live-build
named #{Packages}# (see {Generated package lists}#generated-package-lists),
and the second one including /{xorg}/, /{gdm3}/, /{metacity}/ and
/{xvnc4viewer}/.

code{

 $ mkdir vnc_kiosk_client
 $ cd vnc_kiosk_client
 $ lb config -a i386 -k 686-pae --apt-recommends false
 $ echo '! Packages Priority standard' > config/package-lists/standard.list.chroot
 $ echo "xorg gdm3 metacity xvnc4viewer" > config/package-lists/my.list.chroot

}code

As explained in {Tweaking APT to save space}#tweaking-apt-to-save-space you
may need to re-add some recommended packages to make your image work
properly.

An easy way to list recommends is using /{apt-cache}/. For example:

code{

 $ apt-cache depends live-config live-boot

}code

In this example we found out that we had to re-include several packages
recommended by live-config and live-boot: #{user-setup}# to make autologin
work and #{sudo}# as an essential program to shutdown the system. Besides,
it could be handy to add #{live-tools}# to be able to copy the image to RAM
and #{eject}# to eventually eject the live media. So:

code{

 $ echo "live-tools user-setup sudo eject" > config/package-lists/recommends.list.chroot

}code

After that, create the directory #{/etc/skel}# in #{config/includes.chroot}#
and put a custom #{.xsession}# in it for the default user that will launch
/{metacity}/ and start /{xvncviewer}/, connecting to port #{5901}# on a
server at #{192.168.1.2}#:

code{

 $ mkdir -p config/includes.chroot/etc/skel
 $ cat > config/includes.chroot/etc/skel/.xsession << END
 #!/bin/sh

 /usr/bin/metacity &
 /usr/bin/xvncviewer 192.168.1.2:1

 exit
 END

}code

Costruire l'immagine:

code{

 # lb build

}code

Buon divertimento.

2~ Un'immagine base per una chiavetta USB da 128M

*{Use case:}* Create a standard image with some components removed in order to fit on a 128M USB key with a little space left over to use as you see fit.

When optimizing an image to fit a certain media size, you need to understand
the tradeoffs you are making between size and functionality. In this
example, we trim only so much as to make room for additional material within
a 128M media size, but without doing anything to destroy the integrity of
the packages contained within, such as the purging of locale data via the
/{localepurge}/ package, or other such "intrusive" optimizations. Of
particular note, in order to understand what the #{minimal.chroot}# hook
does you should take a look at #{/usr/share/doc/live-build/examples/hooks}#

code{

 $ lb config -k 486 --apt-indices false --apt-recommends false --memtest none
 $ cp /usr/share/doc/live-build/examples/hooks/minimal.chroot config/hooks

}code

To make the image work properly, we must re-add, at least, two recommended
packages which are left out by the #{--apt-recommends false}# option. See
{Tweaking APT to save space}#tweaking-apt-to-save-space

code{

 $ echo "user-setup sudo" > config/package-lists/recommends.list.chroot

}code

Costruire quindi l'immagine nel modo consueto:

code{

 # lb build 2>&1 | tee build.log

}code

On the author's system at the time of writing this, the above configuration
produced a 95Mbyte image. This compares favourably with the 182Mbyte image
produced by the default configuration in {Tutorial 1}#tutorial-1.

The biggest space-saver here, compared to building a standard image on an
#{i386}# architecture system, is to select only the #{486}# kernel flavour
instead of the default #{-k "486 686-pae"}#. Leaving off APT's indices with
#{--apt-indices false}# also saves a fair amount of space, the tradeoff
being that you need to #{apt-get update}# before using apt in the live
system. Dropping recommended packages with #{--apt-recommends false}# saves
some additional space, at the expense of omitting some packages you might
otherwise expect to be there. #{--memtest none}# prevents the installation
of a memory tester. And finally, the execution of the #{minimal.chroot}#
hook removes some unused packages and files.

Using other hooks, like for example the #{stripped.chroot}# hook found in
#{/usr/share/doc/live-build/examples/hooks}#, may shave off additional small
amounts of space and produce an image of 76MB. But it is up to you to decide
if the functionality that is sacrificed with each size optimization is worth
the loss of functionality.

2~ Un desktop KDE localizzato e l'installer

*{Caso d'uso:}* creazione di un'immagine con il desktop KDE, localizzato per il portoghese brasiliano e che includa l'installatore.

Si vuole creare un'immagine iso ibrida per architettura i386 usando il
nostro desktop preferito, in questo caso KDE, contenente tutti gli stessi
pacchetti che verrebbero installati dall'installatore Debian standard per
KDE.

Il problema iniziale è di scoprire i nomi dei task della lingua appropriati,
attualmente, live-build non aiuta in questo. Si può essere fortunati o
arrivarci con vari tentativi, ma c'è uno strumento #{grep-dctrl}# il quale
può essere utilizzato per scavare nelle descrizioni in tasksel-data, perciò
assicursi di avere entrambi questi pacchetti:

code{

 # apt-get install dctrl-tools tasksel-data

}code

Ora si possono cercare i task appropriati:

code{

 $ grep-dctrl -FTest-lang pt_BR /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: brazilian-portuguese

}code

Con questo comando, si è scoperto che il task si chiama, abbastanza
chiaramente, brazilian-portuguese. Ora per trovare i task correlati:

code{

 $ grep-dctrl -FEnhances brazilian-portuguese /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: brazilian-portuguese-desktop
 Task: brazilian-portuguese-kde-desktop

}code

At boot time we will generate the *{pt_BR.UTF-8}* locale and select the
*{pt}* keyboard layout. Now let's put the pieces together. Recalling from
{Using metapackages}#using-metapackages that task metapackages are prefixed
#{task-}#, we just specify these language boot parameters, then add standard
priority packages and all our discovered task metapackages to our package
list as follows:

code{

 $ mkdir live-pt_BR-kde
 $ cd live-pt_BR-kde
 $ lb config \
     -a i386 \
     -k 486 \
     --bootappend-live "locales=pt_BR.UTF-8 keyboard-layouts=pt" \
     --debian-installer live
 $ echo '! Packages Priority standard' > config/package-lists/standard.list.chroot
 $ echo task-kde-desktop task-brazilian-portuguese task-brazilian-portuguese-desktop \
     task-brazilian-portuguese-kde-desktop >> config/package-lists/desktop.list.chroot
 $ echo debian-installer-launcher >> config/package-lists/installer.list.chroot

}code

Si noti che è stato incluso il pacchetto debian-installer-launcher in modo
da poter lanciare l'installer dal desktop della live, e che è stato anche
specificato il kernel 486, dato che attualmente è necessario che il kernel
dell'installer e quello del sistema live coincidano affinché il launcher
funzioni correttamente.
