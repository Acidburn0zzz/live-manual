:B~ Esempi

1~examples Esempi

Questo capitolo affronta alcune costruzioni di esempio per specifici casi
d'uso con Debian Live. Se si è nuovi nella costruzione di immagini Debian
Live, raccomandiamo di dare innanzitutto un'occhiata ai tre tutorial in
sequenza, dato che ciascuno insegna nuove tecniche che aiuteranno nell'uso e
nella comprensione degli esempi rimanenti.

2~using-the-examples Usare gli esempi

Per usare questi esempi è necessario un sistema per costruirveli sopra che
soddisfi i requisiti elencati in {Requirements}#requirements e avere
live-build installato come descritto in {Installing
live-build}#installing-live-build.

Si noti che, for the sake of brevity, in questi esempi non specifichiamo un
mirror locale da usare per la costruzione. Si può accelerare i download
considerevolmente se si usa un mirror locale. Si possono specificare le
opzioni quando si usa #{lb config}#, come descritto in {Distribution mirrors
used at build time}#distribution-mirrors-build-time, o più convenientemente
impostare il default per il proprio sistema di generazione in
#{/etc/live/build.conf}#. Semplicemente si crei questo file ed in esso si
impostino le corrispondenti variabili #{LB_MIRROR_*}# per il proprio mirror
preferito. Ad esempio:

code{

LB_MIRROR_BOOTSTRAP="http://mirror/debian"
LB_MIRROR_CHROOT="http://mirror/debian"
LB_MIRROR_CHROOT_SECURITY="http://mirror/debian-security"

}code

2~tutorial-1 Tutorial 1: Un'immagine standard

*{Use case:}* Creazione di una semplice prima immagine, imparando le basi di live-build.

In questo tutorial genereremo un'immagine ISO ibrida Debian Live di default
contenente solo pacchetti di base (niente Xorg) e alcuni pacchetti Debian
Live di supporto, come primo esercizio sull'uso di live-build.

Non si può fare in modo molto più semplice di così:

code{

$ mkdir tutorial1 ; cd tutorial1 ; lb config

}code

Si esaminino i contenuti della directory #{config/}# se si desidera. Si
vedrà qui immagazzinato uno scheletro di configurazione, pronto per essere
personalizzato o, in questo caso, usato immediatamente per costruire
un'immagine di default.

Ora, come super-utente, si generi l'immagine, salvando un log con #{tee}#.

code{

# lb build 2>&1 | tee binary.log

}code

Assumendo che tutto vada per il verso giusto, dopo un po' la directory
corrente conterrà #{binary-hybrid.iso}#. Questa immagine ISO ibrida può
essere avviata direttamente in una macchina virtuale come descritto in
{Testing an ISO image with Qemu}#testing-iso-with-qemu e{Testing an ISO
image with virtualbox-ose}#testing-iso-with-virtualbox, oppure masterizzata
su un supporto ottico o ancora su una chiavetta USB come descritto
rispettivamente in {Burning an ISO image to a physical
medium}#burning-iso-image e {Copying USB/HDD image to a USB
stick}#copying-usb-hdd-image.

2~tutorial-2 Tutorial 2: Servizio browser web

*{Use case:}* Creazione di un'immagine per servizio browser web, che insegna come applicare personalizzazioni.

In questo tutorial creeremo un'immagine adatta all'uso come servizio browser
web, che ci serve come introduzione alla personalizzazione delle immagini
Debian Live.

code{

mkdir tutorial2 ; cd tutorial2 ; lb config -p lxde --packages iceweasel

}code

La scelta di LXDE per questo esempio riflette il nostro desiderio di fornire
un ambiente desktop minimale, dato che il punto focale dell'immagine è il
singolo uso che abbiamo in mente, il browser web. Potremmo anche spingerci
oltre e fornire una configurazione di default per il browser web in
#{config/chroot_local-includes/etc/iceweasel/profile/}#, o pacchetti
addizionali di supporto per la fruizione di vari tipi di contenuti web, ma
lasciamo questo come esercizio per il lettore.

Si generi l'immagine, ancora come super-utente, conservando un log come in
{Tutorial 1}#tutorial-1:

code{

# lb build 2>&1 | tee binary.log

}code

Di nuovo, si verifichi che l'immagine sia a posto e la si collaudi, come in
{Tutorial 1}#tutorial-1.

2~tutorial-3 Tutorial 3: A personalized image

*{Use case:}* Create a project to build a personalized image, containing your favourite software to take with you on a USB stick wherever you go, and evolving in successive revisions as your needs and preferences change.

Since we will be changing our personalized image over a number of revisions,
and we want to track those changes, trying things experimentally and
possibly reverting them if things don't work out, we will keep our
configuration in the popular #{git}# version control system. We will also
use the best practice of autoconfiguration via #{auto}# scripts as described
in {Managing a configuration}#managing-a-configuration.

3~ First revision

code{

$ mkdir -p tutorial3/auto $ cp /usr/share/live/examples/auto/*
tutorial3/auto/ $ cd tutorial3

}code

Edit #{auto/config}# to read as follows:

code{

#!/bin/sh

lb config noauto \
    --architecture i386 \
    --linux-flavours 686 \
    --packages-lists lxde \
    --packages "iceweasel xchat" \
    "${@}"

}code

First, #{--architecture i386}# ensures that on our #{amd64}# build system,
we build a 32-bit version suitable for use on most machines. Second, we use
#{--linux-flavours 686}# because we don't anticipate using this image on
much older systems. Third, we've chosen the #{lxde}# package list to give us
a minimal desktop. And finally, we have added two initial favourite
packages: #{iceweasel}# and #{xchat}#.

Now, build the image:

code{

# lb build

}code

Note that unlike in the first two tutorials, we no longer have to type
#{2>&1 | tee binary.log}# as that is now included in #{auto/build}#.

Once you've tested the image (as in {Tutorial 1}#tutorial-1) and are
satisfied it works, it's time to initialize our #{git}# repository, adding
only the auto scripts we just created, and then make the first commit:

code{

$ git init $ git add auto $ git commit -a -m "Initial import."

}code

3~ Second revision

In this revision, we're going to clean up from the first build, add the
#{vlc}# package to our configuration, rebuild, test and commit.

The #{lb clean}# command will clean up all generated files from the previous
build except for the cache, which saves having to re-download packages. This
ensures that the subsequent #{lb build}# will re-run all stages to
regenerate the files from our new configuration.

code{

# lb clean

}code

Now edit #{auto/config}# to add the #{vlc}# package:

code{

#!/bin/sh

lb config noauto \
    --architecture i386 \
    --linux-flavours 686 \
    --packages-lists lxde \
    --packages "iceweasel xchat vlc" \
    "${@}"

}code

Build again:

code{

# lb build

}code

Test, and when you're satisfied, commit the next revision:

code{

$ git commit -a -m "Adding vlc media player."

}code

Of course, more complicated changes to the configuration are possible,
perhaps adding files in subdirectories of #{config/}#. When you commit new
revisions, just take care not to hand edit or commit the top-level files in
#{config}# containing #{LB_*}# variables, as these are build products, too,
and are always cleaned up by #{lb clean}# and re-created with #{lb config}#
via their respective #{auto}# scripts.

We've come to the end of our tutorial series. While many more kinds of
customization are possible, even just using the few features explored in
these simple examples, an almost infinite variety of different images can be
created. The remaining examples in this section cover several other use
cases drawn from the collected experiences of users of Debian Live.

2~ A VNC Kiosk Client

*{Use case:}* Create an image with live-build to boot directly to a VNC server.

_* Make a build directory: #{$ mkdir vncBuild}#

_* Move to the build directory: #{$ cd vncBuild}#

Example to config the build directory to include gdm metacity
xtightvncviewer: #{$ lb config --packages "gdm3 metacity xtightvncviewer"}#

Create a folder /etc/skel folder for a custom .xsession for the default
user: #{$ mkdir -p config/chroot_local-includes/etc/skel}#

Create the .xsession for the default user: #{$ touch
config/chroot_local-includes/etc/skel/.xsession}#

Edit the .xsession file to launch metacity and start xvncviewer with
something similar to the below:

code{

#!/bin/sh

/usr/bin/metacity & /usr/bin/vncviewer xxx.xxx.xxx.xxx:PORT

exit

}code

_* Build the image: #{# lb build}#

_* Enjoy.

2~ A base image for a 128M USB key

*{Use case:}* Create a standard image with some components removed in order to fit on a 128M USB key with space left over to use as you see fit.

When optimizing an image to fit a certain media size, you need to understand
the tradeoffs you are making between size and functionality. In this
example, we trim only so much as to make room for additional material within
a 128M media size, but without doing anything to destroy integrity of the
packages contained within, such as the purging of locale data via the
#{localepurge}# package, or other such "intrusive" optimizations. Of
particular note, you should not use #{--bootstrap-flavour minimal}# unless
you really know what you're doing, as omitting priority #{important}#
packages will most likely produce a broken live system.

code{

$ lb config -k 486 -p minimal --binary-indices false --memtest none
--apt-recommends false --includes none

}code

Now, build the image in the usual way:

code{

# lb build 2>&1 | tee binary.log

}code

On the author's system at time of writing, the above configuration produced
a 78Mbyte image. This compares favourably with the 166Mbyte image produced
by the default configuration in {Tutorial 1}#tutorial-1.

The biggest space-saver here, compared to building a standard image on an
#{i386}# architecture system, is to select only the #{486}# kernel flavour
instead of the default #{-k "486 686"}#. Leaving off APT's indices with
#{--binary-indices false}# also saves a fair amount of space, the tradeoff
being that you need to #{apt-get update}# before using apt in the live
system. Choosing the #{minimal}# package list leaves out the large
#{locales}# package and associated utilities. Dropping recommended packages
with #{--apt-recommends false}# saves some additional space, at the expense
of omitting some packages you might otherwise expect to be there, such as
#{firmware-linux-free}# which may be needed to support certain hardware. The
remaining options shave off additional small amounts of space. It's up to
you to decide if the functionality that is sacrificed with each optimization
is worth the loss in functionality.

2~ A localized KDE desktop and installer

*{Use case:}* Create a KDE desktop image, localized for Brazilian Portuguese and including an installer.

We want to make an iso-hybrid image for i386 architecture using our
preferred desktop, in this case KDE, containing all of the same packages
that would be installed by the standard Debian installer for KDE.

Our initial problem is the discovery of the names of the appropriate
tasks. Currently, live-build cannot help with this. While we might get lucky
and find this by trial-and-error, there is a tool, #{grep-dctrl}#, which can
be used to dig it out of the task descriptions in tasksel-data, so to
prepare, make sure you have both of those things:

code{

# apt-get install dctrl-tools tasksel-data

}code

Now we can search for the appropriate tasks, first with:

code{

$ grep-dctrl -FTest-lang pt_BR /usr/share/tasksel/debian-tasks.desc -sTask,Description
Task: brazilian-portuguese
Description: Brazilian Portuguese environment
 This task installs programs, data files, and
 documentation that make it easier for Brazilian Portuguese speakers
 to use Debian.

}code

By this command, we discover the task is called, plainly enough,
brazilian-portuguese. Now to find the related tasks:

code{

$ grep-dctrl -FEnhances brazilian-portuguese /usr/share/tasksel/debian-tasks.desc -sTask,Description
Task: brazilian-portuguese-desktop
Description: Brazilian Portuguese desktop
 This task localises the desktop in Brasilian Portuguese.

Task: brazilian-portuguese-kde-desktop
Description: Brazilian Portuguese KDE desktop
 This task localises the KDE desktop in Brazilian Portuguese.

}code

We will use the experimental #{--language}# option, as live-build happens to
include #{syslinux}# templates for pt_BR (see {Desktop and language
tasks}#desktop-and-language-tasks for details). And at boot time we will
generate the pt_BR.UTF-8 locale and select the pt-latin1 keyboard
layout. Now let's put the pieces together:

code{

$ mkdir live-pt_BR-kde
$ cd live-pt_BR-kde
$ lb config \
     -a i386 \
     -k 486 \
     -p kde-desktop \
     --language pt_BR \
     --tasks "brazilian-portuguese brazilian-portuguese-desktop brazilian-portuguese-kde-desktop" \
     --bootappend-live "locales=pt_BR.UTF-8 keyboard-layouts=pt-latin1" \
     --debian-installer live \
     --packages debian-installer-launcher

}code

Note that we have included the #{debian-installer-launcher}# package to
launch the installer from the live desktop, and have also specified the 486
flavour kernel, as it is currently necessary to make the installer and live
system kernels match for the launcher to work properly.

