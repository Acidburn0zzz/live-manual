:B~ Personalizzare l'installazione dei pacchetti

1~customizing-package-installation Personalizzare l'installazione dei
pacchetti

Perhaps the most basic customization of a Debian live system is the
selection of packages to be included in the image. This chapter guides you
through the various build-time options to customize live-build's
installation of packages. The broadest choices influencing which packages
are available to install in the image are the distribution and archive
areas. To ensure decent download speeds, you should choose a nearby
distribution mirror. You can also add your own repositories for backports,
experimental or custom packages, or include packages directly as files. You
can define lists of packages, including metapackages which will install many
related packages at once, such as packages for a particular desktop or
language. Finally, a number of options give some control over /{apt}/, or if
you prefer, /{aptitude}/, at build time when packages are installed. You may
find these handy if you use a proxy, want to disable installation of
recommended packages to save space, or need to control which versions of
packages are installed via APT pinning, to name a few possibilities.

2~ Sorgenti dei pacchetti

3~ Distribuzione, le aree di archivio e le modalità

La distribuzione che viene scelta ha un ampio impatto su quali pacchetti
siano disponibili per essere inclusi nell'immagine live. Specificare il nome
in codice, il predefinito per la versione wheezy di live-build è wheezy;
qualsiasi attuale distribuzione mantenuta negli archivi Debian può essere
qui specificata con il suo nome in codice. (Per ulteriori dettagli
consultare il {Glossario}#terms). L'opzione #{--distribution}# non solo
influenza la sorgente dei pacchetti nell'archivio, ma indica a live-build di
comportarsi secondo la necessità per compilare ciascuna distribuzione
supportata. Ad esempio se si vuole costruire un rilascio *{unstable}*, sid,
specificare:

code{

 $ lb config --distribution sid

}code

All'interno dell'archivio dei pacchetti, le aree sono le principali
divisioni dello stesso. In Debian queste sono #{main}#, #{contrib}# e
#{non-free}#; soltanto #{main}# contiene il software che è parte di Debian,
perciò questa è la predefinita. Possono essere specificati uno o più valori:

code{

 $ lb config --archive-areas "main contrib"

}code

Attraverso l'opzione #{--mode}# è disponibile un supporto sperimentale per
alcune derivate di Debian; per impostazione predefinita, questa opzione è
impostata su #{debian}#, anche se si sta costruendo un sistema diverso da
Debian. Se si specifica #{--mode ubuntu}# o #{--mode emdebian}#, saranno
gestiti i nomi della distribuzione e le aree di archivio per la derivata
specificata e non quelli di Debian. La modalità cambia anche il
comportamento di live-build per adattarlo alle derivate.

*{Nota:}* i progetti per i quali sono state aggiunte tali modalità sono i principali responsabili nel supportare gli utenti di queste opzioni. Il progetto Debian Live, a sua volta, fornisce sostegno allo sviluppo solamente sulla base dell'impegno migliore, sui feedback dei progetti derivati così come non sviluppiamo o sosteniamo queste derivate.

3~ Mirror delle distribuzioni

L'archivio Debian è replicato attraverso una vasta rete di mirror in tutto
il mondo cosicché chiunque in ogni nazione può selezionare il mirror più
vicino per la migliore velocità di scaricamento. Ciascuna delle opzioni
#{--mirror-*}# determina quale mirror della distribuzione è usato nei vari
stadi della compilazione. Ricordando dalle {Fasi della
creazione}#stages-of-the-build che la fase di *{avvio}* è quando il chroot è
inizialmente popolato da /{debootstrap}/ con un sistema minimale e quella di
*{chroot}* è quando viene creato il chroot usato per costruire il file
system del sistema live. Perciò per queste fasi vengono usati i
corrispondenti cambi di mirror, e in seguito, nella fase *{binaria}* vengono
usati i valori di #{--mirror-binary}# e #{--mirror-binary-security}#
sostituendo qualsiasi altro mirror usato nelle fasi iniziali.

3~distribution-mirrors-build-time Mirror delle distribuzioni usati in fase
di compilazione

Per impostare i mirror delle distribuzioni usati in fase di compilazione ad
uno locale, è sufficiente impostare #{--mirror-bootstrap}#,
#{--mirror-chroot-security}# e #{--mirror-chroot-backports}# come segue.

code{

 $ lb config --mirror-bootstrap http://localhost/debian/ \
             --mirror-chroot-security http://localhost/debian-security/ \
	     --mirror-chroot-backports http://localhost/debian-backports/

}code

Il mirror chroot, specificato da #{--mirror-chroot}#, è impostato al valore
di #{--mirror-bootstrap}#.

3~ Mirror delle distribuzioni usate durante l'esecuzione

Le opzioni #{--mirror-binary*}# determinano i mirror delle distribuzioni
inseriti nell'immagine binaria. Questi possono essere usati per installare
pacchetti aggiuntivi mentre il sistema live è in funzione. Le impostazioni
predefinite impiegano #{cdn.debian.net}#, un servizio che sceglie un mirror
geograficamente vicino basandosi sul numero IP dell'utente. Questo è una
scelta conveniente quando non si può pronosticare quale sarà il mirror
migliore per tutti gli utenti. Oppure si può specificare il proprio valore
come mostrato nell'esempio qui sotto. Un'immagine compilata con questa
configurazione sarebbe adatta solamente ad utenti di una rete dove sia
raggiungibile il "#{mirror}#".

code{

 $ lb config --mirror-binary http://mirror/debian/ \
             --mirror-binary-security http://mirror/debian-security/

}code

3~additional-repositories Repository addizionali

Si possono aggiungere altri repository, ampliando così la scelta dei
pacchetti al di là di quelli disponibili nella distribuzione di
destinazione. Questi possono essere, per esempio, pacchetti di backport,
sperimentali o personalizzati. Per configurare repository aggiuntivi, creare
i file #{config/archives/vostro-repository.list.chroot}#, o
#{config/archives/vostro-repository.list.binary}#. Come per le opzioni
#{--mirror-*}#, queste controlleranno i repository usati nella fase
*{chroot}* quando si compila l'immagine, e nella fase *{binary}*, ad esempio
per usarli quando il sistema live è avviato.

Per esempio, #{config/archives/live.list.chroot}# permette di installare
pacchetti dal repository snapshot di debian live al momento della creazione
del sistema live.

code{

 deb http://live.debian.net/ sid-snapshots main contrib non-free

}code

Se si aggiunge la stessa riga in #{config/archives/live.list.binary}#, il
repository verrà aggiunto alla directory #{/etc/apt/sources.list.d/}# del
sistema live.

Se il file esiste, saranno prelevati automaticamente.

Bisogna inoltre inserire la chiave GPG usata per firmare il repository nei
file #{config/archives/vostro-repository.key.{binary,chroot}}#.

*{Nota:}* alcuni repository di pacchetti preconfigurati sono disponibili per una facile selezione attraverso l'opzione #{--archives}#, per abilitare gli snapshot live è sufficiente un semplice comando:

code{

 $ lb config --archives live.debian.net

}code

2~choosing-packages-to-install Scegliere i pacchetti da installare

There are a number of ways to choose which packages live-build will install
in your image, covering a variety of different needs. You can simply name
individual packages to install in a package list. You can also use
metapackages in those lists, or select them using package control file
fields. And finally, you may place package files in your #{config/}# tree,
which is well suited to testing of new or experimental packages before they
are available from a repository.

3~package-lists Elenchi di pacchetti

Package lists are a powerful way of expressing which packages should be
installed. The list syntax supports included files and conditional sections
which makes it easy to build lists from other lists and adapt them for use
in multiple configurations. Package names may also be injected into the list
using shell helpers at build time.

*{Nota:}* quando si specifica un pacchetto che non esiste, il comportamento di live-build è determinato dalla scelta delle utilità di APT. Per ulteriori dettagli si veda {Scegliere apt o aptitude}#choosing-apt-or-aptitude.

3~using-metapackages Using metapackages

The simplest way to populate your package list is to use a task metapackage
maintained by your distribution. For example:

code{

 $ lb config
 $ echo task-gnome-desktop > config/package-lists/gnome-desktop.list.chroot

}code

This supercedes the older predefined list method supported in #{live-build}#
2.x. Unlike predefined lists, task metapackages are not specific to the
Debian Live project. Instead, they are maintained by specialist working
groups within the distribution and therefore reflect the consensus of each
group about which packages best serve the needs of the intended users. They
also cover a much broader range of use cases than the predefined lists they
replace.

All task metapackages are prefixed #{task-}#, so a quick way to determine
which are available (though it may contain a handful of false hits that
match the name but aren't metapackages) is to match on the package name
with:

code{

 $ apt-cache search --names-only ^task-

}code

In addition to these, you will find other metapackages with various
purposes. Some are subsets of broader task packages, like #{gnome-core}#,
while others are individual specialized parts of a Debian Pure Blend, such
as the #{education-*}# metapackages. To list all metapackages in the
archive, install the #{debtags}# package and list all packages with the
#{role::metapackage}# tag as follows:

code{

 $ debtags search role::metapackage

}code

3~ Elenchi locali dei pacchetti

Whether you list metapackages, individual packages, or a combination of
both, all local package lists are stored in #{config/package-lists/}#. Since
more than one list can be used, this lends itself well to modular
designs. For example, you may decide to devote one list to a particular
choice of desktop, another to a collection of related packages that might as
easily be used on top of a different desktop. This allows you to experiment
with different combinations of sets of packages with a minimum of fuss,
sharing common lists between different live image projects.

Per essere processati, gli elenchi dei pacchetti che si trovano in questa
directory devono avere un suffisso #{.list}# e un suffisso #{.chroot}# o
#{.binary}# aggiuntivo per indicare per quale fase sia l'elenco.

*{Nota:}* se non si specifica il suffisso l'elenco sarà usato per entrambe le fasi. Normalmente è preferibile specificare #{.list.chroot}# in modo che i pacchetti vengono installati solo nel filesystem live evitando di avere una copia extra del #{.deb}# sul dispositivo.

3~ Elenchi locali di pacchetti binari

Per creare un elenco di binari inserire un file con suffisso
#{.list.binary}# in #{config/package-lists/}#; questi pacchetti non sono
installati nel filesystem ma inclusi sul dispositivo live sotto
#{pool/}#. Solitamente questo elenco si usa con una delle varianti non-live
dell'installatore; come detto sopra, se si vuole che questo sia identico
all'elenco della fase chroot, usare semplicemente il suffisso #{.list}#.

3~generated-package-lists Generated package lists

It sometimes happens that the best way to compose a list is to generate it
with a script. Any line starting with an exclamation point indicates a
command to be executed within the chroot when the image is built. For
example, one might include the line #{! grep-aptavail -n -sPackage
-FPriority standard | sort}# in a package list to produce a sorted list of
available packages with #{Priority: standard}#.

In fact, selecting packages with the #{grep-aptavail}# command (from the
#{dctrl-tools}# package) is so useful that #{live-build}# provides a
#{Packages}# helper script as a convenience. This script takes two
arguments: #{field}# and #{pattern}#. Thus, you can create a list with the
following contents:

code{

 $ lb config
 $ echo '! Packages Priority standard' > config/package-lists/standard.list.chroot

}code

3~ Usare condizioni all'interno degli elenchi di pacchetti

Ognuna delle variabili di configurazione di live-build situate in
#{config/*}# (senza il prefisso #{LB_}#) possono essere utilizzate per
istruzioni condizionali nell'elenco dei pacchetti. In genere questo
significa qualsiasi opzione di #{lb config}# in maiuscolo e con trattini
cambiati in trattini bassi; ma in pratica è la sola ad influenzare la
selezione dei pacchetti che abbia senso, come #{DISTRIBUTION}#,
#{ARCHITECTURES}# o #{ARCHIVE_AREAS}#.

Per esempio, per installare #{ia32-libs}# se è specificata #{--architectures
amd64}#:

code{

 #if ARCHITECTURES amd64
 ia32-libs
 #endif

}code

Si può verificare per ognuna di una serie di valori, ad esempio per
installare /{memtest86+}/ specificando sia #{--architectures i386}# sia
#{--architectures amd64}#:

code{

 #if ARCHITECTURES i386 amd64
 memtest86+
 #endif

}code

È possibile provare altre variabili che contengano più di un valore, ad
esempio per installare /{vrms}/ specificando sia da #{contrib}# sia da
#{non-free}# tramite #{--archive-areas}#:

code{

 #if ARCHIVE_AREAS contrib non-free
 vrms
 #endif

}code

Una condizione può coinvolegere una direttiva #{#include}#:

code{

 #if ARCHITECTURES amd64
 #include <gnome-full>
 #endif

}code

Le condizioni nidificate non sono supportate.

3~desktop-and-language-tasks Task per desktop e lingua

I task per i desktop e la lingua sono un caso particolare che necessita di
ulteriori pianificazioni e configurazioni e in questo senso le immagini live
sono diverse da quelle dell'Installatore Debian. Nell'Installatore Debian,
se il supporto è stato preparato per un particolare ambiente desktop, il
corrispondente task verrà automaticamente installato. Perciò ci sono task
#{gnome-desktop}#, #{kde-desktop}#, #{lxde-desktop}# e #{xfce-desktop}#
interni, nessuno dei quali è offerto nel menu di #{tasksel}#. Allo stesso
modo, non c'è nessuna voce nel menu per i task delle lingue, ma la scelta
della lingua dell'utente durante l'installazione influenza la selezione dei
corrispondenti task della lingua.

Sviluppando un'immagine live per desktop, questa si avvia direttamente su
un'area di lavoro, le scelte del desktop e della lingua predefinita sono
state fatte al momento della compilazione e non al volo come nel caso
dell'installatore Debian. Questo non per dire che un'immagine live non possa
essere creata con un supporto per desktop o lingue multipli per offrire
all'utente una scelta, ma che non è il comportamento predefinito nella
creazione di una live.

Because there is no provision made automatically for language tasks, which
include such things as language-specific fonts and input-method packages, if
you want them, you need to specify them in your configuration. For example,
a GNOME desktop image containing support for Japanese might include these
task metapackages:

code{

 $ lb config
 $ echo "task-gnome-desktop task-laptop" >> config/package-lists/my.list.chroot
 $ echo "task-japanese task-japanese-desktop task-japanese-gnome-desktop" >> config/package-lists/my.list.chroot

}code

2~installing-modified-or-third-party-packages Installare pacchetti
modificati o di terze parti

Nonostante sia contro la filosofia di Debian Live, a volte può essere
necessario creare un sistema live con versioni modificate dei pacchetti nel
repository Debian. Questo per modificare o gestire funzionalità aggiuntive,
lingue e marchi, o anche rimuovere elementi non desiderati da pacchetti
esistenti. Allo stesso modo, i pacchetti di "terze parti" possono essere
utilizzati per aggiungere funzionalità proprietarie o su misura.

Questa sezione non tratta la compilazione e il mantenimento di pacchetti
modificati. Può comunque essere interessante leggere "How to fork privately"
di Joachim Breitner:
http://www.joachim-breitner.de/blog/archives/282-How-to-fork-privately.html
La creazione di pacchetti su misura è esposta nella "Guida per il nuovo
Maintainer" all'indirizzo http://www.debian.org/doc/maint-guide/ e altrove.

Ci sono due modi per installare pacchetti personalizzati:

_* #{packages.chroot}#

_* Utilizzare repository APT personalizzati

Usando #{packages.chroot}# è più semplice da ottenere e utile per una
personalizzazione "una tantum" ma ha una serie di svantaggi, mentre un
repository APT personalizzato è più laborioso da configurare.

3~ Utilizzare #{packages.chroot}# per installare pacchetti personalizzati

Per installare un pacchetto personalizzato copiarlo nella directory
#{config/packages.chroot/}#; i pacchetti al suo interno verranno installati
automaticamente durante la creazione del sistema live, non è necessario
specificarli altrove.

I pacchetti *{devono}* essere nominati nel modo prescritto, un metodo
semplice per farlo è usare #{dpkg-name}#.

L'utilizzo di #{packages.chroot}# per l'installazione di pacchetti
personalizzati presenta degli svantaggi:

_* non è possibile usare secure APT

_* è necessario installare i pacchetti adeguati nella directory
#{config/packages.chroot/}#.

_* non si presta a salvare le configurazioni di Debian Live nel controllo di
versione.

3~ Utilizzare un repository APT per installare pacchetti personalizzati

A differenza di #{packages.chroot}#, quando si usa un repository APT
personalizzato è necessario assicurarsi di specificare altrove i
pacchetti. Per i dettagli si veda {Scegliere i pacchetti da
installare}#choosing-packages-to-install.

Sebbene creare un repository APT possa sembrare uno sforzo inutile,
l'infrastruttura può facilmente essere riutilizzata in un secondo momento
per offrire aggiornamenti dei pacchetti modificati.

3~ Pacchetti personalizzati e APT

live-build utilizza APT per installare tutti i pacchetti nel sistema live in
modo da ereditare i comportamenti di questo programma. Un esempio rilevante
è che (considerando una configurazione predefinita) dato un pacchetto
disponibile in due repository differenti con numeri di versione diversi, APT
sceglie di installare quello con il numero di versione più alto.

A causa di questo si può voler incrementare il numero della versione nei
file #{debian/changelog}# dei pacchetti personalizzati per accertare che la
propria versione avrà la precedenza sui repository Debian ufficiali. È anche
ottenibile modificando le preferenze del APT pinning del sistema live, si
veda {APT pinning}#apt-pinning per maggiori informazioni.

2~ Configurare APT in fase di costruzione

APT è configurabile tramite una serie di opzioni applicate solo in fase di
costruzione (la configurazione di APT utilizzata nel sistema live in
esecuzione può essere configurata nel solito modo, ovvero includendo le
impostazioni appropriate attraverso #{config/includes.chroot/}#). Per un
elenco completo, cercare nel manuale di #{lb_config}# le opzioni che
iniziano con #{apt}#.

3~choosing-apt-or-aptitude Scegliere apt o aptitude

Per installare pacchetti in fase di compilazione si può optare sia per
/{apt}/ sia per /{aptitude}/, l'argomento #{--apt}# di #{lb config}#
determina quale usare. Sceglie il metodo implementando il comportamento
preferito per l'installazione dei pacchetti, la notevole differenza è come
vengono gestiti quelli mancanti.

_* #{apt}#: se viene specificato un pacchetto mancante, l'installazione avrà
esito negativo; questo è l'impostazine predefinita.

_* #{aptitude}#: se viene specificato un pacchetto mancante, l'installazione
avrà successo.

3~ Utilizzare un proxy con APT

Una configurazione di APT spesso richiesta è di amministrare la creazione di
un'immagine dietro un proxy, lo si può specificare con le opzioni
#{--apt-ftp-proxy}# o #{--apt-http-proxy}# secondo necessità:

code{

 $ lb config --apt-http-proxy http://proxy/

}code

3~tweaking-apt-to-save-space Tweaking APT to save space

Si può aver bisogno di risparmiare dello spazio sul supporto dell'immagine,
in tal caso una o entrambe delle seguenti opzioni possono essere
d'interesse.

È possibile non includere gli indici di APT con:

code{

 $ lb config --apt-indices false

}code

Questo non influenzerà le voci in #{/etc/apt/sources.list}#, determina solo
se /#{var/lib/apt}# contiene o meno i file degli indici. Il compromesso è
che APT necessita di quegli indici per operar enel sistema live, perciò
prima di eseguire #{apt-cache search}# o #{apt-get install}#, per esempio,
l'utente deve usare prima #{apt-get update}# per crearli.

If you find the installation of recommended packages bloats your image too
much, provided you are prepared to deal with the consequences discussed
below, you may disable that default option of APT with:

code{

 $ lb config --apt-recommends false

}code

The most important consequence of turning off recommends is that
#{live-boot}# and #{live-config}# themselves recommend some packages that
provide important functionality used by most Live configurations, such as
#{user-setup}# which #{live-config}# recommends and is used to create the
live user. In all but the most exceptional circumstances you need to add
back at least some of these recommends to your package lists or else your
image will not work as expected, if at all. Look at the recommended packages
for each of the #{live-*}# packages included in your build and if you are
not certain you can omit them, add them back into your package lists.

The more general consequence is that if you don't install recommended
packages for any given package, that is, "packages that would be found
together with this one in all but unusual installations" (Debian Policy
Manual, section 7.2), some packages that users of your Live system actually
need may be omitted. Therefore, we suggest you review the difference turning
off recommends makes to your packages list (see the #{binary.packages}# file
generated by #{lb build}#) and re-include in your list any missing packages
that you still want installed. Alternatively, if you find you only want a
small number of recommended packages left out, leave recommends enabled and
set a negative APT pin priority on selected packages to prevent them from
being installed, as explained in {APT pinning}#apt-pinning.

3~ Passare opzioni ad apt o aptitude

Se non c'è un'opzione di #{lb config}# per modificare il comportamento di
APT nel modo desiderato, si usi #{--apt-options}# o #{--aptitude-options}#
per passare opzioni tramite il proprio strumento APT. Consultare il manuale
di #{apt}# e #{aptitude}# per i dettagli.

3~apt-pinning APT pinning

Si prega di leggere prima il manuale di #{apt_preferences(5)}#. Il pinning
può essere configurato sia in fase di costruzione sia di esecuzione; per la
prima creare #{config/chroot_apt/preferences}# mentre per l'ultima creare
#{config/includes.chroot/etc/apt/preferences}#.

Nell'ipotesi di creare un sistema live wheezy e avendo la necessità di
installare da sid tutti i pacchetti live destinati all'immagine binaria
questa fase, bisogna aggiungere sid alle fonti di APT e farne il pinning
affinché verranno installati da lì solo i pacchetti voluti, mentre per tutti
gli altri si attingerà dalla distribuzione principale, wheezy. Quanto segue
servirà allo scopo:

code{

 $ echo "deb http://mirror/debian sid main" > config/archives/sid.list.chroot
 $ cat >> config/chroot_apt/preferences << END
 Package: live-boot live-boot-initramfs-tools live-config live-config-sysvinit
 Pin: release n=sid
 Pin-Priority: 600

 Package: *
 Pin: release n=sid
 Pin-Priority: 1
 END

}code

*{Nota:}* con la versione 0.8.14 o superiore di Apt si possono utilizzare wildcard nei nomi dei pacchetti (*{Package: live-*}*). Ciò significa che funziona con wheezy usando:

code{

$ lb config --distribution wheezy

}code

Negative pin priorities will prevent a package from being installed, as in
the case where you do not want a package that is recommended by another
package. Suppose you are building an LXDE image using #{task-lxde-desktop}#
in #{config/package-lists/lxde-desktop.list.chroot}#, but don't want the
user prompted to store wifi passwords in the keyring. This metapackage
depends on /{lxde-core}/, which recommends /{gksu}/, which in turn
recommends /{gnome-keyring}/. So you want to omit the recommended
/{gnome-keyring}/ package. This can be done by adding the following stanza
to #{config/chroot_apt/preferences}#:

code{

 Package: gnome-keyring
 Pin: version *
 Pin-Priority: -1

}code
