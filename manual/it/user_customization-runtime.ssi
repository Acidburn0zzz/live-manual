:B~ Personalizzare i comportamenti durante l'esecuzione

1~customizing-run-time-behaviours Personalizzare i comportamenti durante
l'esecuzione

Tutte le configurazioni durante l'esecuzione sono eseguite da
live-config. Vengono qui presentate alcune delle opzioni di live-config più
comuni alle quali gli utenti sono interessati; una lista completa può essere
trovata nel suo manuale.

2~ Personalizzare l'utente live

Un'importante considerazione è che l'utente live viene creato all'avvio da
live-boot e non da live-build durante la compilazione. Questo non solo
influenza dove viene introdotto il materiale relativo all'utente nella
creazione, come discusso in {Live/chroot include
locali}#live-chroot-local-includes, ma anche ogni gruppo e permesso
associato all'utente live.

È possibile specificare gruppi aggiuntivi ai quali l'utente live apparterrà
preconfigurando il valore #{passwd/user-default-groups}# di debconf. Ad
esempio, per aggiungere l'utente al gruppo #{fuse}#, inserire la seguente
preconfigurazione in #{config/preseed/}# per la fase chroot:

code{

 $ lb config
 $ echo user-setup passwd/user-default-groups string audio cdrom \
   dip floppy video plugdev netdev powerdev scanner bluetooth fuse \
   >> config/preseed/my.preseed.chroot

}code

È inoltre possibile modificare facilmente il nome utente "user" e la
password "live" predefiniti.

Per cambiare il nome utente specificare quanto segue nella configurazione:

code{

 $ lb config --bootappend-live "username=live-user"

}code

Un modo per cambiare la password è tramite un hook come descritto in {Hook
in fase di avvio}#boot-time-hooks. Si può usare l'hook "passwd" da
#{/usr/share/doc/live-config/examples/hooks}#, anteponendolo di conseguenza
(ad esempio, 200-passwd) e aggiungerlo al file
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Personalizzare la localizzazione e la
lingua

Quando il sistema live si avvia, la lingua è inserita in tre fasi:

_* generazione della localizzazione

_* impostazione del layout di tastiera per la console

impostazione del layout di tastiera per X

Quando si crea un sistema live la localizzazione predefinita è
"locales=en_US.UTF-8". Per definire quale generare, si usi il parametro
#{locales}# nell'opzione #{--bootappend-live}# di #{lb config}#:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

Questo parametro può inoltre essere usato dalla riga di comando del kernel,
specificando una localizzazione nella forma #{lingua_nazione.codifica}#.

Sia la configurazione della tastiera in console sia di X dipendono dal
parametro #{keyboard-layouts}# dell'opzione #{--bootappend-live}#. Si
possono trovare le opzioni valide per i layout di X in
#{/usr/share/X11/xkb/rules/base.xml}# (piuttosto che limitate alle due
lettere del codice della nazione); per trovare il valore (i due caratteri)
corrispondenti alla lingua, si cerchi con il nome inglese della nazione in
cui si parla tale lingua:

code{

 $ grep -i sweden -C3 /usr/share/X11/xkb/rules/base.xml | grep name
 <name>se</name>

}code

Per ottenere i file di localizzazione per il layout di tastiera tedesco e
svizzero-tedesco in X:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

Si può ottenere un elenco di valori validi della tastiera per la console con
il seguente comando:

code{

 $ for i in $(find /usr/share/keymaps/ -iname "*kmap.gz"); \
     do basename $i | head -c -9; echo; done | sort | less

}code

In alternativa è possibile utilizzare il pacchetto #{console-setup}#, uno
strumento per configurare il layout della console tramite le definizioni di
X (XKB); si può dunque impostare il layout in modo più preciso con le
variabili #{keyboard-layouts}#, #{keyboard-variant}#, #{keyboard-options}# e
#{keyboard-model}#; live-boot userà questi parametri anche per X. Ad
esempio, per impostare un layout French-Dvorak (chiamato Bepo) su un sistema
francese con una tastiera TypeMatrix, sia in console sia in X11:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variant=bepo keyboard-model=tm2030usb"

}code

2~persistence Persistenza

Uno dei paradigmi di un cd live è un sistema preinstallato eseguito da un
supporto in sola lettura, come un cdrom, dove le modifiche non sopravvivono
ai riavvii dell'hardware della macchina ospitante.

Un sistema Debian Live è una generalizzazione di questo paradigma e di
conseguenza oltre ai CD gestisce altri supporti; ma comunque, nel suo
comportamento predefinito, deve essere considerato in sola lettura e tutte i
cambiamenti fatti durante l'esecuzione del sistema verranno persi allo
spegnimento.

Persistenza è il nome comune per differenti tipi di soluzioni per salvare
alcune o tutte queste modifiche con i riavii. Per capire come funziona
potrebbe essere utile sapere che sebbene il sistema venga avviato ed
eseguito da un dispositivo in sola lettura, le modifiche a file e directory
vengono scritte su uno scrivibile, tipicamente un ram disk (tmpfs) e i dati
sui ram disk non sopravvivono ai riavvii.

I dati immagazzinati su questo ramdisk andrebbero salvati un supporto
scrivibile persistente come un supporto di memorizzazione locale, una
condivisione di rete o anche una sessione di un CD/DVD riscrivibile
multisessione. Tutti questi supporti sono gestiti in Debian Live in modi
differenti, e tutti tranne l'ultimo richiedono un parametro d'avvio speciale
da specificare all'avvio: #{persistent}#.

Se il parametro di boot #{persistent}# è impostato (e non lo è
#{nopersistent}#), i supporti di memorizzazione locali (hard disk,
dispositivi USB) saranno rilevati come volumi persistenti durante
l'avvio. Un volume persistente è uno dei seguenti:

_* una partizione, identificata dal suo nome GPT (GUID Partition Table).

_* un filesystem, identificato dalla sua label.

_* un file immagine o archivio situato nella directory radice di un
qualsiasi filesystem leggibile (anche una partizione NTFS di un sistema
estraneo), identificato dal nome del file. In questo caso il nome del file
deve contenere anche il tipo di filesystem come estensione, ad esempio
"<label>.ext4".

È possibile limitare i tipi di volume persistenti da usare specificando
certi parametri di boot descritti nella manpage di live-boot(7). Le "label
identificative" di cui sopra possono essere una delle seguenti:

_* #{full-ov}# per strati di persistenza completa.

_* #{custom-ov}# per strati personalizzati.

_* #{live-sn}# per istantanee del sistema completo.

_* #{home-sn}# per istantanee della /home.

3~ Strati di persistenza completa

Con "persistenza completa" si intende l'uso di un volume persistente invece
di un filesystem temporaneo (tmpfs) per salvare le modifiche al supporto in
sola lettura (con il sistema COW, copy-on-write). Per questo tipo di
persistenza la label deve essere #{full-ov}#, che potrebbe essere una
partizione di tipo ext4 su un hard disk o una penna USB creata ad esempio
con:

code{

 # mkfs.ext4 -L full-ov /dev/sdb1

}code

Vedee anche {Usare lo spazio rimanente su una penna
USB}#using-usb-extra-space.

Se si possiede già una partizione sul dispositivo basta solo cambiare
l'etichetta con una delle seguenti:

code{

 $ tune2fs -L full-ov /dev/sdb1 # per filesystems ext2,3,4

}code

Ecco un esempio di come creare un file immagine ext4 da utilizzare per la
persistenza completa:

code{

 $ dd if=/dev/null of=full-ov bs=1G seek=1 # per un file immagine da 1GB
 $ /sbin/mkfs.ext4 -F full-ov

}code

Quindi copiare il file #{full-ov}# nella directory radice di una partizione
scrivibile e riavviare.

3~ Strati personalizzati

Un volume con una label #{custom-ov}# può essere configurato per creare
directory persistenti arbitrarie. Il file #{live.persist}#, situato nella
directory radice del filesystem del volume, controlla quali rendere
persistenti e in che modo.

Nella manpage di live.persist(5) è descritto dettagliatamente come è
configurato il mount degli strati personalizzati, ma un semplice esempio
dovrebbe essere sufficiente per la maggior parte degli usi. Supponendo di
voler creare la directory home e quella della cache di APT in modo
persistente in un filesystem ext4 sulla partizione /dev/sdb1:

code{

 $ mkfs.ext4 -L custom-ov /dev/sdb1
 $ mount -t ext4 /dev/sdb1 /mnt
 $ echo "/home" >> /mnt/live.persist
 $ echo "/var/cache/apt" >> /mnt/live.persist

}code

Quindi riavviare. Durante il primo avvio il contenuto di #{/home}# e
#{/var/cache/apt}# saranno copiati nel volume persistente e da allora tutte
le modifiche a queste directory risiederanno in modo persistente sul
volume. C'è da considerare che tutti i path elencati nel file
#{live.persist}# non possono contenere spazi o i caratteri speciali #{.}# e
#{..}#; inoltre, né #{/live}# (o nessuna delle sue sottodirectory) né #{/}#
può essere resa persistente tramite i mount personalizzati (per l'ultimo
usare la tipologia #{full-ov}# descritta prima).

Possono essere utilizzati svariati volumi di stratificazione personalizzati
(con i rispettivi file #{live.persist}#) allo stesso tempo ma se questi
creano la stessa directory persistente, ne verrà usata solo una. Se due
directory montate sono "nidificate" (una è la sottodirectory dell'altra), la
superiore sarà montata per prima, per cui nessuna operazione di mount verrà
sovrastata dall'altra. I mount nidificati personalizzati sono problematici
se sono elencati nello stesso file #{live.persist}. Se si ha davvero la
necessità (in genere non si dovrebbe averla), consultare la manpage di
live.persist(5) per sapere come gestire questo caso.

3~ Istantanee

Le istantanee sono raccolte di file e directory che non vengono montate
durante l'esecuzione ma copiate all'avvio da un volume persistente al
sistema (tmpfs) e risincronizzate al riavvio e spegnimento. Il volume deve
essere etichettato come #{live-sn}# sotto forma di un semplice archivio cpio
nominato #{live-sn.cpio.gz}#. Un'interruzione di corrente durante
l'esecuzione potrebbe portare ad una perdita di dati, se son state fatte
modifiche importanti si può usare usare #{live-snapshot --refresh}# tante
volte quanto necessario.Giacché non scrive continuamente sul dispositivo,
questo tipo di persistenza è il sistema più comodo e veloce per dispositivi
basati su memoria flash ma occupa tanta RAM quanta è la dimensione
dell'istantanea decompressa.

Esiste anche un'istantanea della /home con etichetta #{home-sn.*}#; funziona
come la principale ma viene applicata solo ad /home.

Attualmente le istantanee non possono gestire la cancellazione dei file.

3~ Sottotesto persistente

Se un utente avesse bisogno di archiviazioni multiple dello stesso tipo per
differenti posti o per test, come #{full-ov-casa}# e #{full-ov-lavoro}#, il
parametro d'avvio #{persistent-subtext}# usato in congiunzione con
#{persistent}# permetterà supporti persistenti multipli ma univoci. Un
esempio potrebbe essere un utente che vuole usare una partizione etichettata
come #{live-sn-sottotesto}#, userebbe: #{persistent}#
#{persistent-subtext=sottotesto}#.

3~ Rimasterizzazione parziale

Le modifiche in fase di esecuzione del tmpfs possono essere incluse in uno
squashfs usando live-snapshot e aggiunte al cd per rimasterizzare la iso nel
caso di un cd riscrivibile o aggiunto ad una sessione di un cd/dvd(rw)
multisessione; live-boot monta tutti i filesystem /live in ordine o con il
modulo del parametro d'avvio.
