:B~ Personalizzare i comportamenti durante l'esecuzione

1~customizing-run-time-behaviours Personalizzare i comportamenti durante
l'esecuzione

Tutte le configurazioni durante l'esecuzione sono eseguite da
live-config. Vengono qui presentate alcune delle opzioni di live-config più
comuni alle quali gli utenti sono interessati; una lista completa può essere
trovata nel suo manuale.

2~ Personalizzare l'utente live

Un'importante considerazione è che l'utente live viene creato all'avvio da
live-boot e non da live-build durante la compilazione. Questo non solo
influenza dove viene introdotto il materiale relativo all'utente nella
creazione, come discusso in {Live/chroot include
locali}#live-chroot-local-includes, ma anche ogni gruppo e permesso
associato all'utente live.

È possibile specificare gruppi aggiuntivi ai quali l'utente live apparterrà
preconfigurando il valore #{passwd/user-default-groups}# di debconf. Ad
esempio, per aggiungere l'utente al gruppo #{fuse}#, inserire la seguente
preconfigurazione in #{config/preseed/}# per la fase chroot:

code{

 $ lb config
 $ echo user-setup passwd/user-default-groups string audio cdrom \
   dip floppy video plugdev netdev powerdev scanner bluetooth fuse \
   >> config/preseed/my.preseed.chroot

}code

It is also possible to change the default username "user" and the default
password "live". If you want to do that for any reason, you can easily
achieve it as follows:

To change the default username you can simply specify it in your config:

code{

 $ lb config --bootappend-live "username=live-user"

}code

One possible way of changing the default password is by means of a hook as
described in {Boot-time hooks}#boot-time-hooks. In order to do that you can
use the "passwd" hook from #{/usr/share/doc/live-config/examples/hooks}#,
prefix it accordingly (e.g. 200-passwd) and add it to
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Personalizzare la localizzazione e la
lingua

Quando il sistema live si avvia, la lingua è inserita in tre fasi:

_* generazione della localizzazione

_* impostazione del layout di tastiera per la console

impostazione del layout di tastiera per X

Quando si crea un sistema live la localizzazione predefinita è
"locales=en_US.UTF-8". Per definire quale generare, si usi il parametro
#{locales}# nell'opzione #{--bootappend-live}# di #{lb config}#:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

Questo parametro può inoltre essere usato dalla riga di comando del kernel,
specificando una localizzazione nella forma #{lingua_nazione.codifica}#.

Sia la configurazione della tastiera in console sia di X dipendono dal
parametro #{keyboard-layouts}# dell'opzione #{--bootappend-live}#. Si
possono trovare le opzioni valide per i layout di X in
#{/usr/share/X11/xkb/rules/base.xml}# (piuttosto che limitate alle due
lettere del codice della nazione); per trovare il valore (i due caratteri)
corrispondenti alla lingua, si cerchi con il nome inglese della nazione in
cui si parla tale lingua:

code{

 $ grep -i sweden -C3 /usr/share/X11/xkb/rules/base.xml | grep name
 <name>se</name>

}code

Per ottenere i file di localizzazione per il layout di tastiera tedesco e
svizzero-tedesco in X:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

Si può ottenere un elenco di valori validi della tastiera per la console con
il seguente comando:

code{

 $ for i in $(find /usr/share/keymaps/ -iname "*kmap.gz"); \
     do basename $i | head -c -9; echo; done | sort | less

}code

In alternativa è possibile utilizzare il pacchetto #{console-setup}#, uno
strumento per configurare il layout della console tramite le definizioni di
X (XKB); si può dunque impostare il layout in modo più preciso con le
variabili #{keyboard-layouts}#, #{keyboard-variant}#, #{keyboard-options}# e
#{keyboard-model}#; live-boot userà questi parametri anche per X. Ad
esempio, per impostare un layout French-Dvorak (chiamato Bepo) su un sistema
francese con una tastiera TypeMatrix, sia in console sia in X11:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variant=bepo keyboard-model=tm2030usb"

}code

2~persistence Persistenza

Uno dei paradigmi di un cd live è un sistema preinstallato eseguito da un
supporto in sola lettura, come un cdrom, dove le modifiche non sopravvivono
ai riavvii dell'hardware della macchina ospitante.

Un sistema Debian Live è una generalizzazione di questo paradigma e di
conseguenza oltre ai CD gestisce altri supporti; ma comunque, nel suo
comportamento predefinito, deve essere considerato in sola lettura e tutte i
cambiamenti fatti durante l'esecuzione del sistema verranno persi allo
spegnimento.

Persistenza è il nome comune per differenti tipi di soluzioni per salvare
alcune o tutte queste modifiche con i riavii. Per capire come funziona
potrebbe essere utile sapere che sebbene il sistema venga avviato ed
eseguito da un dispositivo in sola lettura, le modifiche a file e directory
vengono scritte su uno scrivibile, tipicamente un ram disk (tmpfs) e i dati
sui ram disk non sopravvivono ai riavvii.

I dati immagazzinati su questo ramdisk andrebbero salvati un supporto
scrivibile persistente come un supporto di memorizzazione locale, una
condivisione di rete o anche una sessione di un CD/DVD riscrivibile
multisessione. Tutti questi supporti sono gestiti in Debian Live in modi
differenti, e tutti tranne l'ultimo richiedono un parametro d'avvio speciale
da specificare all'avvio: #{persistent}#.

If the boot parameter #{persistent}# is set (and #{nopersistent}# is not
set), local storage media (e.g. hard disks, USB drives) will be probed for
persistent volumes during boot. A persistent volume is any of the following:

_* a partition, identified by its GPT name.

_* a filesystem, identified by its filesystem label.

_* an image/archive file located on the root of any readable filesystem
(even an NTFS partition of a foreign OS), identified by its file name. In
this case the file name must also use the containing filesystem as the file
extension, e.g. "<label>.ext3".

It is possible to restrict which types of persistent volumes to use by
specifying certain boot parameters described in the live-boot(7) man
page. The "identifying labels" referred to above can be any of the
following:

_* #{full-ov}# for full persistent overlays.

_* #{custom-ov}# for custom overlays.

_* #{live-sn}# for full system snapshots.

_* #{home-sn}# per istantanee in /home.

3~ Full persistent overlays

By 'full persistence' it is meant that instead of using a tmpfs for storing
modifications to the read-only media (with the copy-on-write, COW, system) a
persistent volume is used. For this type of persistence the volume label
must be #{full-ov}#. This could, for instance, be an ext2 partition on a
hard disk or on a usb key created with, e.g.:

code{

 # mkfs.ext2 -L full-ov /dev/sdb1

}code

Si veda anche {Usare lo spazio rimanente su una penna
USB}#using-usb-extra-space.

Se si possiede già una partizione sul dispositivo basta solo cambiare
l'etichetta con una delle seguenti:

code{

 $ tune2fs -L full-ov /dev/sdb1 # for ext2,3,4 filesystems

}code

Here's an example of how to create an ext2-based image file used for full
persistence:

code{

 $ dd if=/dev/null of=full-ov bs=1G seek=1 # for a 1GB sized image file
 $ /sbin/mkfs.ext2 -F full-ov

}code

Then copy the #{full-ov}# file to the root of a writable partition and
reboot.

3~ Custom overlays

A volume with the label #{custom-ov}# can be configured to make arbitrary
directories persistent. The file #{live.persist}#, located on the volume's
filesystem root, controls which directories it makes persistent, and in
which way.

How custom overlay mounts are configured is described in full detail in the
live.persist(5) man page, but a simple example should be sufficient for most
uses. Let's say we want to make our home directory and APT cache persistent
in an ext3 filesystem on the /dev/sdb1 partition:

code{

 $ mkfs.ext3 -L custom-ov /dev/sdb1
 $ mount -t ext3 /dev/sdb1 /mnt
 $ echo "/home" >> /mnt/live.persist
 $ echo "/var/cache/apt" >> /mnt/live.persist

}code

Then we reboot. During the first boot the contents of /home and
/var/cache/apt will be copied into the persistent volume, and from then on
all changes to these directories will live in the persistent volume. Please
note that any paths listed in the #{live.persist}# file cannot contain white
spaces or the special "." and ".." path components. Also, neither "/live"
(or any of its sub-directories) nor "/" can be made persistent using custom
mounts (for the latter, use the #{full-ov}# type persistence described
above).

Several different custom overlay volumes (with their own #{live.persist}#
files) can be used at the same time, but if several volumes make the same
directory persistent, only one of them will be used. If any two mounts are
"nested" (i.e. one is a sub-directory of the other) the parent will be
mounted before the child so no mount will be hidden by the other. Nested
custom mounts are problematic if they are listed in the same
#{live.persist}# file. See the live.persist(5) man page for how to handle
that case if you really need it (hint: you usually don't).

3~ Istantanee

Snapshots are collections of files and directories which are not mounted
while running but which are copied from a persistent volume to the system
(tmpfs) at boot and which are resynced at reboot/shutdown of the system. The
volume must be labeled #{live-sn}#, and it defaults to a simple cpio archive
named #{live-sn.cpio.gz}#. A power interruption during run time could lead
to data loss, hence, if you have important changes, invoke #{live-snapshot
--refresh}# as often as needed. This type of persistence, since it does not
write continuously to the persistent media, is the most flash-based device
friendly and the fastest of all the persistence systems, but it occupies as
much RAM as the size of the uncompressed snapshot.

Esiste anche un'istantanea della /home con etichetta #{home-sn.*}#; funziona
come la principale ma viene applicata solo ad /home.

Snapshots cannot currently handle file deletion.

3~ Sottotesto persistente

If a user would need multiple persistent storage of the same type for
different locations or testing, such as #{full-ov-nonwork}# and
#{full-ov-work}#, the boot parameter #{persistent-subtext}# used in
conjunction with the boot parameter #{persistent}# will allow for multiple
but unique persistent media. An example would be if a user wanted to use a
persistent partition labeled #{live-sn-subText}# they would use the boot
parameters of: #{persistent}# #{persistent-subtext=subText}#.

3~ Rimasterizzazione parziale

Le modifiche in fase di esecuzione del tmpfs possono essere incluse in uno
squashfs usando live-snapshot e aggiunte al cd per rimasterizzare la iso nel
caso di un cd riscrivibile o aggiunto ad una sessione di un cd/dvd(rw)
multisessione; live-boot monta tutti i filesystem /live in ordine o con il
modulo del parametro d'avvio.
