:B~ Personalizzare i comportamenti durante l'esecuzione

1~customizing-run-time-behaviours Personalizzare i comportamenti durante
l'esecuzione

Tutte le configurazioni durante l'esecuzione sono eseguite da
live-config. Vengono qui presentate alcune delle opzioni di live-config più
comuni alle quali gli utenti sono interessati; una lista completa può essere
trovata nel suo manuale.

2~ Personalizzare l'utente live

Un'importante considerazione è che l'utente live viene creato all'avvio da
live-boot e non da live-build durante la compilazione. Questo non solo
influenza dove viene introdotto il materiale relativo all'utente nella
creazione, come discusso in {Live/chroot include
locali}#live-chroot-local-includes, ma anche ogni gruppo e permesso
associato all'utente live.

È possibile specificare gruppi aggiuntivi ai quali l'utente live apparterrà
preconfigurando il valore #{passwd/user-default-groups}# di debconf. Ad
esempio, per aggiungere l'utente al gruppo #{fuse}#, inserire la seguente
preconfigurazione in #{config/preseed/}# per la fase chroot:

code{

 $ lb config
 $ echo user-setup passwd/user-default-groups string audio cdrom \
   dip floppy video plugdev netdev powerdev scanner bluetooth fuse \
   >> config/preseed/my.preseed.chroot

}code

È inoltre possibile modificare facilmente il nome utente "user" e la
password "live" predefiniti.

Per cambiare il nome utente specificare quanto segue nella configurazione:

code{

 $ lb config --bootappend-live "username=live-user"

}code

Un modo per cambiare la password è tramite un hook come descritto in {Hook
in fase di avvio}#boot-time-hooks. Si può usare l'hook "passwd" da
#{/usr/share/doc/live-config/examples/hooks}#, anteponendolo di conseguenza
(ad esempio, 200-passwd) e aggiungerlo al file
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Personalizzare la localizzazione e la
lingua

Quando il sistema live si avvia, la lingua è inserita in tre fasi:

_* generazione della localizzazione

_* impostazione del layout di tastiera per la console

impostazione del layout di tastiera per X

Quando si crea un sistema live la localizzazione predefinita è
"locales=en_US.UTF-8". Per definire quale generare, si usi il parametro
#{locales}# nell'opzione #{--bootappend-live}# di #{lb config}#:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

Questo parametro può inoltre essere usato dalla riga di comando del kernel,
specificando una localizzazione nella forma #{lingua_nazione.codifica}#.

Sia la configurazione della tastiera in console sia di X dipendono dal
parametro #{keyboard-layouts}# dell'opzione #{--bootappend-live}#. Si
possono trovare le opzioni valide per i layout di X in
#{/usr/share/X11/xkb/rules/base.xml}# (piuttosto che limitate alle due
lettere del codice della nazione); per trovare il valore (i due caratteri)
corrispondenti alla lingua, si cerchi con il nome inglese della nazione in
cui si parla tale lingua:

code{

 $ grep -i sweden -C3 /usr/share/X11/xkb/rules/base.xml | grep name
 <name>se</name>

}code

Per ottenere i file di localizzazione per il layout di tastiera tedesco e
svizzero-tedesco in X:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

Si può ottenere un elenco di valori validi della tastiera per la console con
il seguente comando:

code{

 $ for i in $(find /usr/share/keymaps/ -iname "*kmap.gz"); \
     do basename $i | head -c -9; echo; done | sort | less

}code

In alternativa è possibile utilizzare il pacchetto #{console-setup}#, uno
strumento per configurare il layout della console tramite le definizioni di
X (XKB); si può dunque impostare il layout in modo più preciso con le
variabili #{keyboard-layouts}#, #{keyboard-variant}#, #{keyboard-options}# e
#{keyboard-model}#; live-boot userà questi parametri anche per X. Ad
esempio, per impostare un layout French-Dvorak (chiamato Bepo) su un sistema
francese con una tastiera TypeMatrix, sia in console sia in X11:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variant=bepo keyboard-model=tm2030usb"

}code

2~persistence Persistenza

Uno dei paradigmi di un cd live è un sistema preinstallato eseguito da un
supporto in sola lettura, come un cdrom, dove le modifiche non sopravvivono
ai riavvii dell'hardware della macchina ospitante.

Un sistema Debian Live è una generalizzazione di questo paradigma e di
conseguenza oltre ai CD gestisce altri supporti; ma comunque, nel suo
comportamento predefinito, deve essere considerato in sola lettura e tutte i
cambiamenti fatti durante l'esecuzione del sistema verranno persi allo
spegnimento.

'Persistence' is a common name for different kinds of solutions for saving
across reboots some, or all, of this run-time evolution of the system. To
understand how it works it would be handy to know that even if the system is
booted and run from read-only media, modifications to the files and
directories are written on writable media, typically a ram disk (tmpfs) and
ram disks' data do not survive reboots.

I dati immagazzinati su questo ramdisk andrebbero salvati un supporto
scrivibile persistente come un supporto di memorizzazione locale, una
condivisione di rete o anche una sessione di un CD/DVD riscrivibile
multisessione. Tutti questi supporti sono gestiti in Debian Live in modi
differenti, e tutti tranne l'ultimo richiedono un parametro d'avvio speciale
da specificare all'avvio: #{persistence}#.

If the boot parameter #{persistence}# is set (and #{nopersistence}# is not
set), local storage media (e.g. hard disks, USB drives) will be probed for
persistence volumes during boot. It is possible to restrict which types of
persistence volumes to use by specifying certain boot parameters described
in the live-boot(7) man page. A persistence volume is any of the following:

_* una partizione, identificata dal suo nome GPT (GUID Partition Table).

_* un filesystem, identificato dalla sua label.

_* an image file located on the root of any readable filesystem (even an
NTFS partition of a foreign OS), identified by its file name. In this case
the file name must also use the containing filesystem as the file extension,
e.g. "persistence.ext4".

The volume label for overlays must be #{persistence}#. And in order to fully
customize the volume's persistence there must be a file named
#{live-persistence.conf}#. See {The live-persistence.conf
file}#live-persistence-conf

Here are some examples of how to prepare a volume to be used for
persistence. It can be, for instance, an ext4 partition on a hard disk or on
a usb key created with, e.g.:

code{

 # mkfs.ext4 -L persistence /dev/sdb1

}code

Vedere anche {Usare lo spazio rimanente su una penna
USB}#using-usb-extra-space.

Se si possiede già una partizione sul dispositivo basta solo cambiare
l'etichetta con una delle seguenti:

code{

 $ tune2fs -L persistence /dev/sdb1 # for ext2,3,4 filesystems

}code

Here's an example of how to create an ext4-based image file used for
persistence:

code{

 $ dd if=/dev/null of=persistence bs=1G seek=1 # for a 1GB sized image file
 $ /sbin/mkfs.ext4 -F persistence

}code

Then copy the #{persistence}# file to the root of a writable partition.

3~live-persistence-conf The live-persistence.conf file

A volume with the label #{persistence}# can be configured to make arbitrary
directories persistent. The file #{live-persistence.conf}#, located on the
volume's filesystem root, controls which directories it makes persistent,
and in which way.

Nella manpage di live-persistence.conf(5) è descritto dettagliatamente come
è configurato il mount degli strati personalizzati, ma un semplice esempio
dovrebbe essere sufficiente per la maggior parte degli usi. Supponendo di
voler creare la directory home e quella della cache di APT in modo
persistente in un filesystem ext4 sulla partizione /dev/sdb1:

code{

 $ mkfs.ext4 -L persistence /dev/sdb1
 $ mount -t ext4 /dev/sdb1 /mnt
 $ echo "/home" >> /mnt/live-persistence.conf
 $ echo "/var/cache/apt" >> /mnt/live-persistence.conf

}code

Then we reboot. During the first boot the contents of #{/home}# and
#{/var/cache/apt}# will be copied into the persistence volume, and from then
on all changes to these directories will live in the persistence
volume. Please note that any paths listed in the #{live-persistence.conf}#
file cannot contain white spaces or the special #{.}# and #{..}# path
components. Also, neither #{/live}# (or any of its sub-directories) nor
#{/}# can be made persistent using custom mounts.

Possono essere utilizzati svariati volumi di stratificazione personalizzati
(con i rispettivi file #{live-persistence.conf}#) allo stesso tempo ma se
questi creano la stessa directory persistente, ne verrà usata solo una. Se
due directory montate sono "nidificate" (una è la sottodirectory
dell'altra), la superiore sarà montata per prima, per cui nessuna operazione
di mount verrà sovrastata dall'altra. I mount nidificati personalizzati sono
problematici se sono elencati nello stesso file #{live-persistence.conf}. Se
si ha davvero la necessità (in genere non si dovrebbe averla), consultare la
manpage di live-persistence.conf(5) per sapere come gestire questo caso.

3~ Sottotesto persistente

If a user would need multiple persistence storage of the same type for
different locations or testing, such as #{persistence-nonwork}# and
#{persistence-work}#, the boot parameter #{persistence-subtext}# used in
conjunction with the boot parameter #{persistence}# will allow for multiple
but unique persistence media. An example would be if a user wanted to use a
persistence partition labeled #{persistence-subText}# they would use the
boot parameters of: #{persistence}# #{persistence-subtext=subText}#.
