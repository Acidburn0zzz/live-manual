:B~ Personalizzare i comportamenti durante l'esecuzione

1~customizing-run-time-behaviours Personalizzare i comportamenti durante
l'esecuzione

Tutte le configurazioni durante l'esecuzione sono eseguite da
live-config. Vengono qui presentate alcune delle opzioni di live-config più
comuni alle quali gli utenti sono interessati; una lista completa può essere
trovata nel suo manuale.

2~ Personalizzare l'utente live

Un'importante considerazione è che l'utente live viene creato all'avvio da
live-boot e non da live-build durante la compilazione. Questo non solo
influenza dove viene introdotto il materiale relativo all'utente nella
creazione, come discusso in {Live/chroot include
locali}#live-chroot-local-includes, ma anche ogni gruppo e permesso
associato all'utente live.

È possibile specificare gruppi aggiuntivi ai quali l'utente live apparterrà
preconfigurando il valore #{passwd/user-default-groups}# di debconf. Ad
esempio, per aggiungere l'utente al gruppo #{fuse}#, inserire la seguente
preconfigurazione in #{config/preseed/}# per la fase chroot:

code{

 $ lb config
 $ echo user-setup passwd/user-default-groups string audio cdrom \
   dip floppy video plugdev netdev powerdev scanner bluetooth fuse \
   >> config/preseed/my.preseed.chroot

}code

È inoltre possibile modificare facilmente il nome utente "user" e la
password "live" predefiniti.

Per cambiare il nome utente specificare quanto segue nella configurazione:

code{

 $ lb config --bootappend-live "username=live-user"

}code

Un modo per cambiare la password è tramite un hook come descritto in {Hook
in fase di avvio}#boot-time-hooks. Si può usare l'hook "passwd" da
#{/usr/share/doc/live-config/examples/hooks}#, anteponendolo di conseguenza
(ad esempio, 2000-passwd) e aggiungerlo al file
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Personalizzare la localizzazione e la
lingua

When the live system boots, language is involved in two steps:

_* generazione della localizzazione

_* setting the keyboard configuration

The default locale when building a Live system is
#{locales=en_US.UTF-8}#. To define the locale that should be generated, use
the #{locales}# parameter in the #{--bootappend-live}# option of #{lb
config}#, e.g.

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

Multiple locales may be specified as a comma-delimited list.

This parameter, as well as the keyboard configuration parameters indicated
below, can also be used at the kernel command line. You can specify a locale
by #{language_country}# (in which case the default encoding is used) or the
full #{language_country.encoding}# word. A list of supported locales and the
encoding for each can be found in #{/usr/share/i18n/SUPPORTED}#.

Both the console and X keyboard configuration are performed by
#{live-config}# using the #{console-setup}# package. To configure them, use
the #{keyboard-layouts}#, #{keyboard-variants}#, #{keyboard-options}# and
#{keyboard-model}# boot parameters via the #{--bootappend-live}#
option. Valid options for these can be found in
#{/usr/share/X11/xkb/rules/base.lst}#. To find layouts and variants for a
given language, try searching for the English name of the language and/or
the country where the language is spoken, e.g:

code{

$ egrep -i '(^!|german.*switzerland)' /usr/share/X11/xkb/rules/base.lst
 ! model
 ! layout
   ch              German (Switzerland)
 ! variant
   legacy          ch: German (Switzerland, legacy)
   de_nodeadkeys   ch: German (Switzerland, eliminate dead keys)
   de_sundeadkeys  ch: German (Switzerland, Sun dead keys)
   de_mac          ch: German (Switzerland, Macintosh)
 ! option

}code

Note that each variant lists the layout to which it applies in the
description.

Often, only the layout needs to be configured. For example, to get the
locale files for German and Swiss German keyboard layout in X use:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

However, for very specific use cases, you may wish to include other
parameters. For example, to set up a French system with a French-Dvorak
layout (called Bepo) on a TypeMatrix EZ-Reach 2030 USB keyboard, use:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variants=bepo keyboard-model=tm2030usb"

}code

Multiple values may be specified as comma-delimited lists for each of the
#{keyboard-*}# options, with the exception of #{keyboard-model}#, which
accepts only one value. Please see the #{keyboard(5)}# man page for details
and examples of #{XKBMODEL}#, #{XKBLAYOUT}#, #{XKBVARIANT}# and
#{XKBOPTIONS}# variables. If multiple #{keyboard-variants}# values are
given, they will be matched one-to-one with #{keyboard-layouts}# values (see
#{setxkbmap(1)}# #{-variant}# option). Empty values are allowed; e.g. to
define two layouts, the default being US QWERTY and the other being US
Dvorak, use:

code{

 $ lb config --bootappend-live \
     "keyboard-layouts=us,us keyboard-variants=,dvorak"

}code

2~persistence Persistenza

Uno dei paradigmi di un cd live è un sistema preinstallato eseguito da un
supporto in sola lettura, come un cdrom, dove le modifiche non sopravvivono
ai riavvii dell'hardware della macchina ospitante.

Un sistema Debian Live è una generalizzazione di questo paradigma e di
conseguenza oltre ai CD gestisce altri supporti; ma comunque, nel suo
comportamento predefinito, deve essere considerato in sola lettura e tutte i
cambiamenti fatti durante l'esecuzione del sistema verranno persi allo
spegnimento.

Persistenza è il nome comune per differenti tipi di soluzioni per salvare
alcune o tutte queste modifiche con i riavii. Per capire come funziona
potrebbe essere utile sapere che sebbene il sistema venga avviato ed
eseguito da un dispositivo in sola lettura, le modifiche a file e directory
vengono scritte su uno scrivibile, tipicamente un ram disk (tmpfs) e i dati
sui ram disk non sopravvivono ai riavvii.

I dati immagazzinati su questo ramdisk andrebbero salvati un supporto
scrivibile persistente come un supporto di memorizzazione locale, una
condivisione di rete o anche una sessione di un CD/DVD riscrivibile
multisessione. Tutti questi supporti sono gestiti in Debian Live in modi
differenti, e tutti tranne l'ultimo richiedono un parametro d'avvio speciale
da specificare all'avvio: #{persistence}#.

Se il parametro di boot #{persistence}# è impostato (e non lo è
#{nopersistence}#), i supporti di memorizzazione locali (hard disk,
dispositivi USB) saranno rilevati come volumi persistenti durante l'avvio. È
possibile selezionare quali tipi utilizzare specificando certi parametri di
avvio descritti nella manpage di live-boot(7). Un volume persistente è uno
dei seguenti:

_* una partizione, identificata dal suo nome GPT (GUID Partition Table).

_* un filesystem, identificato dalla sua label.

_* an image file located on the root of any readable filesystem (even an
NTFS partition of a foreign OS), identified by its file name.

The volume label for overlays must be #{persistence}# but it will be ignored
unless it contains in its root a file named #{live-persistence.conf}# which
is used to fully customize the volume's persistence, this is to say,
specifying the directories that you want to save in your persistence volume
after a reboot. See {The live-persistence.conf file}#live-persistence-conf
for more details.

Here are some examples of how to prepare a volume to be used for
persistence. It can be, for instance, an ext4 partition on a hard disk or on
a usb key created with, e.g.:

code{

 # mkfs.ext4 -L persistence /dev/sdb1

}code

Vedere anche {Usare lo spazio rimanente su una penna
USB}#using-usb-extra-space.

Se si possiede già una partizione sul dispositivo basta solo cambiare
l'etichetta con una delle seguenti:

code{

 # tune2fs -L persistence /dev/sdb1 # for ext2,3,4 filesystems

}code

Here's an example of how to create an ext4-based image file to be used for
persistence:

code{

 $ dd if=/dev/null of=persistence bs=1 seek=1G # for a 1GB sized image file
 $ /sbin/mkfs.ext4 -F persistence

}code

Once the image file is created, as an example, to make #{/usr}# persistent
but only saving the changes you make to that directory and not all the
contents of #{/usr}#, you can use the "union" option. If the image file is
located in your home directory, copy it to the root of your hard drive's
filesystem and mount it in #{/mnt}# as follows:

code{

 # cp persistence /
 # mount -t ext4 /persistence /mnt

}code

Then, create the #{live-persistence.conf}# file adding content and unmount
the image file.

code{

 # echo "/usr union" >> /mnt/live-persistence.conf
 # umount /mnt

}code

Now, reboot into your live media with the boot parameter "persistence".

3~live-persistence-conf The live-persistence.conf file

A volume with the label #{persistence}# must be configured by means of the
#{live-persistence.conf}# file to make arbitrary directories
persistent. That file, located on the volume's filesystem root, controls
which directories it makes persistent, and in which way.

Nella manpage di live-persistence.conf(5) è descritto dettagliatamente come
è configurato il mount degli strati personalizzati, ma un semplice esempio
dovrebbe essere sufficiente per la maggior parte degli usi. Supponendo di
voler creare la directory home e quella della cache di APT in modo
persistente in un filesystem ext4 sulla partizione /dev/sdb1:

code{

 # mkfs.ext4 -L persistence /dev/sdb1
 # mount -t ext4 /dev/sdb1 /mnt
 # echo "/home" >> /mnt/live-persistence.conf
 # echo "/var/cache/apt" >> /mnt/live-persistence.conf
 # umount /mnt

}code

Quindi riavviare. Durante il primo avvio il contenuto di #{/home}# e
#{/var/cache/apt}# saranno copiati nel volume persistente e da allora tutte
le modifiche a queste directory risiederanno in modo persistente sul
volume. C'è da considerare che tutti i path elencati nel file
#{live-persistence.conf}# non possono contenere spazi o i caratteri speciali
#{.}# e #{..}#; inoltre, né #{/live}# (o nessuna delle sue sottodirectory)
né #{/}# può essere resa persistente tramite i mount personalizzati.

Possono essere utilizzati svariati volumi di stratificazione personalizzati
(con i rispettivi file #{live-persistence.conf}#) allo stesso tempo ma se
questi creano la stessa directory persistente, ne verrà usata solo una. Se
due directory montate sono "nidificate" (una è la sottodirectory
dell'altra), la superiore sarà montata per prima, per cui nessuna operazione
di mount verrà sovrastata dall'altra. I mount nidificati personalizzati sono
problematici se sono elencati nello stesso file #{live-persistence.conf}. Se
si ha davvero la necessità (in genere non si dovrebbe averla), consultare la
manpage di live-persistence.conf(5) per sapere come gestire questo caso.

3~ Using more than one persistence store

If a user would need multiple persistence store of the same type for
different locations or testing, such as #{persistence-nonwork}# and
#{persistence-work}#, the boot parameter #{persistence-label}# used in
conjunction with the boot parameter #{persistence}# will allow for multiple
but unique persistence media. An example would be if a user wanted to use a
persistence partition labeled #{persistence-subText}# they would use the
boot parameters of: #{persistence}# #{persistence-label=subText}#.
