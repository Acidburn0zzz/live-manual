:B~ Ejemplos

1~examples Ejemplos

Este capítulo ofrece ejemplos de creación de imágenes para casos de uso
específicos de Debian Live. Si se es nuevo en la creación de una imagen
propia de Debian Live, se recomienda leer primero los tres tutoriales en
secuencia, ya que cada uno enseña nuevas técnicas que ayudan a utilizar y
entender los ejemplos restantes.

2~using-the-examples Uso de los ejemplos

Para poder seguir estos ejemplos es necesario un sistema donde crearlos que
cumpla con los requisitos enumerados en {Requisitos}#requirements y tener
live-build instalado tal y como se describe en {Instalación de
live-build}#installing-live-build.

Hay que tener en cuenta que, para abreviar, en estos ejemplos no se
especifica una réplica local para la creación de la imagen.  Es posible
acelerar las descargas considerablemente si se utiliza una réplica local. Se
puede especificar las opciones cuando se usa #{lb config}#, tal y como se
describe en {Réplicas de Distribution utilizadas durante la
creación}#distribution-mirrors-build-time,  o para más comodidad, establecer
el valor por defecto para la creación del sistema en
#{/etc/live/build.conf}#. Basta con crear este fichero y en el mismo,
establecer las variables #{LB_MIRROR_*}# correspondientes a la réplica
preferida. Todas las demás réplicas usadas en el proceso de creación usarán
estos valores por defecto. Por ejemplo:

code{

 LB_MIRROR_BOOTSTRAP="http://mirror/debian"
 LB_MIRROR_CHROOT_SECURITY="http://mirror/debian-security"
 LB_MIRROR_CHROOT_BACKPORTS="http://mirror/debian-updates"

}code

2~tutorial-1 Tutorial 1: Una imagen estándar

*{Caso práctico:}* Crear una primera imagen sencilla, aprendiendo los fundamentos de live-build.

En este tutorial, vamos a construir una imagen ISO hybrid por defecto de
Debian Live que contenga únicamente los paquetes base (sin Xorg) y algunos
paquetes de soporte Debian Live, como un primer ejercicio en el uso de
live-build.

No puede ser más fácil que esto:

code{

 $ mkdir tutorial1 ; cd tutorial1 ; lb config

}code

Si se examina el contenido del directorio #{config/}# se verá almacenada
allí una configuración en esqueleto preparada para ser personalizada o en
este caso para ser usada inmediatamente para construir una imagen por
defecto.

Ahora, como superusuario, crear la imagen, guardando un log con #{tee}#
mientras se crea.

code{

 # lb build 2>&1 | tee binary.log

}code

Suponiendo que todo va bien, después de un rato, el directorio actual
contendrá #{binary-hybrid.iso}#. Esta imagen ISO híbrida se puede arrancar
directamente en una máquina virtual como se describe en {Probar una imagen
ISO con Qemu}#testing-iso-with-qemu y en {Probar una imagen ISO con
virtualbox-ose}#testing-iso-with-virtualbox o bien ser copiada a un medio
óptico como un dispositivo USB tal y como se describe en {Grabar una imagen
ISO en un medio físico}#burning-iso-image y {Copiar una imagen ISO híbrida
en un dispositivo USB}#copying-iso-hybrid-to-usb, respectivamente.

2~tutorial-2 Tutorial 2: Una utilidad de navegador web

*{Caso práctico:}* Crear una utilidad de navegador web, aprendiendo a aplicar personalizaciones.

En este tutorial, se creará una imagen adecuada para su uso como utilidad de
navegador web, esto sirve como introducción a la personalización de las
imágenes de Debian Live.

code{

 $ mkdir tutorial2
 $ cd tutorial2
 $ lb config -p lxde
 $ echo iceweasel >> config/package-lists/my.list.chroot

}code

La elección de LXDE para este ejemplo refleja el deseo de ofrecer un entorno
de escritorio mínimo, ya que el enfoque de la imagen es el uso individual
que se tiene en mente, el navegador web. Se podría ir aún más lejos y
ofrecer una configuración por defecto para el navegador web en
#{config/includes.chroot/etc/iceweasel/profile/}#, o paquetes adicionales de
soporte para la visualización de diversos tipos de contenido web, pero se
deja esto como un ejercicio para el lector.

Crear la imagen, de nuevo como superusuario, guardando un log como en el
{Tutorial 1}#tutorial-1:

code{

 # lb build 2>&1 | tee binary.log

}code

De nuevo, verificar que la imagen está bien y probarla igual que en el
{Tutorial 1}#tutorial-1.

2~tutorial-3 Tutorial 3: Una imagen personalizada

*{Caso práctico:}* Crear un proyecto para conseguir una imagen personalizada, que contenga el software favorito para llevárselo en una memoria USB donde quiera que se vaya, y hacerlo evolucionar en revisiones sucesivas, tal y como vayan cambiando las necesidades y preferencias.

Como nuestra imagen personalizada irá cambiando durante un número de
revisiones, si se quiere ir siguiendo esos cambios, probar nuevas cosas de
forma experimental y posiblemente volver atrás si no salen bien, se guardará
la configuración en el popular sistema de control de versiones
#{git}#. También se utilizarán las mejores prácticas de configuración
automática a través de scripts #{auto}# como se describe en {Gestionar una
configuración}#managing-a-configuration.

3~ Primera revisión

code{

 $ mkdir -p tutorial3/auto
 $ cp /usr/share/live/build/examples/auto/* tutorial3/auto/
 $ cd tutorial3

}code

Editar #{auto/config}# del siguiente modo:

code{

 #!/bin/sh

 lb config noauto \
     --architectures i386 \
     --linux-flavours 686-pae \
     --package-lists lxde \
     "${@}"

}code

Completar la lista de paquetes local:

code{

 $ echo "iceweasel xchat" >> config/package-lists/my.list.chroot

}code

En primer lugar con #{--architectures i386}# se asegura de que en nuestro
sistema de creación #{amd64}# se crea una versión de 32-bits adecuada para
ser usada en la mayoría de máquinas. En segundo lugar, se usa
#{--linux-flavours 686-pae}# porque no se espera usar esta imagen en
sistemas mucho más viejos. En tercer lugar se elige la lista de paquetes
#{lxde}# para proporcionar un escritorio mínimo. Y, por último, se añaden
dos paquetes iniciales favoritos: #{iceweasel}# y #{xchat}#.

Ahora, crear la imagen:

code{

 # lb build

}code

Tener en cuenta que a diferencia de los dos primeros tutoriales, ya no se
tiene que escribir #{2>&1 | tee binary.log}# ya que esto se incluye ahora en
#{auto/build}#.

Una vez que se ha probado la imagen (como en el {Tutorial 1}#tutorial-1) y
se ha asegurado de que funciona, es el momento de iniciar el repositorio
git, añadiendo sólo los scripts auto que se acaba de crear, y luego hacer el
primer commit:

code{

 $ git init
 $ git add auto
 $ git commit -a -m "Initial import."

}code

3~ Segunda revisión

En esta revisión, vamos a limpiar desde la primera creación, agregar el
paquete #{vlc}# a nuestra configuración, crear de nuevo, probar y enviar los
cambios al git.

El comando #{lb clean}# limpiará todos los ficheros generados en las
primeras creaciones a excepción del caché, lo cual ahorra tener que volver a
descargar de nuevo los paquetes. Esto asegura que el siguiente #{lb build}#
vuelva a ejecutar todas las fases para regenerar los ficheros de nuestra
nueva configuración.

code{

 # lb clean

}code

Añadir ahora el paquete #{vlc}# a nuestra lista de paquetes local en
#{config/package-lists/my.list.chroot}#:

code{

 
}code

Crear de nuevo:

code{

# lb build

}code

Probar, y cuando se esté satisfecho, enviar la próxima revisión al git:

code{

 $ git commit -a -m "Adding vlc media player."

}code

Por supuesto, es posible hacer cambios más complicados en la configuración,
tal vez añadiendo ficheros en los subdirectorios de #{config/}#. Cuando se
envian nuevas revisiones, hay que tener cuidado de no editar a mano o enviar
los ficheros del nivel superior en #{config}# que contienen variables
#{LB_*}# ya que estos son productos de creación también y son siempre
limpiados por #{lb clean}# y recreados con #{lb config}# a través de sus
respectivos scripts #{auto}#.

Hemos llegado al final de nuestra serie de tutoriales. Si bien son posibles
muchos más tipos de personalización, aunque sólo sea con las pocas
características explicadas en estos sencillos ejemplos, se puede crear una
variedad casi infinita de imágenes diferentes. Los ejemplos que quedan en
esta sección abarcan varios casos de usos diferentes procedentes de las
experiencias recogidas de los usuarios de Debian Live.

2~ Un cliente VNC kiosk

*{Caso Práctico:}* Crear una imagen con live-build para arrancar directamente un servidor VNC.

Hacer un directorio de creación y crear una configuración en esqueleto según
la lista estándar-x11, incluyendo #{gdm3}#, #{metacity}# y #{xvnc4viewer}#,
desactivando los paquetes recomendados para conseguir un sistema mínimo:

code{

 $ mkdir vnc_kiosk_client
 $ cd vnc_kiosk_client
 $ lb config -a i386 -k 686-pae -p standard-x11 \
     --apt-recommends false
 $ echo "gdm3 metacity xvnc4viewer" >> config/package-lists/my.list.chroot

}code

Crear el directorio #{/etc/skel}# y poner un fichero #{.xsession}#
personalizado para el usuario que por defecto ejecutará metacity e iniciará
el xvncviewer, conectándo al puerto #{5901}# de un servidor en
#{192.168.1.2}#:

code{

 $ mkdir -p config/includes.chroot/etc/skel
 $ cat > config/includes.chroot/etc/skel/.xsession << END
 #!/bin/sh

 /usr/bin/metacity &
 /usr/bin/xvncviewer 192.168.1.2:1

 exit
 END

}code

Crear la imagen:

code{

 # lb build

}code

Disfrutarlo.

2~ Una imagen básica para un pendrive USB de 128M

*{Caso Práctico:}* Crear una imagen estándar quitando algunos componentes para que quepa en un pendrive USB de 128M dejándo espacio libre para poder usarlo.

Al optimizar una imagen para adaptarla al tamaño de algunos medios de
almacenamiento, es necesario comprender el equilibrio que se está haciendo
entre tamaño y funcionalidad. En este ejemplo, se recorta tanto sólo para
dar cabida a material adicional dentro de un tamaño de 128M, pero sin hacer
nada para destruir la integridad de los paquetes que contiene, tales como la
depuración de las variantes locales a través del paquete #{localepurge}# u
otro tipo de optimizaciones «intrusivas». Cabe destacar que no se debe usar
#{--bootstrap-flavour minimal}# a menos de que realmente se sepa lo que se
está haciendo, ya que al omitir paquetes de prioridad #{importante}# lo más
probable es que se produzca un sistema roto.

code{

 $ lb config -k 486 -p minimal --apt-indices false \
     --memtest none --apt-recommends false --includes none

}code

Ahora, crear la imagen de forma habitual:

code{

 # lb build 2>&1 | tee binary.log

}code

En el sistema del autor, en el momento de escribir esto, la configuración
anterior produjo una imagen de 78Mbytes. Esto se compara favorablemente en
tamaño con la imagen de 166Mbytes producida por la configuración por defecto
en el {Tutorial 1}#tutorial-1.

El mayor ahorro de espacio aquí, en comparación con la creación de una
imagen estándar en un sistema de arquitectura #{i386}# es seleccionar sólo
la versión del kernel #{486}# en lugar de la de por defecto #{-k "486
686-pae"}#. Dejar fuera los índices de APT con #{--apt-indices false}#
también ahorra una cantidad importante de espacio, la desventaja es que es
necesario hacer un #{apt-get update}# antes de usar apt en el sistema en
vivo. Elegir la lista del paquete #{minimal}# deja fuera el gran paquete de
#{locales}# y sus utilidades asociadas. Dejando los paquetes recomendados
con #{--apt-recommends false}# se ahorra un poco de espacio adicional a
costa de omitir algunos paquetes que de otro modo podría esperarse que
estuvieran alli, tal como #{firmware-linux-free}# que puede ser necesario
para el soporte de cierto hardware. Las opciones restantes recortan pequeñas
cantidades adicionales de espacio. Es necesario decidir si vale la pena la
funcionalidad que se sacrifica con cada optimización.

2~ Un escritorio KDE con variante local e instalador

*{Caso práctico:}* Crear una imagen del escritorio KDE, con la variante local Portugués de Brasil con instalador incluido.

Se desea crear una imagen iso-hybrid para la arquitectura i386 con un
escritorio preferido, en este caso el KDE, que contiene todos los mismos
paquetes que serían instalados por el programa de instalación estándar de
Debian para KDE.

El primer problema es descubrir los nombres de las tareas adecuadas. En la
actualidad, live-build no puede ayudar en esto. Aunque podríamos tener
suerte y encontrarlos a base de pruebas, hay una herramienta,
#{grep-dctrl}#, para extraerlos de las descripciones de tareas en
tasksel-data, para proceder, asegurarse de tener ambas cosas:

code{

 
}code

Ahora podemos buscar las tareas apropiadas, primero con:

code{

 $ grep-dctrl -FTest-lang pt_BR /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: brazilian-portuguese

}code

Con este comando, se descubre que la tarea se llama, sencillamente,
brazilian-portuguese. Ahora para encontrar las tareas relacionas: 

code{

 $ grep-dctrl -FEnhances brazilian-portuguese /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: brazilian-portuguese-desktop
 Task: brazilian-portuguese-kde-desktop

}code

En el momento del arranque se van a generar las variantes locales
pt_BR.UTF-8 y seleccionar la distribución del teclado pt-latin1. También
será necesario preconfigurar la opción de escritorio, "kde" para que tasksel
instale la tarea de escritorio correcta, ya que difiere de la de por defecto
(Ver {Tareas de Escritorio e Idioma}#desktop-and-language-tasks). Ahora
vamos a poner las piezas juntas:

code{

 $ mkdir live-pt_BR-kde
 $ cd live-pt_BR-kde
 $ lb config \
     -a i386 \
     -k 486 \
     --bootappend-live "locales=pt_BR.UTF-8 keyboard-layouts=pt-latin1" \
     --debian-installer live
 $ echo kde-desktop brazilian-portuguese brazilian-portuguese-desktop \
     brazilian-portuguese-kde-desktop >> config/task-lists/my.list.chroot
 $ echo debian-installer-launcher >> config/package-lists/my.list.chroot
 $ echo tasksel tasksel/desktop multiselect kde >> config/preseed/my.preseed.chroot

}code

Tener en cuenta que se ha incluido el paquete #{debian-installer-launcher}#
para lanzar el instalador desde el escritorio en vivo, y que también se ha
especificado el kernel 486, ya que actualmente es necesario que el
instalador y el kernel del sistema en vivo coincidan para que el lanzador
funcione correctamente.
