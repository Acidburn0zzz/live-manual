:B~ Ejemplos

1~examples Ejemplos

Este capítulo ofrece ejemplos de creación de imágenes para casos de uso
específicos de Debian Live. Si se es nuevo en la creación de una imagen
propia de Debian Live, se recomienda leer primero los tres tutoriales en
secuencia, ya que cada uno enseña nuevas técnicas que ayudan a utilizar y
entender los ejemplos restantes.

2~using-the-examples Uso de los ejemplos

Para poder seguir estos ejemplos es necesario un sistema donde crearlos que
cumpla con los requisitos enumerados en {Requisitos}#requirements y tener
live-build instalado tal y como se describe en {Instalación de
live-build}#installing-live-build.

Hay que tener en cuenta que, para abreviar, en estos ejemplos no se
especifica una réplica local para la creación de la imagen.  Es posible
acelerar las descargas considerablemente si se utiliza una réplica local. Se
puede especificar las opciones cuando se usa #{lb config}#, tal y como se
describe en {Réplicas de Distribution utilizadas durante la
creación}#distribution-mirrors-build-time,  o para más comodidad, establecer
el valor por defecto para la creación del sistema en
#{/etc/live/build.conf}#. Basta con crear este fichero y en el mismo,
establecer las variables #{LB_MIRROR_*}# correspondientes a la réplica
preferida. Todas las demás réplicas usadas en el proceso de creación usarán
estos valores por defecto. Por ejemplo:

code{

 LB_MIRROR_BOOTSTRAP="http://mirror/debian"
 LB_MIRROR_CHROOT_SECURITY="http://mirror/debian-security"
 LB_MIRROR_CHROOT_BACKPORTS="http://mirror/debian-updates"

}code

2~tutorial-1 Tutorial 1: Una imagen estándar

*{Caso práctico:}* Crear una primera imagen sencilla, aprendiendo los fundamentos de live-build.

En este tutorial, vamos a construir una imagen ISO hybrid por defecto de
Debian Live que contenga únicamente los paquetes base (sin Xorg) y algunos
paquetes de soporte Debian Live, como un primer ejercicio en el uso de
live-build.

No puede ser más fácil que esto:

code{

 $ mkdir tutorial1 ; cd tutorial1 ; lb config

}code

Si se examina el contenido del directorio #{config/}# se verá almacenada
allí una configuración en esqueleto preparada para ser personalizada o en
este caso para ser usada inmediatamente para construir una imagen por
defecto.

Ahora, como superusuario, crear la imagen, guardando un log con #{tee}#
mientras se crea.

code{

 # lb build 2>&1 | tee build.log

}code

Suponiendo que todo va bien, después de un rato, el directorio actual
contendrá #{binary.hybrid.iso}#. Esta imagen ISO híbrida se puede arrancar
directamente en una máquina virtual como se describe en {Probar una imagen
ISO con Qemu}#testing-iso-with-qemu y en {Probar una imagen ISO con
virtualbox-ose}#testing-iso-with-virtualbox o bien ser copiada a un medio
óptico como un dispositivo USB tal y como se describe en {Grabar una imagen
ISO en un medio físico}#burning-iso-image y {Copiar una imagen ISO híbrida
en un dispositivo USB}#copying-iso-hybrid-to-usb, respectivamente.

2~tutorial-2 Tutorial 2: Una utilidad de navegador web

*{Caso práctico:}* Crear una utilidad de navegador web, aprendiendo a aplicar personalizaciones.

En este tutorial, se creará una imagen adecuada para su uso como utilidad de
navegador web, esto sirve como introducción a la personalización de las
imágenes de Debian Live.

code{

 $ mkdir tutorial2
 $ cd tutorial2
 $ echo "task-lxde-desktop iceweasel" >> config/package-lists/my.list.chroot

}code

La elección de LXDE para este ejemplo refleja el deseo de ofrecer un entorno
de escritorio mínimo, ya que el enfoque de la imagen es el uso individual
que se tiene en mente, el navegador web. Se podría ir aún más lejos y
ofrecer una configuración por defecto para el navegador web en
#{config/includes.chroot/etc/iceweasel/profile/}#, o paquetes adicionales de
soporte para la visualización de diversos tipos de contenido web, pero se
deja esto como un ejercicio para el lector.

Crear la imagen, de nuevo como superusuario, guardando un log como en el
{Tutorial 1}#tutorial-1:

code{

 # lb build 2>&1 | tee build.log

}code

De nuevo, verificar que la imagen está bien y probarla igual que en el
{Tutorial 1}#tutorial-1.

2~tutorial-3 Tutorial 3: Una imagen personalizada

*{Caso práctico:}* Crear un proyecto para conseguir una imagen personalizada, que contenga el software favorito para llevárselo en una memoria USB donde quiera que se vaya, y hacerlo evolucionar en revisiones sucesivas, tal y como vayan cambiando las necesidades y preferencias.

Como nuestra imagen personalizada irá cambiando durante un número de
revisiones, si se quiere ir siguiendo esos cambios, probar nuevas cosas de
forma experimental y posiblemente volver atrás si no salen bien, se guardará
la configuración en el popular sistema de control de versiones
#{git}#. También se utilizarán las mejores prácticas de configuración
automática a través de scripts #{auto}# como se describe en {Gestionar una
configuración}#managing-a-configuration.

3~ Primera revisión

code{

 $ mkdir -p tutorial3/auto
 $ cp /usr/share/doc/live-build/examples/auto/* tutorial3/auto/
 $ cd tutorial3

}code

Editar #{auto/config}# del siguiente modo:

code{

 #!/bin/sh

 lb config noauto \
     --architectures i386 \
     --linux-flavours 686-pae \
     "${@}"

}code

Ejecutar #{lb config}# para generar el árbol de configuración, utilizando el
script #{auto/config}# que justo se acaba de crear:

code{

 $ lb config

}code

Completar la lista de paquetes local:

code{

 $ echo "task-lxde-desktop iceweasel xchat" >> config/package-lists/my.list.chroot

}code

En primer lugar con #{--architectures i386}# se asegura de que en un sistema
de creación #{amd64}# se crea una versión de 32-bits adecuada para ser usada
en la mayoría de máquinas. En segundo lugar, se usa #{--linux-flavours
686-pae}# porque no se espera usar esta imagen en sistemas mucho más
viejos. En tercer lugar se elige el metapaquete /{lxde}/ para proporcionar
un escritorio mínimo. Y, por último, se añaden dos paquetes iniciales
favoritos: /{iceweasel}/ y /{xchat}/.

Ahora, crear la imagen:

code{

 # lb build

}code

Tener en cuenta que a diferencia de los dos primeros tutoriales, ya no se
tiene que escribir #{2>&1 | tee build.log}# ya que esto se incluye ahora en
#{auto/build}#.

Una vez que se ha probado la imagen (como en el {Tutorial 1}#tutorial-1) y
se ha asegurado de que funciona, es el momento de iniciar el repositorio
git, añadiendo sólo los scripts auto que se acaba de crear, y luego hacer el
primer commit:

code{

 $ git init
 $ git add auto
 $ git commit -a -m "Initial import."

}code

3~ Segunda revisión

En esta revisión, vamos a limpiar desde la primera creación, agregar el
paquete /{vlc}/ a nuestra configuración, crear de nuevo, probar y enviar los
cambios al git.

El comando #{lb clean}# limpiará todos los ficheros generados en las
primeras creaciones a excepción del caché, lo cual ahorra tener que volver a
descargar de nuevo los paquetes. Esto asegura que el siguiente #{lb build}#
vuelva a ejecutar todas las fases para regenerar los ficheros de nuestra
nueva configuración.

code{

 # lb clean

}code

Añadir ahora el paquete /{vlc}/ a nuestra lista de paquetes local en
#{config/package-lists/my.list.chroot}#:

code{

  $ echo vlc >> config/package-lists/my.list.chroot

}code

Crear de nuevo:

code{

# lb build

}code

Probar, y cuando se esté satisfecho, enviar la próxima revisión al git:

code{

 $ git commit -a -m "Adding vlc media player."

}code

Por supuesto, es posible hacer cambios más complicados en la configuración,
tal vez añadiendo ficheros en los subdirectorios de #{config/}#. Cuando se
envian nuevas revisiones, hay que tener cuidado de no editar a mano o enviar
los ficheros del nivel superior en #{config}# que contienen variables
#{LB_*}# ya que estos son productos de creación también y son siempre
limpiados por #{lb clean}# y recreados con #{lb config}# a través de sus
respectivos scripts #{auto}#.

Hemos llegado al final de nuestra serie de tutoriales. Si bien son posibles
muchos más tipos de personalización, aunque sólo sea con las pocas
características explicadas en estos sencillos ejemplos, se puede crear una
variedad casi infinita de imágenes diferentes. Los ejemplos que quedan en
esta sección abarcan varios casos de usos diferentes procedentes de las
experiencias recogidas de los usuarios de Debian Live.

2~ Un cliente VNC kiosk

*{Caso Práctico:}* Crear una imagen con live-build para arrancar directamente un servidor VNC.

Make a build directory and create an skeletal configuration inside it,
disabling recommends to make a minimal system. And then create two initial
package lists: the first one generated with a script provided by live-build
named #{Packages}# (see {Generated package lists}#generated-package-lists),
and the second one including /{xorg}/, /{gdm3}/, /{metacity}/ and
/{xvnc4viewer}/.

code{

 $ mkdir vnc_kiosk_client
 $ cd vnc_kiosk_client
 $ lb config -a i386 -k 686-pae --apt-recommends false
 $ echo '! Packages Priority standard' > config/package-lists/standard.list.chroot
 $ echo "xorg gdm3 metacity xvnc4viewer" > config/package-lists/my.list.chroot

}code

As explained in {Tweaking APT to save space}#tweaking-apt-to-save-space you
may need to re-add some recommended packages to make your image work
properly.

An easy way to list recommends is using /{apt-cache}/. For example:

code{

 $ apt-cache depends live-config live-boot

}code

In this example we found out that we had to re-include several packages
recommended by live-config and live-boot: #{user-setup}# to make autologin
work and #{sudo}# as an essential program to shutdown the system. Besides,
it could be handy to add #{live-tools}# to be able to copy the image to RAM
and #{eject}# to eventually eject the live media, So:

code{

$ echo "live-tools user-setup sudo eject" >
config/package-lists/recommends.list.chroot

}code

Crear el directorio #{/etc/skel}# en #{config/includes.chroot}# y poner
dentro un fichero #{.xsession}# personalizado para el usuario que por
defecto ejecutará /{metacity}/ e iniciará el /{xvncviewer}/, conectándo al
puerto #{5901}# de un servidor en #{192.168.1.2}#:

code{

 $ mkdir -p config/includes.chroot/etc/skel
 $ cat > config/includes.chroot/etc/skel/.xsession << END
 #!/bin/sh

 /usr/bin/metacity &
 /usr/bin/xvncviewer 192.168.1.2:1

 exit
 END

}code

Crear la imagen:

code{

 # lb build

}code

Disfrutarlo.

2~ Una imagen básica para un pendrive USB de 128M

*{Caso Práctico:}* Crear una imagen estándar quitando algunos componentes para que quepa en un pendrive USB de 128M dejándo un poco de espacio libre para poder usarlo para lo que se quiera.

Al optimizar una imagen para adaptarla al tamaño de algunos medios de
almacenamiento, es necesario comprender el equilibrio que se está haciendo
entre tamaño y funcionalidad. En este ejemplo, se recorta tanto sólo para
dar cabida a material adicional dentro de un tamaño de 128M, pero sin hacer
nada para destruir la integridad de los paquetes que contiene, tales como la
depuración de las variantes locales a través del paquete /{localepurge}/ u
otro tipo de optimizaciones «intrusivas». Cabe destacar que para entender lo
que hace el script gancho #{minimal.chroot}# se debería mirar en
#{/usr/share/doc/live-build/examples/hooks}#

code{

 $ lb config -k 486 --apt-indices false --apt-recommends false --memtest none
 $ cp /usr/share/doc/live-build/examples/hooks/minimal.chroot config/hooks

}code

To make the image work properly, we must re-add, at least, two recommended
packages which are left out by the #{--apt-recommends false}# option. See
{Tweaking APT to save space}#tweaking-apt-to-save-space

code{

 $ echo "user-setup sudo" > config/package-lists/recommends.list.chroot

}code

Ahora, crear la imagen de forma habitual:

code{

 # lb build 2>&1 | tee build.log

}code

En el sistema del autor, en el momento de escribir esto, la configuración
anterior produjo una imagen de 95Mbytes. Esto se compara favorablemente en
tamaño con la imagen de 182Mbytes producida por la configuración por defecto
en el {Tutorial 1}#tutorial-1.

The biggest space-saver here, compared to building a standard image on an
#{i386}# architecture system, is to select only the #{486}# kernel flavour
instead of the default #{-k "486 686-pae"}#. Leaving off APT's indices with
#{--apt-indices false}# also saves a fair amount of space, the tradeoff
being that you need to #{apt-get update}# before using apt in the live
system. Dropping recommended packages with #{--apt-recommends false}# saves
some additional space, at the expense of omitting some packages you might
otherwise expect to be there, such as /{firmware-linux-free}/ which may be
needed to support certain hardware. #{--memtest none}# prevents the
installation of a memory tester. And finally, the execution of the
#{minimal.chroot}# hook removes some unused packages and files.

Si se utilizan otros scripts gancho, como por ejemplo el script
#{stripped.chroot}# que se encuentra en
#{/usr/share/doc/live-build/examples/hooks}#,  se puede reducir aún más el
tamaño de la imagen hasta 76MB. Pero es necesario decidir si vale la pena la
funcionalidad que se sacrifica con cada optimización del tamaño.

2~ Un escritorio KDE con variante local e instalador

*{Caso práctico:}* Crear una imagen del escritorio KDE, con la variante local Portugués de Brasil con instalador incluido.

Se desea crear una imagen iso-hybrid para la arquitectura i386 con un
escritorio preferido, en este caso el KDE, que contiene todos los mismos
paquetes que serían instalados por el programa de instalación estándar de
Debian para KDE.

El primer problema es descubrir los nombres de las tareas adecuadas. En la
actualidad, live-build no puede ayudar en esto. Aunque podríamos tener
suerte y encontrarlos a base de pruebas, hay una herramienta,
#{grep-dctrl}#, para extraerlos de las descripciones de tareas en
tasksel-data, para proceder, asegurarse de tener ambas cosas:

code{

  # apt-get install dctrl-tools tasksel-data

}code

Ahora podemos buscar las tareas apropiadas, primero con:

code{

 $ grep-dctrl -FTest-lang pt_BR /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: brazilian-portuguese

}code

Con este comando, se descubre que la tarea se llama, sencillamente,
brazilian-portuguese. Ahora para encontrar las tareas relacionas: 

code{

 $ grep-dctrl -FEnhances brazilian-portuguese /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: brazilian-portuguese-desktop
 Task: brazilian-portuguese-kde-desktop

}code

At boot time we will generate the pt_BR.UTF-8 locale and select the
pt-latin1 keyboard layout. Now let's put the pieces together. Recalling from
{Using metapackages}#using-metapackages that task metapackages are prefixed
#{task-}#, we just specify these language boot parameters, then add standard
priority packages and all our discovered task metapackages to our package
list as follows:

code{

 $ mkdir live-pt_BR-kde
 $ cd live-pt_BR-kde
 $ lb config \
     -a i386 \
     -k 486 \
     --bootappend-live "locales=pt_BR.UTF-8 keyboard-layouts=pt-latin1" \
     --debian-installer live
 $ echo '! Packages Priority standard' > config/package-lists/standard.list.chroot
 $ echo task-kde-desktop task-brazilian-portuguese task-brazilian-portuguese-desktop \
     task-brazilian-portuguese-kde-desktop >> config/package-lists/desktop.list.chroot
 $ echo debian-installer-launcher >> config/package-lists/installer.list.chroot

}code

Tener en cuenta que se ha incluido el paquete debian-installer-launcher para
lanzar el instalador desde el escritorio en vivo, y que también se ha
especificado el kernel 486, ya que actualmente es necesario que el
instalador y el kernel del sistema en vivo coincidan para que el lanzador
funcione correctamente.
