:B~ Conceptos básicos

1~the-basics Conceptos básicos

This chapter contains a brief overview of the build process and instructions
for using the three most commonly used image types. The most versatile image
type, #{iso-hybrid}#, may be used on a virtual machine, optical media or USB
portable storage device. In certain special cases, such as the use of
persistence, #{usb-hdd}# may be more suitable for USB devices. The chapter
finishes with instructions for building and using a #{net}# type image,
which is a bit more involved due to the setup required on the server. This
is a slightly advanced topic for anyone who is not familiar already with
netbooting, but is included here because once the setup is done, it is a
very convenient way to test and deploy images for booting on the local
network without the hassle of dealing with image media.

2~ ¿Qué es un sistema en vivo?

Por lo general, un sistema en vivo se refiere a un sistema operativo que
arranca en un equipo desde un medio extraíble, como un CD-ROM, dispositivo
USB, o desde una red, listo para usar sin ningún tipo de instalación en la
unidad de costumbre, con configuración automática en tiempo de ejecución
(Ver {Términos}#terms).

Debian Live, es un sistema Debian GNU/Linux, creado para una de las
arquitecturas soportadas (actualmente amd64, i386, PowerPC y SPARC). Se
compone de las siguientes partes:

_* *{Imágen del kernel de Linux}*, normalmente llamada #{vmlinuz*}#

_* *{Imagen del Disco RAM inicial (initrd)}*: Un Disco RAM, que incluya los
módulos de kernel necesarios para montar la imagen del sistema y algunos
scripts para ponerlo en marcha.

_* *{Imagen del sistema}*: La imagen del sistema de ficheros raiz. Por lo
general, se utiliza un sistema de ficheros comprimido SquashFS para reducir
al mínimo el tamaño de la imagen de Debian Live. Hay que tener en cuenta que
es de sólo lectura. Por lo tanto, durante el arranque del sistema Debian
Live se utiliza un disco RAM y un mecanismo de «unión» que permite escribir
ficheros en el sistema en funcionamiento. Sin embargo, todas las
modificaciones se perderán al apagar el equipo a menos que se use de modo
opcional la persistencia (ver {Persistencia}#persistence).

_* *{Gestor de arranque}*: Una pequeña pieza de código diseñada para
arrancar desde el medio de almacenamiento escogido, posiblemente mostrando
un menú o un indicador de arranque para permitir la selección de
opciones/configuración. Carga el kernel de Linux y su initrd para funcionar
con un sistema de ficheros asociado. Se pueden usar soluciones diferentes,
dependiendo del medio de almacenamiento de destino y el formato del sistema
de ficheros que contenga los componentes mencionados anteriormente: isolinux
para arrancar desde un CD o DVD en formato ISO9660, syslinux para arrancar
desde el disco duro o unidad USB desde una partición VFAT, extlinux para
formatos ext2/3/4 y particiones btrfs, pxelinux para arranque de red PXE,
GRUB para particiones ext2/3/4 , etc.

Se puede usar live-build  para crear la imagen del sistema a partir de
ciertas especificaciones, incluir un kernel de Linux, su initrd y un gestor
de arranque para ponerlos en funcionamiento, todo ello en un formato que
depende del medio de almacenamiento elegido (imagen ISO9660, imagen de
disco, etc.)

2~ First steps: building an ISO hybrid image

Regardless of the image type, you will need to perform the same basic steps
to build an image each time. As a first example, execute the following
sequence of live-build commands to create a basic ISO hybrid image
containing just the Debian standard system without X.org. It is suitable for
burning to CD or DVD media, and also to copy onto a USB stick.

First, run the #{lb config}# command. This will create a "config/" hierarchy
in the current directory for use by other commands:

code{

 $ lb config

}code

No parameters are passed to #{lb config}#, so defaults for all of its
various options will be used. See {The lb config command}#lb-config for more
details.

Now that the "config/" hierarchy exists, build the image with the #{lb
build}# command:

code{

 # lb build

}code

This process can take a while, depending on the speed of your network
connection. When it is complete, there should be a #{binary-hybrid.iso}#
image file, ready to use, in the current directory.

2~ Using an ISO hybrid live image

After either building or downloading an ISO hybrid image, which can be
obtained at http://www.debian.org/CD/live/, the usual next step is to
prepare your media for booting, either CD-R(W) or DVD-R(W) optical media or
a USB stick.

3~burning-iso-image Grabar una imagen ISO a un medio físico.

Grabar una imagen ISO es fácil:

code{

 # apt-get install wodim

 $ wodim binary-hybrid.iso

}code

3~copying-iso-hybrid-to-usb Copying an ISO hybrid image to a USB stick

ISO images prepared with the #{isohybrid}# command, like the images produced
by live-build's default #{iso-hybrid}# binary image type, can be copied to a
USB stick and directly booted without further steps. Plug in a USB stick
with a size larger than that of #{binary-hybrid.iso}# and determine which
device it is, which we hereafter refer to as #{${USBSTICK}}#. This is the
device file of your key, such as #{/dev/sdb}#, not a partition, such as
#{/dev/sdb1}#! You can find the right device name by looking in #{dmesg}#'s
output after plugging in the stick, or better yet, #{ls -l
/dev/disk/by-id}#.

*{ATENCIÓN: Esto borrará definitivamente cualquier contenido anterior del dispositivo.}*

Once you are certain you have the correct device name, use the #{dd}#
command to copy the image to the stick as follows:

code{

 $ dd if=binary-hybrid.iso of=${USBSTICK}

}code


3~ Booting the live media

The first time you boot your live media, whether CD, DVD, USB key, or PXE
boot, some setup in your computer's BIOS may be needed first. Since BIOSes
vary greatly in features and key bindings, we cannot get into the topic in
depth here. Some BIOSes provide a key to bring up a menu of boot devices at
boot time, which is the easiest way if it is available on your
system. Otherwise, you need to enter the BIOS configuration menu and change
the boot order to place the boot device for the live system before your
normal boot device.

Once you've booted the media, you are presented with a boot menu. If you
just press enter here, the system will boot using the default entry,
#{Live}# and default options. For more information about boot options, see
the "help" entry in the menu and also the #{live-boot}# and #{live-config}#
man pages found within the live system.

Assuming you've selected #{Live}# and booted a default desktop live image,
after the boot messages scroll by, you should be automatically logged into
the #{user}# account and see a desktop, ready to use. If you've booted a
console-only image, such as #{standard}# or #{rescue}# flavour prebuilt
images, you should be automatically logged in on the console to the #{user}#
account and see a shell prompt, ready to use.

2~ Using a virtual machine for testing

It can be a great time-saver for the development of live images to run them
in a virtual machine (VM). This is not without its caveats:

_* Running a VM requires enough RAM for both the guest OS and the host and a
CPU with hardware support for virtualization is recommended.

_* There are some inherent limitations to running on a VM, e.g. poor video
performance, limited choice of emulated hardware.

_* When developing for specific hardware, there is no substitute for running
on the hardware itself.

_* Occasionally there are bugs that relate only to running in a VM. When in
doubt, test your image directly on the hardware.

Provided you can work within these constraints, survey the available VM
software and choose one that is suitable for your needs.

3~testing-iso-with-qemu Testing an ISO image with QEMU

The most versatile VM in Debian is QEMU. If your processor has hardware
support for virtualization, use the #{qemu-kvm}# package; the #{qemu-kvm}#
package description briefly lists the requirements.

First, install #{qemu-kvm}# if your processor supports it. If not, install
#{qemu}#, in which case the program name is #{qemu}# instead of #{kvm}# in
the following examples. The #{qemu-utils}# package is also valuable for
creating virtual disk images with #{qemu-img}#.

code{

 # apt-get install qemu-kvm qemu-utils

}code

Booting an ISO image is simple:

code{

 $ kvm -cdrom binary-hybrid.iso

}code

See the man pages for more details.

3~testing-iso-with-virtualbox  Probar una imagen ISO con virtualbox-ose

Para probar una imagen ISO con virtualbox-ose:

code{

 # apt-get install virtualbox-ose virtualbox-ose-dkms

 $ virtualbox

}code

Create a new virtual machine, change the storage settings to use
binary-hybrid.iso as the CD/DVD device, and start the machine.

Note: For live systems containing X.org that you want to test with
#{virtualbox-ose}#, you may wish to include the VirtualBox X.org driver
package, #{virtualbox-ose-guest-x11}#, in your live-build
configuration. Otherwise, the resolution is limited to 800x600.

code{

 $ lb config --packages virtualbox-ose-guest-x11

}code

2~ Crear una imagen USB/HDD

La siguiente secuencia de comandos creará una imagen USB/HDD básica que
contendrá sólo el sistema estándar de Debian sin X.org. Es adecuada para el
arranque desde dispositivos USB, discos duros USB y otros dispositivos de
almacenamiento portátil. Normalmente, se puede utilizar para este propósito
una imagen ISO híbrida, pero es posible que la BIOS que no maneje
adecuadamente las imágenes híbridas. También es interesante una imagen
USB/HDD si se desea utilizar el espacio restante en los medios de
almacenamiento para una partición con persistencia.

Nota: si se ha creado una imagen ISO con el ejemplo anterior, se tendrá que
limpiar el directorio de trabajo con el comando #{lb clean}# (ver el comando
lb clean}#lb-clean):

code{

 # lb clean --binary

}code

Ejecutar el comando #{lb config}# con los parámetros para configurar la
jerarquía #{config/}# para crear una imágen USB/HDD:

code{

 $ lb config -b usb-hdd

}code

Crear ahora la imagen con el comando #{lb build}#:

code{

 # lb build

}code

3~copying-usb-hdd-image Copiar una imagen USB/HDD a un dispositivo USB

% FIXME: eliminate duplication with ISO hybrid, as these are virtually the
same instructions!

La imagen binaria generada contiene una partición VFAT y el gestor de
arranque syslinux, lista para ser copiada directamente en un dispositivo
USB. Conecte una memoria USB de tamaño mayor que el del fichero binary.img y
teclee:

code{

 $ dd if=binary.img of=${USBSTICK}

}code

Siendo #{${USBSTICK}}# la ubicación del dispositivo, como #{/dev/sdb}#
(ATENCIÓN: no es una partición como #{/dev/sdb1}# sino todo el dispositivo
completo). Una vez conectado el dispositivo, se puede encontrar su nombre
correcto utilizando mediante la orden #{dmesg}#, o incluso mejor mediante la
orden #{ls -l /dev/disk/by-id}#.

*{ATENCIÓN: Esto borrará definitivamente cualquier contenido anterior del dispositivo.}*

Nota: Como se mencionó anteriormente, este mismo proceso se puede utilizar
para imágenes #{iso-hybrid}# (con sufijo #{-hybrid.iso}#), pero no imágenes
tipo #{iso}#.

3~testing-usb-hdd-with-qemu Probar una imágen USB/HDD con Qemu

code{

 # apt-get install qemu

 $ qemu -hda binary.img

}code

3~ Cómo usar el espacio que queda libre en el dispositivo USB

Si se desea usar el espacio libre después de haber instalado la imagen
binary.img, se puede usar un programa de particionado como #{gparted}# o
#{parted}# para crear una partición nueva en el dispositivo. La primera
partición será usada por el sistema Debian en vivo.

code{

 # gparted ${USBSTICK}

}code

Después de la creación de la partición, siendo #{${PARTITION}}# el nombre de
la partición (por ejemplo #{/dev/sdb2}# ),se tiene que crear un sistema de
ficheros en él. Una opción posible sería ext4.

code{

 # mkfs.ext4 ${PARTITION}

}code

Si se desea usar los datos de esta partición con Windows, usar FAT32.

code{

 # mkfs.vfat -F 32

}code

*{Recordar: Cada vez que se instale una nueva binary.img en el dispositivo, todos los datos del dispositivo se perderán debido a que la tabla de particiones se sobrescribe con el contenido de la imagen.}*

2~building-netboot-image Creación de una imagen de arranque en red

La siguiente secuencia de comandos creará una imagen de arranque en red
básica que contendrá el sistema estándar de Debian sin X.org. Se puede usar
para el arranque en red.

Nota: si se ha seguido algúno de los ejemplos anteriores, se tendrá que
limpiar el directorio de trabajo con el comando #{lb clean}#:

code{

 # lb clean --binary

}code

Ejecute el comando #{lb config}# de la siguiente manera para configurar la
imagen de arranque en red:

code{

 $ lb config -b net --net-root-path "/srv/debian-live" --net-root-server "192.168.0.1"

}code

A diferencia de las imágenes ISO y USB/HDD, el sistema de arranque en red en
sí mismo no envía la imagen del sistema de ficheros al cliente, por eso los
ficheros se deben enviar mediante NFS. Las opciones #{--net-root-path}# y
#{--net-root-server}# especifican la ubicación y el servidor,
respectivamente, del servidor NFS en el que se encuentra la imagen del
sistema de ficheros en el arranque. Se debe asegurar que estos se ajustan a
los valores adecuados para la red y el servidor deseados.

Crear ahora la imagen con el comando #{lb build}#:

code{

 # lb build

}code

En un arranque en red, el cliente ejecuta una pequeña pieza de software que
generalmente se encuentra en la EPROM de la tarjeta Ethernet. Este programa
envía una solicitud de DHCP para obtener una dirección IP e información
sobre qué hacer a continuación. Por lo general, el siguiente paso es
conseguir un gestor de arranque de alto nivel a través del protocolo
TFTP. Este gestor podría ser PXELINUX, GRUB, o incluso arrancar directamente
un sistema operativo como Linux.

Por ejemplo, si se descomprime el archivo generado #{binary-net.tar.gz}# en
el directorio #{/srv/debian-live}#, se verá la imagen del sistema de
ficheros en #{live/filesystem.squashfs}# y el kernel, initrd y el gestor de
arranque pxelinux en #{tftpboot/debian-live/i386}#.

Ahora se debe configurar tres servicios en el servidor para que arranque en
red: el servidor DHCP, el servidor TFTP y el servidor NFS.

3~ Servidor DHCP

Hay que configurar el servidor DHCP de la red para asegurar que proporciona
una dirección IP al cliente, y para anunciar la ubicación del gestor de
arranque PXE.

He aquí un ejemplo que puede servir de inspiración. Fue escrito para el
servidor ISC DHCP #{isc-dhcp-server}# en su fichero de configuración
#{/etc/dhcp/dhcpd.conf}#:

code{

 # /etc/dhcp/dhcpd.conf - fichero de configuración para isc-dhcp-server

 ddns-update-style none;

 option domain-name "example.org";
 option domain-name-servers ns1.example.org, ns2.example.org;

 default-lease-time 600;
 max-lease-time 7200;

 log-facility local7;

 subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.1 192.168.0.254;
   next-server servername;
   filename "pxelinux.0";
}

}code

3~ Servidor TFTP

Se encarga de suministrar el kernel y el Disco RAM inicial para el sistema.

Se debe instalar el paquete tftpd-hpa. Este servidor podrá suministrar todos
los ficheros contenidos de un directorio raíz, normalmente
#{/srv/tftp}#. Para permitirle que pueda servir los ficheros de
#{/srv/debian-live/tftpboot}#, se debe ejecutar  el siguiente comando con
privilegios de superusuario:

code{

 # dpkg-reconfigure -plow tftpd-hpa

}code

y llenar el directorio del nuevo servidor tftp cuando sea requerido.

3~ Servidor NFS 

Una vez el equipo cliente ha descargado y arrancado el kernel de Linux junto
a su initrd, intentará montar el sistema de archivos de la imagen en vivo a
través de un servidor NFS.

Se debe instalar el paquete #{nfs-kernel-server}#.

Entonces, se debe hacer que la imagen del sistema de archivos esté
disponible a través de NFS añadiendo una línea como la siguiente para
#{/etc/exports}#:

code{

 /srv/debian-live *(ro,async,no_root_squash,no_subtree_check)

}code

e informar al servidor NFS sobre esta nueva exportación con el siguiente
comando:

code{

 # exportfs -rv

}code

La configuración de estos tres servicios puede ser un poco difícil. Será
necesario un poco de paciencia para conseguir que todos ellos funcionen
juntos. Para obtener más información, ver el wiki de syslinux en
http://syslinux.zytor.com/wiki/index.php/PXELINUX o la sección sobre TFTP
Net Booting del Manual del Instalador de Debian en
http://d-i.alioth.debian.org/manual/en.i386/ch04s05.html Esto puede ser
útil, ya que sus procesos son muy similares.

3~ Cómo probar el arranque en red

La creación de una imagen de arranque en red es fácil usando la mágia de
live-build, pero probar las imágenes en máquinas físicas puede ser un
proceso mucho más lento.

Para hacer nuestra vida más fácil, se puede utilizar la virtualización. Hay
dos soluciones.

3~ Qemu

_* Install #{qemu}#, #{bridge-utils}#, #{sudo}#.

Se debe editar el fichero #{/etc/qemu-ifup}#:

code{

 #!/bin/sh
 sudo -p "Password for $0:" /sbin/ifconfig $1 172.20.0.1
 echo "Executing /etc/qemu-ifup"
 echo "Bringing up $1 for bridged mode..."
 sudo /sbin/ifconfig $1 0.0.0.0 promisc up
 echo "Adding $1 to br0..."
 sudo /usr/sbin/brctl addif br0 $1
 sleep 2

}code

Obtener o crear un #{grub-floppy-netboot}# (en el svn).

Lanzar #{qemu}# con "#{-net nic,vlan=0 -net tap,vlan=0,ifname=tun0}#"

3~ VMWare Player

_* Instalar VMWare Player (Edición gratuita "free as in beer")

_* Crear un directorio PXETester y crear un fichero de texto dentro llamado
#{pxe.vwx}#

_* Copiar este texto dentro:

code{

 #!/usr/bin/vmware
 config.version = "8"
 virtualHW.version = "4"
 memsize = "512"
 MemAllowAutoScaleDown = "FALSE"

 ide0:0.present = "FALSE"
 ide1:0.present = "FALSE"
 floppy0.present = "FALSE"
 sound.present = "FALSE"
 tools.remindInstall = "FALSE"

 ethernet0.present = "TRUE"
 ethernet0.addressType = "generated"

 displayName = "Test Boot PXE"
 guestOS = "other"

 ethernet0.generatedAddress = "00:0c:29:8d:71:3b"
 uuid.location = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
 uuid.bios = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
 ethernet0.generatedAddressOffset = "0"

}code

_* Se pueden realizar pruebas con este fichero de configuración
(p.ej. cambiar el limite de memoria a 256)

_* Hacer doble clic en este fichero (o lanzar VMWare player y seleccionar
este fichero).

_* Mientras esté en ejecución solo hay que  pulsar espacio si surge esa
extraña pregunta...
