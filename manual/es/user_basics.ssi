:B~ Conceptos básicos

1~the-basics Conceptos básicos

Este capítulo contiene una breve descripción del proceso de creación de las
imágenes en vivo y las instrucciones para el uso de los tres tipos de
imágenes más utilizadas. El tipo de imagen más versátil, #{iso-hybrid}#, se
puede utilizar en una máquina virtual, en medios ópticos u otros dispositivo
de almacenamiento USB. En ciertos casos especiales, como para el uso de la
persistencia («persistence» N. del T.) las imágenes #{usb-hdd}#, pueden ser
las más adecuadas para dispositivos USB. El capítulo termina con
instrucciones para crear y usar una imagen de tipo #{red}#, que es un poco
más complicado debido a la configuración necesaria en el servidor. Es un
tema ligeramente avanzado para cualquier persona que no esté familiarizada
con el arranque en red, pero se incluye aquí porque una vez que se realiza
la instalación, es una forma muy conveniente para probar y desplegar
imágenes de arranque en red local sin la molestia de tratar con los
dispositivos de almacenamiento de la imagen.

2~what-is-live ¿Qué es un sistema en vivo?

Por lo general, un sistema en vivo se refiere a un sistema operativo que
arranca en un equipo desde un medio extraíble, como un CD-ROM, dispositivo
USB, o desde una red, listo para usar sin ningún tipo de instalación en la
unidad de costumbre, con configuración automática en tiempo de ejecución
(Ver {Términos}#terms).

Debian Live, es un sistema Debian GNU/Linux, creado para una de las
arquitecturas soportadas (actualmente amd64, i386, powerpc y sparc). Se
compone de las siguientes partes:

_* *{Imágen del kernel de Linux}*, normalmente llamada #{vmlinuz*}#

_* *{Imagen del Disco RAM inicial (initrd)}*: Un Disco RAM configurado para
el arranque de Linux, que incluya los módulos posiblemente necesarios para
montar la imagen del sistema y algunos scripts para ponerlo en marcha.

_* *{Imagen del sistema}*: La imagen del sistema de ficheros raiz. Por lo
general, se utiliza un sistema de ficheros comprimido SquashFS para reducir
al mínimo el tamaño de la imagen de Debian Live. Hay que tener en cuenta que
es de sólo lectura. Por lo tanto, durante el arranque del sistema Debian
Live se utiliza un disco RAM y un mecanismo de «unión» que permite escribir
ficheros en el sistema en funcionamiento. Sin embargo, todas las
modificaciones se perderán al apagar el equipo a menos que se use de modo
opcional la persistencia (ver {Persistencia}#persistence).

_* *{Gestor de arranque}*: Una pequeña pieza de código diseñada para
arrancar desde el medio de almacenamiento escogido, posiblemente mostrando
un menú o un indicador de arranque para permitir la selección de
opciones/configuración. Carga el kernel de Linux y su initrd para funcionar
con un sistema de ficheros asociado. Se pueden usar soluciones diferentes,
dependiendo del medio de almacenamiento de destino y el formato del sistema
de ficheros que contenga los componentes mencionados anteriormente: isolinux
para arrancar desde un CD o DVD en formato ISO9660, syslinux para arrancar
desde el disco duro o unidad USB desde una partición VFAT, extlinux para
formatos ext2/3/4 y particiones btrfs, pxelinux para arranque de red PXE,
GRUB para particiones ext2/3/4 , etc.

Se puede usar live-build  para crear la imagen del sistema a partir de
ciertas especificaciones, incluir un kernel de Linux, su initrd y un gestor
de arranque para ponerlos en funcionamiento, todo ello en un formato que
depende del medio de almacenamiento elegido (imagen ISO9660, imagen de
disco, etc.)

2~building-iso-hybrid Primeros pasos: creación de una imagen ISO híbrida

Independientemente del tipo de imagen, cada vez se tendrá que realizar los
mismos pasos básicos para construir una imagen. Como primer ejemplo ejecutar
la siguiente secuencia de comandos live-build para crear una imagen ISO
híbrida básica que contiene sólo el sistema estándar de Debian sin X.org. Es
adecuada para grabarla en un CD o DVD y también para copiarla en un
dispositivo USB. 

En primer lugar, se ejecuta el comando #{lb config}#. Ésto creará una
jerarquía «config/» en el directorio actual que será usada por otros
comandos:

code{

 $ lb config

}code

Al no pasar ningún parámetro a #{lb config}#, se indica que se quiere
utilizar todas las opciones por defecto. Ver{El comando lb config}#lb-config
para más detalles.

Ahora que existe un jerarquía «config/», se puede crear la imagen con el
comando #{lb build}#:

code{

 # lb build

}code

Este proceso puede llevar un tiempo, dependiendo de la velocidad de la
conexión de red. Cuando haya terminado, debería haber un fichero
#{binary-hybrid.iso}# listo para ser usado en el directorio actual.

2~using-iso-hybrid Usar una imagen ISO híbrida

Después de construir o descargar una imagen ISO híbrida, las cuales se
pueden obtener en http://www.debian.org/CD/live/,  el siguiente paso
habitual es preparar los medios de almacenamieto, ya sean medios ópticos
CD-R(W) o DVD-R(W) o llaves USB.

3~burning-iso-image Grabar una imagen ISO a un medio físico.

Grabar una imagen ISO es fácil:

code{

 # apt-get install wodim

 $ wodim binary-hybrid.iso

}code

 3~copying-iso-hybrid-to-usb Copiar una imagen ISO híbrida a un dispositivo
USB

Las imágenes ISO preparadas con el comando #{isohybrid}#, igual que las
imágenes del tipo #{iso-hybrid}# producidas por defecto, pueden
sencillamente copiarse a una llave USB con #{dd}# o con un programa
equivalente. Conectar una llave USB con un tamaño mayor que el de
#{binary-hybrid.iso}# y determinar qué dispositivo es,(«device» N. del T.)
al cual nos referiremos de ahora en adelante como #{${USBSTICK}}#. Este
nombre de «dispositivo» se refiere a la llave entera o #{/dev/sdb}# y ¡No a
una partición como #{/dev/sdb1}#! Se puede encontrar el nombre del
dispositivo correcto mirando la salida de #{dmesg}# después de conectar la
llave, o mejor aún ejecutando #{ls -l /dev/disk/by-id}#.

Cuando se esté seguro de tener el nombre del dispositivo correcto, usar el
comando #{dd}# para copiar la imagen a la llave. *{¡Ésto borrará de forma
definitiva cualquier contenido previo en la llave!}*

code{

$ dd if=binary-hybrid.iso of=${USBSTICK}

}code


3~booting-live-media Arrancar los medios en vivo

La primera vez que se arranque desde los medios de almacenamiento en vivo,
ya sea CD, DVD, llave USB, o de arranque en red PXE, primero puede ser
necesario algún tipo de configuración en la BIOS de la máquina. Dado que las
BIOS varían mucho en sus características y combinaciones de teclas, no se
puede entrar en el tema en profundidad aquí. Algunas BIOS proporcionan un
tecla para abrir un menú de dispositivos de arranque que es la manera más
fácil de hacerlo si se encuentra disponible en el sistema.

Una vez que se haya arrancado desde los medios de almacenamiento externos,
se accede a un menú de arranque. Si se pulsa la tecla «enter»,  el sistema
arrancará usando el modo por defecto #{Live}# y las opciones
predeterminadas. Para obtener más información acerca de las opciones de
arranque, ver la opción  «help» del menú y también las páginas del manual de
#{live-boot}# y #{live-config}# que se encuentran en el sistema en vivo.

Suponiendo que se ha seleccionado #{Live}# y arrancado una imagen en vivo
por defecto con escritorio gráfico, después de que los mensajes de arranque
hayan pasado, se habrá iniciado automáticamente una sesión como usuario
#{user}# y se verá el escritorio preparado para ser usado. Si se ha
arrancado una imagen sólo con  consola como por ejemplo las imágenes
predeterminadas #{standard}# o #{rescue}# se habrá iniciado automáticamente
una sesión como usuario #{user}# y se verá el cursor del intérprete de
comandos preparado para ser usado.

2~using-virtual-machine Usar una máquina virtual para pruebas

Ejecutar las imágenes en vivo en una máquina virtual (VM) puede ser un gran
ahorro de tiempo para su desarrollo. Esto no está exento de advertencias:

_* Para ejecutar una máquina virtual se requiere tener suficiente memoria
RAM para el sistema operativo huésped y el anfitrión y se recomienda una CPU
con soporte de hardware para la virtualización.

_* Existen algunas limitaciones inherentes a la ejecución en una máquina
virtual, por ejemplo, rendimiento de video pobre, la limitada gama de
hardware emulado.

_* Cuando se desarrolla para un hardware específico, no hay sustituto mejor
que el propio hardware.

_* A veces hay errores que se refieren únicamente a la ejecución en una
máquina virtual. En caso de duda, probar la imagen directamente en el
hardware.

Siempre que se pueda trabajar dentro de estas limitaciones, mirar que
software VM hay disponible y elegir uno que sea adecuado según las
necesidades.

3~testing-iso-with-qemu Probar una imagen ISO con QEMU

La máquina virtual más versátil en Debian es QEMU. Si el procesador tiene
soporte de hardware para virtualización, utilizar el paquete #{qemu-kvm}#;
en la descripción del paquete #{qemu-kvm}# se enumera brevemente la lista de
requisitos.

En primer lugar, instalar #{qemu-kvm}# si el procesador lo soporta. Si no es
así, instalar #{qemu}#, en cuyo caso el nombre del programa será #{qemu}# en
vez de #{kvm}# en los siguientes ejemplos. El paquete #{qemu-utils}# también
es útil para la creación de imágenes virtuales de disco con #{qemu-img}#.

code{

 # apt-get install qemu-kvm qemu-utils

}code

Arrancar una imagen ISO es sencillo:

code{

 $ kvm -cdrom binary-hybrid.iso

}code

Consultar las páginas del manual para más detalles.

3~testing-iso-with-virtualbox  Probar una imagen ISO con virtualbox-ose

Para probar una imagen ISO con virtualbox-ose:

code{

 # apt-get install virtualbox-ose virtualbox-ose-dkms

 $ virtualbox

}code

Crear una nueva máquina virtual, cambiar la configuración de almacenamiento
para utilizar binary-hybrid.iso como dispositivo CD/DVD y arrancar la
máquina.

Nota: Para probar los sistemas en vivo con soporte X.org en virtualbox-ose,
se puede incluir el paquete del driver de VirtualBox X.org,
#{virtualbox-ose-guest-x11}#, en la configuración de live-build. De lo
contrario, la resolución se limita a 800x600

code{

 $ lb config --packages virtualbox-ose-guest-x11

}code

2~building-usb-hdd Crear una imagen USB/HDD

La siguiente secuencia de comandos creará una imagen USB/HDD básica que
contendrá sólo el sistema estándar de Debian sin X.org. Es adecuada para el
arranque desde dispositivos USB, discos duros USB y otros dispositivos de
almacenamiento portátil. Normalmente, se puede utilizar para este propósito
una imagen ISO hybrid, pero es posible que la BIOS no maneje adecuadamente
las imágenes híbridas. También es interesante una imagen USB/HDD si se desea
utilizar el espacio restante en los medios de almacenamiento para una
partición con persistencia.

Nota: si se ha creado una imagen ISO hybrid con el ejemplo anterior, se
tendrá que limpiar el directorio de trabajo con el comando #{lb clean}# (ver
{El comando lb clean}#lb-clean):

code{

 # lb clean --binary

}code

Ejecutar el comando #{lb config}# como antes pero esta vez especificando el
tipo de imagen USB/HDD:

code{

 $ lb config -b usb-hdd

}code

Crear ahora la imagen con el comando #{lb build}#:

code{

 # lb build

}code

Cuando termine el proceso de creación, debe haber un fichero llamado
#{binary.img}# en el directorio actual .

2~using-usb-hdd-image Utilizar una imágen USB/HDD

La imagen binaria generada contiene una partición VFAT y el gestor de
arranque syslinux, lista para ser copiada directamente en un dispositivo
USB. Dado que utilizar una imagen USB/HDD es igual a usar una imagen ISO
híbrida en un USB, seguir las instrucciones de #{Usar una imagen ISO
hybrid}#using-iso-hybrid con la diferencia de usar el nombre #{binary.img}#
en lugar de #{binary-hybrid.iso}#.

3~testing-usb-hdd-with-qemu Probar una imágen USB/HDD con Qemu

En primer lugar, instalar QEMU como se describe más arriba en #{Probar una
imágen ISO con QEMU}#testing-iso-with-qemu A continuación, ejecutar #{kvm}#
o #{qemu}#, según qué versión necesita el sistema anfitrión y especificando
#{binary.img}# como primer disco duro.

code{

 $ kvm -hda binary.img

}code

3~using-usb-extra-space Usar el espacio libre en el dispositivo USB

Si se desea usar el espacio libre después de haber instalado la imagen
#{binary.img}# en una llave USB, se puede usar un programa de particionado
como #{gparted}# o #{parted}# para crear una partición nueva en el
dispositivo. La primera partición será usada por el sistema Debian en vivo.

code{

 # gparted ${USBSTICK}

}code

Después de crear la partición, dónde #{${PARTITION}}# es el nombre de la
partición, por ejemplo #{/dev/sdb2}# se tiene que crear un sistema de
ficheros en él. Una opción posible sería ext4.

code{

 # mkfs.ext4 ${PARTITION}

}code

Nota: Si se desea usar el espacio extra con Windows, segun parece, ese
sistema operativo no puede acceder normalmente a otra partición más que a la
primera. Se han comentado algunas soluciones a este problema en nuestra
#{lista de correo}#contact pero según parece no hay una solución fácil.

*{Recordar: Cada vez que se instale una nueva binary.img en el dispositivo, todos los datos del dispositivo se perderán debido a que la tabla de particiones se sobrescribe con el contenido de la imagen, así pues, realizar primero una copia de seguridad de la partición para poder restaurarla trás actualizar la imagen en vivo.}*

2~building-netboot-image Creación de una imagen de arranque en red

La siguiente secuencia de comandos creará una imagen de arranque en red
básica que contendrá el sistema estándar de Debian sin X.org. Se puede usar
para el arranque en red.

Nota: si se ha seguido algúno de los ejemplos anteriores, se tendrá que
limpiar el directorio de trabajo con el comando #{lb clean}#:

code{

 # lb clean --binary

}code

Ejecutar el comando #{lb config}# de la siguiente manera para configurar la
imagen de arranque en red:

code{

 $ lb config -b net --net-root-path "/srv/debian-live" --net-root-server "192.168.0.1"

}code

A diferencia de las imágenes ISO y USB/HDD, el sistema de arranque en red en
sí mismo no envía la imagen del sistema de ficheros al cliente, por eso los
ficheros se deben enviar mediante NFS. Las opciones #{--net-root-path}# y
#{--net-root-server}# especifican la ubicación y el servidor,
respectivamente, del servidor NFS en el que se encuentra la imagen del
sistema de ficheros en el arranque. Se debe asegurar que estos se ajustan a
los valores adecuados para la red y el servidor deseados.

Crear ahora la imagen con el comando #{lb build}#:

code{

 # lb build

}code

En un arranque en red, el cliente ejecuta una pequeña pieza de software que
generalmente se encuentra en la EPROM de la tarjeta Ethernet. Este programa
envía una solicitud de DHCP para obtener una dirección IP e información
sobre qué hacer a continuación. Por lo general, el siguiente paso es
conseguir un gestor de arranque de alto nivel a través del protocolo
TFTP. Este gestor podría ser PXELINUX, GRUB, o incluso arrancar directamente
un sistema operativo como Linux.

Por ejemplo, si se descomprime el archivo generado #{binary-net.tar.gz}# en
el directorio #{/srv/debian-live}#, se verá la imagen del sistema de
ficheros en #{live/filesystem.squashfs}# y el kernel, initrd y el gestor de
arranque pxelinux en #{tftpboot/debian-live/i386}#.

Ahora se debe configurar tres servicios en el servidor para que arranque en
red: el servidor DHCP, el servidor TFTP y el servidor NFS.

3~ Servidor DHCP

Hay que configurar el servidor DHCP de red para asegurar que proporciona una
dirección IP al cliente, y para anunciar la ubicación del gestor de arranque
PXE.

He aquí un ejemplo que puede servir de inspiración. Fue escrito para el
servidor ISC DHCP #{isc-dhcp-server}# en su fichero de configuración
#{/etc/dhcp/dhcpd.conf}#:

code{

 # /etc/dhcp/dhcpd.conf - fichero de configuración para isc-dhcp-server

 ddns-update-style none;

 option domain-name "example.org";
 option domain-name-servers ns1.example.org, ns2.example.org;

 default-lease-time 600;
 max-lease-time 7200;

 log-facility local7;

 subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.1 192.168.0.254;
   next-server servername;
   filename "pxelinux.0";
}

}code

3~ Servidor TFTP

Se encarga de suministrar el kernel y el Disco RAM inicial para el sistema.

Se debe instalar el paquete tftpd-hpa. Este servidor podrá suministrar todos
los ficheros contenidos de un directorio raíz, normalmente
#{/srv/tftp}#. Para permitirle que pueda servir los ficheros de
#{/srv/debian-live/tftpboot}#, se debe ejecutar el siguiente comando con
privilegios de superusuario:

code{

 # dpkg-reconfigure -plow tftpd-hpa

}code

y llenar el directorio del nuevo servidor tftp cuando sea requerido.

3~ Servidor NFS 

Una vez el equipo cliente ha descargado y arrancado el kernel de Linux junto
a su initrd, intentará montar el sistema de archivos de la imagen en vivo a
través de un servidor NFS.

Se debe instalar el paquete #{nfs-kernel-server}#.

Entonces, se debe hacer que la imagen del sistema de archivos esté
disponible a través de NFS añadiendo una línea como la siguiente para
#{/etc/exports}#:

code{

 /srv/debian-live *(ro,async,no_root_squash,no_subtree_check)

}code

e informar al servidor NFS sobre esta nueva exportación con el siguiente
comando:

code{

 # exportfs -rv

}code

La configuración de estos tres servicios puede ser un poco difícil. Será
necesario un poco de paciencia para conseguir que todos ellos funcionen
juntos. Para obtener más información, ver el wiki de syslinux en
http://syslinux.zytor.com/wiki/index.php/PXELINUX o la sección sobre TFTP
Net Booting del Manual del Instalador de Debian en
http://d-i.alioth.debian.org/manual/en.i386/ch04s05.html Ésto puede ser
útil, ya que sus procesos son muy similares.

3~ Cómo probar el arranque en red

La creación de una imagen de arranque en red es fácil usando la mágia de
live-build, pero probar las imágenes en máquinas físicas puede ser un
proceso mucho más lento.

Para hacer nuestra vida más fácil, se puede utilizar la virtualización. Hay
dos soluciones.

3~ Qemu

_* Install #{qemu}#, #{bridge-utils}#, #{sudo}#.

Se debe editar el fichero #{/etc/qemu-ifup}#:

code{

 #!/bin/sh
 sudo -p "Password for $0:" /sbin/ifconfig $1 172.20.0.1
 echo "Executing /etc/qemu-ifup"
 echo "Bringing up $1 for bridged mode..."
 sudo /sbin/ifconfig $1 0.0.0.0 promisc up
 echo "Adding $1 to br0..."
 sudo /usr/sbin/brctl addif br0 $1
 sleep 2

}code

Obtener o crear un #{grub-floppy-netboot}# (en el svn).

Lanzar #{qemu}# con "#{-net nic,vlan=0 -net tap,vlan=0,ifname=tun0}#"

3~ VMWare Player

_* Instalar VMWare Player (Edición gratuita «free as in beer»)

_* Crear un directorio PXETester y crear un fichero de texto dentro llamado
#{pxe.vwx}#

_* Copiar este texto dentro:

code{

 #!/usr/bin/vmware
 config.version = "8"
 virtualHW.version = "4"
 memsize = "512"
 MemAllowAutoScaleDown = "FALSE"

 ide0:0.present = "FALSE"
 ide1:0.present = "FALSE"
 floppy0.present = "FALSE"
 sound.present = "FALSE"
 tools.remindInstall = "FALSE"

 ethernet0.present = "TRUE"
 ethernet0.addressType = "generated"

 displayName = "Test Boot PXE"
 guestOS = "other"

 ethernet0.generatedAddress = "00:0c:29:8d:71:3b"
 uuid.location = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
 uuid.bios = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
 ethernet0.generatedAddressOffset = "0"

}code

_* Se pueden realizar pruebas con este fichero de configuración
(p.ej. cambiar el limite de memoria a 256)

_* Hacer doble clic en este fichero (o lanzar VMWare player y seleccionar
este fichero).

_* Mientras esté en ejecución solo hay que pulsar espacio si surge esa
extraña pregunta...
