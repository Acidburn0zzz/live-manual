:B~ Conceptos básicos

1~the-basics Conceptos básicos

This chapter contains a brief overview of the build process and instructions
for using the three most commonly used image types. The most versatile image
type, #{iso-hybrid}#, may be used on a virtual machine, optical media or USB
portable storage device. In certain special cases, as explained later, the
#{hdd}# type may be more suitable. The chapter finishes with instructions
for building and using a #{net}# type image, which is a bit more involved
due to the setup required on the server. This is an slightly advanced topic
for anyone who is not familiar already with netbooting, but it is included
here because once the setup is done, it is a very convenient way to test and
deploy images for booting on the local network without the hassle of dealing
with image media.

A lo largo de todo el capítulo se hace a menudo referencia al nombre de las
imágenes producidas por defecto por live-build. Si se descarga una imagen ya
creada, el nombre puede variar.

2~what-is-live ¿Qué es un sistema en vivo?

Por lo general, un sistema en vivo se refiere a un sistema operativo que
arranca en un equipo desde un medio extraíble, como un CD-ROM, dispositivo
USB, o desde una red, listo para usar sin ningún tipo de instalación en la
unidad de costumbre, con configuración automática en tiempo de ejecución
(Ver {Términos}#terms).

Debian Live, es un sistema Debian GNU/Linux, creado para una de las
arquitecturas soportadas (actualmente amd64, i386, powerpc y sparc). Se
compone de las siguientes partes:

_* *{Imágen del kernel de Linux}*, normalmente llamada #{vmlinuz*}#

_* *{Imagen del Disco RAM inicial (initrd)}*: Un Disco RAM configurado para
el arranque de Linux, que incluya los módulos posiblemente necesarios para
montar la imagen del sistema y algunos scripts para ponerlo en marcha.

_* *{Imagen del sistema}*: La imagen del sistema de ficheros raíz. Por lo
general, se utiliza un sistema de ficheros comprimido SquashFS para reducir
al mínimo el tamaño de la imagen de Debian Live. Hay que tener en cuenta que
es de sólo lectura. Por lo tanto, durante el arranque del sistema Debian
Live se utiliza un disco RAM y un mecanismo de «unión» que permite escribir
ficheros en el sistema en funcionamiento. Sin embargo, todas las
modificaciones se perderán al apagar el equipo a menos que se use de modo
opcional la persistencia (ver {Persistencia}#persistence).

_* *{Gestor de arranque}*: Una pequeña pieza de código diseñada para
arrancar desde el medio de almacenamiento escogido, posiblemente mostrando
un menú o un indicador de arranque para permitir la selección de
opciones/configuración. Carga el kernel de Linux y su initrd para funcionar
con un sistema de ficheros asociado. Se pueden usar soluciones diferentes,
dependiendo del medio de almacenamiento de destino y el formato del sistema
de ficheros que contenga los componentes mencionados anteriormente: isolinux
para arrancar desde un CD o DVD en formato ISO9660, syslinux para arrancar
desde el disco duro o unidad USB desde una partición VFAT, extlinux para
formatos ext2/3/4 y particiones btrfs, pxelinux para arranque de red PXE,
GRUB para particiones ext2/3/4 , etc.

Se puede usar live-build  para crear la imagen del sistema a partir de
ciertas especificaciones, incluir un kernel de Linux, su initrd y un gestor
de arranque para ponerlos en funcionamiento, todo ello en un formato que
depende del medio de almacenamiento elegido (imagen ISO9660, imagen de
disco, etc.)

2~building-iso-hybrid Primeros pasos: creación de una imagen ISO híbrida

Regardless of the image type, you will need to perform the same basic steps
to build an image each time. As a first example, create a build directory,
change to that directory and then execute the following sequence of
live-build commands to create a basic ISO hybrid image containing a default
live system without X.org. It is suitable for burning to CD or DVD media,
and also to copy onto a USB stick.

The name of the working directory is absolutely up to you, but if you take a
look at the examples used throughout live-manual, it is a good idea to use a
name that helps you identify the image you are working with in each
directory, especially if you are working or experimenting with different
image types. In this case you are going to build a default system so let's
call it, for example, live-default.

code{

 $ mkdir live-default && cd live-default

}code

Entonces, se ejecuta el comando #{lb config}#. Esto creará una jerarquía
«config/» en el directorio actual que será usada por otros comandos:

code{

 $ lb config

}code

Al no pasar ningún parámetro a #{lb config}#, se indica que se quiere
utilizar todas las opciones por defecto. Ver{El comando lb config}#lb-config
para más detalles.

Ahora que existe un jerarquía «config/», se puede crear la imagen con el
comando #{lb build}#:

code{

 # lb build

}code

Este proceso puede llevar un tiempo, dependiendo de la velocidad de la
conexión de red. Cuando haya terminado, debería haber un fichero
#{binary.hybrid.iso}# listo para ser usado en el directorio actual.

2~using-iso-hybrid Usar una imagen ISO híbrida

Después de construir o descargar una imagen ISO híbrida, las cuales se
pueden obtener en http://www.debian.org/CD/live/,  el siguiente paso
habitual es preparar los medios de almacenamieto, ya sean medios ópticos
CD-R(W) o DVD-R(W) o llaves USB.

3~burning-iso-image Grabar una imagen ISO en un medio físico.

Grabar una imagen ISO es fácil. Simplemente instalar wodim y usarlo desde el
intérprete de comandos para grabar la imagen. Por ejemplo: 

code{

 # apt-get install wodim

 $ wodim binary.hybrid.iso

}code

3~copying-iso-hybrid-to-usb Copiar una imagen ISO híbrida a un dispositivo
USB

ISO images prepared with #{xorriso}#, can be simply copied to a USB stick
with the #{dd}# program or an equivalent. Plug in a USB stick with a size
large enough for your image file and determine which device it is, which we
hereafter refer to as #{${USBSTICK}}#. This is the device file of your key,
such as #{/dev/sdb}#, not a partition, such as #{/dev/sdb1}#! You can find
the right device name by looking in #{dmesg}#'s output after plugging in the
stick, or better yet, #{ls -l /dev/disk/by-id}#.

Cuando se esté seguro de tener el nombre del dispositivo correcto, usar el
comando #{dd}# para copiar la imagen a la llave. *{¡Esto borrará de forma
definitiva cualquier contenido previo en la llave!}*

code{

 $ dd if=binary.hybrid.iso of=${USBSTICK}

}code

3~using-usb-extra-space Usar el espacio libre en el dispositivo USB

To use the remaining free space after copying #{binary.hybrid.iso}# to a USB
stick, use a partitioning tool such as /{gparted}/ or /{parted}/ to create a
new partition on the stick. The first partition will be used by the Debian
Live system.

code{

 # gparted ${USBSTICK}

}code

Después de crear la partición, dónde #{${PARTITION}}# es el nombre de la
partición, por ejemplo #{/dev/sdb2}# se tiene que crear un sistema de
ficheros en él. Una opción posible sería ext4.

code{

 # mkfs.ext4 ${PARTITION}

}code

*{Nota:}* Si se desea usar el espacio extra con Windows, segun parece, ese sistema operativo no puede acceder normalmente a otra partición más que a la primera. Se han comentado algunas soluciones a este problema en nuestra {lista de correo}#contact pero según parece no hay una solución fácil.

*{Remember: Every time you install a new binary.hybrid.iso on the stick, all data on the stick will be lost because the partition table is overwritten by the contents of the image, so back up your extra partition first to restore again after updating the live image.}*

3~booting-live-media Arrancar los medios en vivo

La primera vez que se arranque desde los medios de almacenamiento en vivo,
ya sea CD, DVD, llave USB, o de arranque en red PXE, primero puede ser
necesario algún tipo de configuración en la BIOS de la máquina. Dado que las
BIOS varían mucho en sus características y combinaciones de teclas, no se
puede entrar en el tema en profundidad aquí. Algunas BIOS proporcionan una
tecla para abrir un menú de dispositivos de arranque que es la manera más
fácil de hacerlo si se encuentra disponible en el sistema.

Una vez que se haya arrancado desde los medios de almacenamiento externos,
se accede a un menú de arranque. Si se pulsa la tecla «enter»,  el sistema
arrancará usando el modo por defecto #{Live}# y las opciones
predeterminadas. Para obtener más información acerca de las opciones de
arranque, ver la opción  «help» del menú y también las páginas del manual de
live-boot y live-config que se encuentran en el sistema en vivo.

Assuming you've selected #{Live}# and booted a default desktop live image,
after the boot messages scroll by, you should be automatically logged into
the #{user}# account and see a desktop, ready to use. If you have booted a
console-only image, such as #{standard}# or #{rescue}# flavour prebuilt
images, you should be automatically logged in on the console to the #{user}#
account and see a shell prompt, ready to use.

2~using-virtual-machine Usar una máquina virtual para pruebas

Ejecutar las imágenes en vivo en una máquina virtual (VM) puede ser un gran
ahorro de tiempo para su desarrollo. Esto no está exento de advertencias:

_* Para ejecutar una máquina virtual se requiere tener suficiente memoria
RAM para el sistema operativo huésped y el anfitrión y se recomienda una CPU
con soporte de hardware para la virtualización.

_* Existen algunas limitaciones inherentes a la ejecución en una máquina
virtual, por ejemplo, rendimiento de video pobre o limitada gama de hardware
emulado.

_* Cuando se desarrolla para un hardware específico, no hay sustituto mejor
que el propio hardware.

_* A veces hay errores causados únicamente por la ejecución en una máquina
virtual. En caso de duda, probar la imagen directamente en el hardware.

Siempre que se pueda trabajar dentro de estas limitaciones, mirar que
software VM hay disponible y elegir uno que sea adecuado según las
necesidades.

3~testing-iso-with-qemu Probar una imagen ISO con QEMU

La máquina virtual más versátil en Debian es QEMU. Si el procesador tiene
soporte de hardware para virtualización, utilizar el paquete
/{qemu-kvm}/. En la descripción del paquete /{qemu-kvm}/ se enumera
brevemente la lista de requisitos.

En primer lugar, instalar #{qemu-kvm}# si el procesador lo soporta. Si no es
así, instalar #{qemu}#, en cuyo caso el nombre del programa será #{qemu}# en
vez de #{kvm}# en los siguientes ejemplos. El paquete /{qemu-utils}/ también
es útil para la creación de imágenes virtuales de disco con #{qemu-img}#.

code{

 # apt-get install qemu-kvm qemu-utils

}code

Arrancar una imagen ISO es sencillo:

code{

 $ kvm -cdrom binary.hybrid.iso

}code

Consultar las páginas del manual para más detalles.

3~testing-iso-with-virtualbox  Probar una imagen ISO con virtualbox

Para probar una imagen ISO con /{virtualbox}/:

code{

 # apt-get install virtualbox virtualbox-dkms

 $ virtualbox

}code

Crear una nueva máquina virtual, cambiar la configuración de almacenamiento
para utilizar #{binary.hybrid.iso}# como dispositivo CD/DVD y arrancar la
máquina.

*{Nota:}* Para probar los sistemas en vivo con soporte X.org en /{virtualbox}/, se puede incluir el paquete del driver de VirtualBox X.org, /{virtualbox-guest-x11}/, en la configuración de live-build. De lo contrario, la resolución se limita a 800x600.

code{

 $ echo virtualbox-guest-x11 >> config/package-lists/my.list.chroot

}code

2~using-hdd-image Building and using an HDD image

Building an HDD image is similar to an ISO hybrid one in all respects except
you specify #{-b hdd}# and the resulting filename is #{binary.img}# which
cannot be burnt to optical media. It is suitable for booting from USB
sticks, USB hard drives, and various other portable storage
devices. Normally, an ISO hybrid image can be used for this purpose instead,
but if you have a BIOS which does not handle hybrid images properly, you
need an HDD image.

*{Nota:}* si se ha creado una imagen ISO híbrida con el ejemplo anterior, se tendrá que limpiar el directorio de trabajo con el comando #{lb clean}# (ver {El comando lb clean}#lb-clean):

code{

 # lb clean --binary

}code

Ejecutar el comando #{lb config}# como antes pero esta vez especificando el
tipo de imagen HDD:

code{

 $ lb config -b hdd

}code

Crear ahora la imagen con el comando #{lb build}#:

code{

 # lb build

}code

Cuando termine el proceso de creación, debe haber un fichero llamado
#{binary.img}# en el directorio actual .

The generated binary image contains a VFAT partition and the syslinux
bootloader, ready to be directly written on a USB device. Once again, using
an HDD image is just like using an ISO hybrid one on USB. Follow the
instructions in {Using an ISO hybrid live image}#using-iso-hybrid, except
use the filename #{binary.img}# instead of #{binary.hybrid.iso}#.

Likewise, to test an HDD image with Qemu, install /{qemu}/ as described
above in {Testing an ISO image with QEMU}#testing-iso-with-qemu. Then run
#{kvm}# or #{qemu}#, depending on which version your host system needs,
specifying #{binary.img}# as the first hard drive.

code{

 $ kvm -hda binary.img

}code

2~building-netboot-image Creación de una imagen de arranque en red

The following sequence of commands will create a basic netboot image
containing a default live system without X.org. It is suitable for booting
over the network.

*{Nota:}* si se ha seguido algúno de los ejemplos anteriores, se tendrá que limpiar el directorio de trabajo con el comando #{lb clean}#:

code{

 # lb clean --binary

}code

Ejecutar el comando #{lb config}# de la siguiente manera para configurar la
imagen de arranque en red:

code{

 $ lb config -b net --net-root-path "/srv/debian-live" --net-root-server "192.168.0.1"

}code

A diferencia de las imágenes ISO y HDD, el sistema de arranque en red en sí
mismo no envía la imagen del sistema de ficheros al cliente, por eso los
ficheros se deben enviar mediante NFS. Las opciones #{--net-root-path}# y
#{--net-root-server}# especifican la ubicación y el servidor,
respectivamente, del servidor NFS en el que se encuentra la imagen del
sistema de ficheros en el arranque. Se debe asegurar que estos se ajustan a
los valores adecuados para la red y el servidor deseados.

Crear ahora la imagen con el comando #{lb build}#:

code{

 # lb build

}code

En un arranque en red, el cliente ejecuta una pequeña pieza de software que
generalmente se encuentra en la EPROM de la tarjeta Ethernet. Este programa
envía una solicitud de DHCP para obtener una dirección IP e información
sobre qué hacer a continuación. Por lo general, el siguiente paso es
conseguir un gestor de arranque de alto nivel a través del protocolo
TFTP. Este gestor podría ser PXELINUX, GRUB, o incluso arrancar directamente
un sistema operativo como Linux.

Por ejemplo, si se descomprime el archivo generado #{binary.netboot.tar.xz}#
en el directorio #{/srv/debian-live}#, se verá la imagen del sistema de
ficheros en #{live/filesystem.squashfs}# y el kernel, initrd y el gestor de
arranque pxelinux en #{tftpboot/debian-live/i386}#.

Ahora se debe configurar tres servicios en el servidor para que arranque en
red: el servidor DHCP, el servidor TFTP y el servidor NFS.

3~ Servidor DHCP

Hay que configurar el servidor DHCP de red para asegurar que proporciona una
dirección IP al cliente, y para anunciar la ubicación del gestor de arranque
PXE.

He aquí un ejemplo que puede servir de inspiración. Fue escrito para el
servidor ISC DHCP #{isc-dhcp-server}# en su fichero de configuración
#{/etc/dhcp/dhcpd.conf}#:

code{

 # /etc/dhcp/dhcpd.conf - fichero de configuración para isc-dhcp-server

 ddns-update-style none;

 option domain-name "example.org";
 option domain-name-servers ns1.example.org, ns2.example.org;

 default-lease-time 600;
 max-lease-time 7200;

 log-facility local7;

 subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.1 192.168.0.254;
   next-server servername;
   filename "pxelinux.0";
}

}code

3~ Servidor TFTP

Se encarga de suministrar el kernel y el Disco RAM inicial para el sistema.

Se debe instalar el paquete /{tftpd-hpa}/. Este servidor podrá suministrar
todos los ficheros contenidos de un directorio raíz, normalmente
#{/srv/tftp}#. Para permitirle que pueda servir los ficheros de
#{/srv/debian-live/tftpboot}#, se debe ejecutar el siguiente comando con
privilegios de superusuario:

code{

 # dpkg-reconfigure -plow tftpd-hpa

}code

y escribir el directorio del nuevo servidor tftp cuando sea requerido.

3~ Servidor NFS 

Una vez el equipo cliente ha descargado y arrancado el kernel de Linux junto
a su initrd, intentará montar el sistema de archivos de la imagen en vivo a
través de un servidor NFS.

Se debe instalar el paquete /{nfs-kernel-server}/.

Entonces, se debe hacer que la imagen del sistema de archivos esté
disponible a través de NFS añadiendo una línea como la siguiente para
#{/etc/exports}#:

code{

 /srv/debian-live *(ro,async,no_root_squash,no_subtree_check)

}code

e informar al servidor NFS sobre esta nueva exportación con el siguiente
comando:

code{

 # exportfs -rv

}code

La configuración de estos tres servicios puede ser un poco difícil. Será
necesario un poco de paciencia para conseguir que todos ellos funcionen
juntos. Para obtener más información, ver el wiki de syslinux en
http://syslinux.zytor.com/wiki/index.php/PXELINUX o la sección sobre TFTP
Net Booting del Manual del Instalador de Debian en
http://d-i.alioth.debian.org/manual/en.i386/ch04s05.html Esto puede ser
útil, ya que sus procesos son muy similares.

3~ Cómo probar el arranque en red

La creación de una imagen de arranque en red es fácil usando la mágia de
live-build, pero probar las imágenes en máquinas físicas puede ser un
proceso mucho más lento.

Para hacer nuestra vida más fácil, se puede utilizar la virtualización. Hay
dos soluciones.

3~ Qemu

_* Instalar /{qemu}/, /{bridge-utils}/, /{sudo}/.

Se debe editar el fichero #{/etc/qemu-ifup}#:

code{

 #!/bin/sh
 sudo -p "Password for $0:" /sbin/ifconfig $1 172.20.0.1
 echo "Executing /etc/qemu-ifup"
 echo "Bringing up $1 for bridged mode..."
 sudo /sbin/ifconfig $1 0.0.0.0 promisc up
 echo "Adding $1 to br0..."
 sudo /usr/sbin/brctl addif br0 $1
 sleep 2

}code

Obtener o crear un #{grub-floppy-netboot}# (en el svn).

Lanzar #{qemu}# con "#{-net nic,vlan=0 -net tap,vlan=0,ifname=tun0}#"

3~ VMWare Player

_* Instalar VMWare Player (Edición gratuita «free as in beer»)

_* Crear un directorio PXETester y crear un fichero de texto dentro llamado
#{pxe.vwx}#

_* Copiar este texto dentro:

code{

 #!/usr/bin/vmware
 config.version = "8"
 virtualHW.version = "4"
 memsize = "512"
 MemAllowAutoScaleDown = "FALSE"

 #!/usr/bin/vmware
 config.version = "8"
 virtualHW.version = "4"
 memsize = "512"
 MemAllowAutoScaleDown = "FALSE"

 ethernet0.present = "TRUE"
 ethernet0.addressType = "generated"

 displayName = "Test Boot PXE"
 guestOS = "other"

 ethernet0.generatedAddress = "00:0c:29:8d:71:3b"
 uuid.location = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
 uuid.bios = "56 4d 83 72 5c c4 de 3f-ae 9e 07 91 1d 8d 71 3b"
 ethernet0.generatedAddressOffset = "0"

}code

_* Se pueden realizar pruebas con este fichero de configuración
(p.ej. cambiar el limite de memoria a 256)

_* Hacer doble clic en este fichero (o lanzar VMWare player y seleccionar
este fichero).

_* Mientras esté en ejecución, si surge esa extraña pregunta, simplemente
hay que pulsar «espacio» ...
