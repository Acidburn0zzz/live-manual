:B~ Personalización del comportamiento en tiempo de ejecución.

1~customizing-run-time-behaviours Personalización del comportamiento en
tiempo de ejecución.

Toda la configuración que se hace en tiempo de ejecución es realizada por
live-config. Éstas son algunas de las opciones más comunes de live-config en
las que los usuarios están más interesados. Se puede encontrar una lista
completa de todas las posibilidades en la página de manual de live-config.

2~ Personalización del usuario por defecto del sistema en vivo

Una consideración importante es que el usuario por defecto del sistema en
vivo es creado por live-boot en el arranque y no live-build durante la
creación de la imagen. Ésto no sólo influye dónde se introducen los
materiales relacionados con este usuario durante la creación de la imagen
tal y como se explica en {Includes locales en
Live/chroot}#live-chroot-local-includes sino también a cualquier grupo y a
los permisos asociados con el usuario por defecto del sistema en vivo.

Se puede especificar grupos adicionales a los que pertenecerá el usuario por
defecto del sistema en vivo preconfigurando el valor debconf
#{passwd/user-default-groups}#. Por ejemplo, para agregar el usuario al
grupo #{fuse}# durante la etapa chroot, añadir el siguiente código en un
fichero en el directorio #{config/preseed/}#.

code{

 $ lb config
 $ echo user-setup passwd/user-default-groups string audio cdrom \
   dip floppy video plugdev netdev powerdev scanner bluetooth fuse \
   >> config/preseed/my.preseed.chroot

}code

Además, es posible cambiar el usuario por defecto "user" y la contraseña por
defecto "live". Si se desea cambiarlos por cualquier motivo, se puede
conseguir de forma sencilla tal y como se explica a continuación:

Cambiar el nombre del usuario por defecto es tan sencillo como especificarlo
en la configuración:

code{

 $ lb config --bootappend-live "username=live-user"

}code

Una posible forma de cambiar la contraseña por defecto es usando un script
gancho (hook) tal y como se describe en {Scripts gancho en tiempo de
arranque}#boot-time-hooks. Para conseguirlo se puede usar el script gancho
«passwd» de #{/usr/share/doc/live-config/examples/hooks}#, ponerle un
prefijo adecuado (p.ej. 2000-passwd) y añadirlo a
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Personalización de las variantes locales e
idioma

Cuando el sistema en vivo arranca, el idioma está implicado en dos pasos:

_* Generar las variantes locales

_* Establecer la distribución del teclado

La variante local predeterminada en la creación de un sistema en vivo es
#{locales=en_US.UTF-8}#. Para definir la variante local que se debe generar,
se puede utilizar el parámetro #{locales}# en la opción
#{--bootappend-live}# de #{lb config}#, p.ej.

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

Se pueden especificar diversas variantes locales separándolas con comas.

Este parámetro se puede utilizar en la línea de comandos del kernel, al
igual que los parámetros de configuración del teclado indicados a
continuación. Es posibe configurar una variante local con #{idioma_país}#
(en cuyo caso se utiliza el tipo de codificación por omisión) o también con
la expresión completa #{idioma_país.codificación}#. La lista de todas las
variantes locales está en #{/usr/share/i18n/SUPPORTED}#.

#{live-config}# se encarga de la configuración del teclado de la consola y
del entorno gráfico X utilizando el paquete #{console-setup}#. Para
configurarlos se puede utilizar los parámetros de arranque
#{keyboard-layouts}#, #{keyboard-variant}#, #{keyboard-options}# y
#{keyboard-model}# a través de la opción #{--bootappend-live}#. Se puede
encontrar una lista de opciones válidas para estos parámetros en
#{/usr/share/X11/xkb/rules/base.lst}#. Para hallar la distribución del
teclado y la variante que corresponde a un idioma se puede buscar el nombre
en inglés de la nación donde se habla el idioma, por ejemplo:

code{

$ egrep -i '(^!|german.*switzerland)' /usr/share/X11/xkb/rules/base.lst
 ! model
 ! layout
   ch              German (Switzerland)
 ! variant
   legacy          ch: German (Switzerland, legacy)
   de_nodeadkeys   ch: German (Switzerland, eliminate dead keys)
   de_sundeadkeys  ch: German (Switzerland, Sun dead keys)
   de_mac          ch: German (Switzerland, Macintosh)
 ! option

}code

Cada variante muestra una descripción de la disposición que aplica.

Normalmente, sólo es necesario configurar la disposición del teclado. Por
ejemplo, para obtener los ficheros de la variante local de la disposición
del teclado alemán y suizo-alemán en X utilizar:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

Sin enbargo, para casos de uso muy específicos, se puede incluir otros
parámetros. Por ejemplo, para configurar un sistema Francés con una
disposición French-Dvorak (también llamado Bepo) en un teclado USB
TypeMatrix EZ-Reach 2030, utilizar:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variant=bepo keyboard-model=tm2030usb"

}code

Para cada una de las variables de configuración del teclado #{keyboard-*}#
se puede especificar varios valores separados por comas. A excepción de
#{keyboard-model}#, que sólo acepta un valor. En la página de manual
#{keyboard(5)}# se explican los detalles y algunos ejemplos de cómo utilizar
las variables #{XKBMODEL}#, #{XKBLAYOUT}#, #{XKBVARIANT}# y
#{XKBOPTIONS}#. Si se especifican diferentes valores en #{keyboard-variant}#
estos se corresponderan uno a uno con los valores #{keyboard-layouts}# (ver
#{setxkbmap(1)}# opción #{-variant}#). Se admiten valores vacíos; por
ejemplo para definir dos distribuciones de teclado, la que se usa por
omisión US QWERTY y otra US Dvorak, utilizar:

code{

 $ lb config --bootappend-live \
     "keyboard-layouts=us,us keyboard-variant=,dvorak"

}code

2~persistence  Persistencia

Un paradigma de un cd en vivo («live cd» N. del T.) es ser un sistema
pre-instalado que funciona desde medios de almacenamiento de sólo lectura,
como un CD-ROM, donde los cambios y las modificaciones no se guardan tras
reiniciar el sistema en que se ejecuta.

Un sistema Debian Live es una generalización de este paradigma pero que es
compatible con otros medios de almacenamiento, no sólo en CDs. Aún así, en
su comportamiento predeterminado, se debe considerar un sistema de sólo
lectura y todos los cambios en tiempo de ejecución del sistema se pierden al
apagar el equipo.

La «persistencia» es un nombre común que se da a los diferentes tipos de
soluciones para guardar algunos o todos los cambios realizados durante la
ejecución tras reiniciar el sistema. Para entender cómo funciona es útil
saber que incluso si el sistema se inicia y se ejecuta desde los medios de
almacenamiento de sólo lectura, las modificaciones de los ficheros y
directorios se escriben en medios de escritura, por lo general en la memoria
ram (tmpfs) y los datos guardados en la ram no se guardan tras reiniciar.

Los datos almacenados en esta memoria ram se pueden guardar en un soporte
grabable, como un medio de almacenamiento local, un recurso compartido en
red o incluso en una sesión de un CD/DVD regrabable en multisesión. Todos
estos medios son compatibles con Debian Live de diferentes maneras y todos,
menos el último, requieren un parámetro de arranque especial que se
especificará en el momento del arranque: #{persistence}#.

Si se usa el parámetro de arranque #{persistence}# (y no se usa la opción
#{nopersistence}#), se busca en los medios de almacenamiento locales
(p.ej. discos duros, llaves USB) volúmenes con persistencia durante el
arranque. Es posible restringir qué tipos de volúmenes persistentes se
pueden usar especificando ciertos parámetros de arranque descritos en la
página del manual de live-boot(7). Un volumen persistente es cualquiera de
los siguientes: 

_* una partición, identificada por su nombre GPT.

_* Un sistema de ficheros, identificado por su etiqueta de sistema de
ficheros.

_* una fichero imagen situado en la raíz de cualquier sistema de ficheros
que pueda ser leido (incluso una partición NTFS de otro sistema operativo),
identificado por su nombre de fichero. En este caso el nombre del fichero
debe contener el nombre el sistema de ficheros como extensión,
p.ej. "persistence.ext4".

La etiqueta del volumen para las capas de persistencia debe ser
#{persistence}#. Y para poder personalizar de forma completa la persistencia
del volumen tiene que haber un fichero llamado
#{live-persistence.conf}#. Ver {El fichero
live-persistence.conf}#live-persistence-conf

He aquí algunos ejemplos de cómo preparar un volumen para ser usado para la
persistencia. Puede ser, por ejemplo, una partición en un disco duro o en
una llave usb creada con, p.ej.

code{

 # mkfs.ext4 -L persistence /dev/sdb1

}code

Ver {Usar el espacio libre en el dispositivo USB}#using-usb-extra-space.

Si ya existe una partición en el dispositivo, sólo se tiene que cambiar la
etiqueta con uno de los siguientes:

code{

 $ tune2fs -L persistence /dev/sdb1 # for ext2,3,4 filesystems

}code

Un ejemplo de cómo crear un fichero imagen basado en ext4 usado para la
persistencia:

code{

 $ dd if=/dev/null of=persistence bs=1G seek=1 # for a 1GB sized image file
 $ /sbin/mkfs.ext4 -F persistence

}code

A continuación, copiar el fichero #{persistence}# en la raíz de una
partición grabable.

3~live-persistence-conf El fichero live-persistence.conf

Un volumen con la etiqueta #{persistence}# puede ser configurado para crear
arbitrariamente directorios persistentes. El fichero
#{live-persistence.conf}#, situado en el sistema de ficheros raíz del
volumen, controla que directorios hace persistentes y también de que manera.

En la página de manual de live-persistence.conf(5) se explica en detalle
cómo se configura el montaje de las capas, pero un sencillo ejemplo es
suficiente para la mayoría de los casos. Supongamos que queremos crear
nuestro directorio home y APT cache persistentes en un sistema de ficheros
ext4 en la partición /dev/sdb1:

code{

 # mkfs.ext4 -L persistence /dev/sdb1
 # mount -t ext4 /dev/sdb1 /mnt
 # echo "/home" >> /mnt/live-persistence.conf
 # echo "/var/cache/apt" >> /mnt/live-persistence.conf

}code

Entonces reiniciamos. Durante el primer arranque los contenidos de #{/home}#
y #{/var/cache/apt}# se copiarán en el volumen persistente y a partir de ese
momento todos los cambios en esos directorios se guardarán allí. Tener en
cuenta que las rutas listadas en el fichero #{live-persistence.conf}# no
pueden contener espacios en blanco ni los componentes especiales #{.}# y
#{..}#. Además, ni #{/live}# (o ninguno de sus sub-directorios) ni #{/}#
pueden hacerse persistentes montándolos de forma personalizada.

Se puede usar diferentes volúmenes de capas personalizados al mismo tiempo
(con sus propios ficheros #{live-persistence.conf}#) pero si varios
volúmenes hacen que un mismo directorio sea persistente, sólo uno de ellos
será usado. Si dos unidades montadas están "anidadas" (es decir, una es un
sub-directorio de la otra) el directorio superior será montado antes que el
inferior de este modo no quedará uno escondido por el otro. La
personalización de los montajes anidadados es problemática si están listados
en el mismo fichero #{live-persistence.conf}#. Consultar la página de manual
de live-persistence.conf(5) para ver como manejar ese caso si realmente es
necesario. (aclaración: normalmente no lo es).

3~ Utilizar varios medios persistentes

Si un usuario necesita un almacenamiento persistente múltiple del mismo tipo
para diferentes lugares o pruebas, tales como #{persistence-nonwork}# y
#{persistence-work}#, el parámetro de arranque #{persistence-label}# usado
junto con el parámetro de arranque #{persistence}# permitirá medios de
almacenamiento persistentes múltiples pero únicos. Un ejemplo sería, si un
usuario desea utilizar una partición persistente etiquetada
#{persistence-subText}# usaría los parámetros de arranque: #{persistence}#
#{persistence-label=subText}#.
