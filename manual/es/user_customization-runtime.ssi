:B~ Personalización del comportamiento en tiempo de ejecución.

1~customizing-run-time-behaviours Personalización del comportamiento en
tiempo de ejecución.

Toda la configuración que se hace en tiempo de ejecución es realizada por
live-config. Éstas son algunas de las opciones más comunes de live-config en
las que los usuarios están más interesados. Se puede encontrar una lista
completa de todas las posibilidades en la página de manual de live-config.

2~ Personalización del usuario por defecto del sistema en vivo

Una consideración importante es que el usuario por defecto del sistema en
vivo es creado por live-boot en el arranque y no live-build durante la
creación de la imagen. Ésto no sólo influye dónde se introducen los
materiales relacionados con este usuario durante la creación de la imagen
tal y como se explica en {Includes locales en
Live/chroot}#live-chroot-local-includes sino también a cualquier grupo y a
los permisos asociados con el usuario por defecto del sistema en vivo.

Se puede especificar grupos adicionales a los que pertenecerá el usuario por
defecto del sistema en vivo preconfigurando el valor debconf
#{passwd/user-default-groups}#. Por ejemplo, para agregar el usuario al
grupo #{fuse}# durante la etapa chroot, añadir el siguiente código en un
fichero en el directorio #{config/preseed/}#.

code{

 $ lb config
 $ echo user-setup passwd/user-default-groups string audio cdrom \
   dip floppy video plugdev netdev powerdev scanner bluetooth fuse \
   >> config/preseed/my.preseed.chroot

}code

Además, es posible cambiar el usuario por defecto "user" y la contraseña por
defecto "live". Si se desea cambiarlos por cualquier motivo, se puede
conseguir de forma sencilla tal y como se explica a continuación:

Cambiar el nombre del usuario por defecto es tan sencillo como especificarlo
en la configuración:

code{

 $ lb config --bootappend-live "username=live-user"

}code

Una posible forma de cambiar la contraseña por defecto es usando un script
gancho (hook) tal y como se describe en {Scripts gancho en tiempo de
arranque}#boot-time-hooks. Para conseguirlo se puede usar el script gancho
«passwd» de #{/usr/share/doc/live-config/examples/hooks}#, ponerle un
prefijo adecuado (p.ej. 200-passwd) y añadirlo a
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Personalización de las variantes locales e
idioma

Cuando el sistema en vivo arranca, el idioma está implicado en tres pasos:

_* Generar las variantes locales

_* Establecer la distribución del teclado para el consola

_* Establecer la distribución del teclado para el entorno gráfico X

La variante local predeterminada en la creación de un sistema en vivo es
"locales=en_US.UTF-8". Para definir la variante local que se debe generar,
se puede utilizar el parámetro #{locales}# en la opción
#{--bootappend-live}# de #{lb config}#, p.ej.

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

Este parámetro también se puede utilizar en la línea de comandos del
kernel. Se puede especificar una variante local de esta forma:
#{language_country.encoding}#.

Tanto la configuración del teclado de la consola y del entorno gráfico X
dependen del parámetro #{keyboard-layouts}# de la opción
#{--bootappend-live}#. Se pueden encontrar opciones válidas de la
disposición del teclado en #{/usr/share/X11/xkb/rules/base.xml}# (bastante
limitado a los códigos de país de dos letras). Para hallar el valor (los dos
letras) que corresponde a un idioma se puede buscar el nombre en inglés de
la nación donde se habla el idioma, por ejemplo:

code{

 $ grep -i sweden -C3 /usr/share/X11/xkb/rules/base.xml | grep name
 <name>se</name>

}code

Por ejemplo, para obtener los ficheros de la variante local de la
disposición del teclado alemán y suizo-alemán en X usar:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

Se puede ver una lista de los valores de teclados válidos para la consola
con el siguiente comando:

code{

 $ for i in $(find /usr/share/keymaps/ -iname "*kmap.gz"); \
     do basename $i | head -c -9; echo; done | sort | less

}code

Alternativamente, se puede usar el paquete #{console-setup}# una herramienta
que permite configurar la disposición de la consola utilizando definiciones
X (XKB), a continuación, se puede configurar el teclado con mayor precisión
con las variables #{keyboard-layouts}#, #{keyboard-variant}#,
#{keyboard-options}# y #{keyboard-model}#;  live-boot también usará estos
parámetros para la configuración de X. Por ejemplo, para establecer un
sistema francés con una distribución de teclas francés-Dvorak (llamado Bepo)
en un teclado TypeMatrix, tanto en consola X como X11, se puede utilizar:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variant=bepo keyboard-model=tm2030usb"

}code

2~persistence  Persistencia

Un paradigma de un cd en vivo («live cd» N. del T.) es ser un sistema
pre-instalado que funciona desde medios de almacenamiento de sólo lectura,
como un CD-ROM, donde los cambios y las modificaciones no se guardan tras
reiniciar el sistema en que se ejecuta.

Un sistema Debian Live es una generalización de este paradigma pero que es
compatible con otros medios de almacenamiento, no sólo en CDs. Aún así, en
su comportamiento predeterminado, se debe considerar un sistema de sólo
lectura y todos los cambios en tiempo de ejecución del sistema se pierden al
apagar el equipo.

La persistencia es un nombre común que se da a los diferentes tipos de
soluciones para guardar algunos o todos los cambios realizados durante la
ejecución tras reiniciar el sistema. Para entender cómo funciona es útil
saber que incluso si el sistema se inicia y se ejecuta desde los medios de
almacenamiento de sólo lectura, las modificaciones de los ficheros y
directorios se escriben en medios de escritura, por lo general en la memoria
ram (tmpfs) y los datos guardados en la ram no se guardan tras reiniciar.

Los datos almacenados en esta memoria ram se pueden guardar en un soporte
grabable como un medio de almacenamiento local, un recurso compartido en red
o incluso en una sesión de un CD/DVD regrabable en multisesión. Todos estos
medios son compatibles con Debian Live de diferentes maneras, y todos menos
el último requieren un parámetro de arranque especial que se especificará en
el momento del arranque: #{persistent}#.

Si se usa el parámetro de arranque #{persistent}# (y no se usa la opción
#{nopersistent}#), se busca en los medios de almacenamiento locales
(p.ej. discos duros, llaves USB) volúmenes con persistencia durante el
arranque. Un volumen persistente es cualquiera de los siguientes: 

_* una partición, identificada por su nombre GPT.

_* Un sistema de ficheros, identificado por su etiqueta de sistema de
ficheros.

_* una fichero imagen/archivo situado en el sistema raiz de cualquier
sistema de ficheros que pueda ser leido (incluso una partición NTFS de otro
sistema operativo), identificado por su nombre de fichero. En este caso el
nombre del fichero debe contener el nombre el sistema de ficheros como
extensión, p.ej. "<label>.ext4".

Es posible restringir qué tipos de volúmenes persistentes se pueden usar
especificando ciertos parámetros de arranque descritos en la página del
manual de live-boot(7). Las "etiquetas identificadoras" referidas
anteriormente pueden ser cualquiera de las siguientes:

_* #{full-ov}# para capas de persistencia total.

_* #{custom-ov}# para capas personalizadas.

_* #{live-sn}# para instantáneas del sistema entero.

_* #{home-sn}# para instantáneas de /home.

3~ Capas de persistencia total 

Por «Persistencia total» se entiende la utilización de una partición de
escritura en lugar de usar un tmpfs (sistema de ficheros temporal) para
guardar los cambios realizados en los medios de sólo lectura (con el sistema
copiar-al-escribir o COW «copy-on-write» N. del T.). Para utilizar este tipo
de persistencia la etiqueta del volumen debe ser #{full-ov}#. Esta podría
ser, por ejemplo, una partición ext4 o un disco duro o una llave usb creada
con. p.ej:

code{

 # mkfs.ext4 -L full-ov /dev/sdb1

}code

Ver {Usar el espacio libre en el dispositivo USB}#using-usb-extra-space.

Si ya existe una partición en el dispositivo, sólo se tiene que cambiar la
etiqueta con uno de los siguientes:

code{

 $ tune2fs -L full-ov /dev/sdb1 # for ext2,3,4 filesystems

}code

Un ejemplo de cómo crear un fichero imagen basado en ext4 usando
persistencia total.

code{

 $ dd if=/dev/null of=full-ov bs=1G seek=1 # for a 1GB sized image file
 $ /sbin/mkfs.ext4 -F full-ov

}code

A continuación, copiar el fichero #{full-ov}# en una partición grabable y
reiniciar el sistema.

3~ Capas personalizadas

Un volumen con la etiqueta #{custom-ov}# puede ser personalizado para crear
arbitrariamente directorios persistentes. El fichero #{live.persist}#,
situado en el sistema de ficheros raiz del volumen, controla que directorios
hace persistentes y también de que manera.

En la página de manual de live.persist(5) se explica en detalle cómo se
configura el montaje de las capas, pero un sencillo ejemplo es suficiente
para la mayoría de los casos. Supongamos que queremos crear nuestro
directorio home y APT cache persistentes en un sistema de ficheros ext4 en
la partición /dev/sdb1:

code{

 $ mkfs.ext4 -L custom-ov /dev/sdb1
 $ mount -t ext4 /dev/sdb1 /mnt
 $ echo "/home" >> /mnt/live.persist
 $ echo "/var/cache/apt" >> /mnt/live.persist

}code

Entonces reiniciamos. Durante el primer arranque los contenidos de #{/home}#
y #{/var/cache/apt}# se copiarán en el volumen persistente y a partir de ese
momento todos los cambios en esos directorios se guardarán allí. Tener en
cuenta que los rutas listadas en el fichero #{live.persist}# no pueden
contener espacios en blanco ni los componentes especiales #{.}# y
#{..}#. Además ni #{/live}# (o ninguno de sus sub-directorios) ni #{/}#
pueden hacerse persistentes montándolos de forma personalizada. Para este
último, usar el tipo de persistencia #{full-ov}# descrito anteriormente.

Se puede usar diferentes volúmenes de capas personalizados al mismo tiempo
(con sus propios ficheros #{live.persist}#) pero si varios volúmenes hacen
que un mismo directorio sea persistente, sólo uno de ellos será usado. Si
dos unidades montadas están "anidadas" (es decir, una es un sub-directorio
de la otra) el directorio superior será montado antes que el inferior de
este modo no quedará uno escondido por el otro. La personalización de los
montajes anidadados es problemática si están listados en el mismo fichero
#{live.persist}#. Consultar la página de manual de live.persist(5) para ver
como manejar ese caso si realmente es necesario. (aclaración: normalmente no
lo es).

3~ Instantáneas

Las instantáneas son colecciones de ficheros y directorios que no se montan
durante la ejecución, pero que se copian desde un volumen persistente al
sistema (tmpfs) en el arranque y que se resincroniza en el reinicio/apagado
del sistema.  El volumen debe tener la etiqueta #{live-sn}#, y su valor
predeterminado es un simple archivo cpio denominado #{live-sn.cpio.gz}#. Una
interrupción del suministro eléctrico en tiempo de ejecución podría conducir
a la pérdida de datos, por lo tanto, se puede usar la herramienta
#{live-snapshot --refresh}# para sincronizar cambios importantes. Este tipo
de persistencia es la menos agresiva con los dispositivos tipo flash y el
más rápido de todos los sistemas de persistencia, ya que no escribe
continuamente en los medios de almacenamiento, pero ocupa tanta RAM como el
tamaño de la instantánea sin comprimir.

Existe también una versión de la instantánea /home y su etiqueta es
#{home-sn.*}#; que funciona igual que la instantánea principal, pero sólo se
aplica a /home.

Las instantáneas no pueden manejar el borrado de ficheros.

3~ SubText persistente

Si un usuario necesita un almacenamiento persistente múltiple del mismo tipo
para diferentes lugares o pruebas, tales como #{full-ov-nonwork}# y
#{full-ov-work}#, el parámetro de arranque #{persistent-subtext}# usado
junto con el parámetro de arranque #{persistent}# permitirá medios de
almacenamiento persistentes múltiples pero únicos. Un ejemplo sería, si un
usuario desea utilizar una partición persistente etiquetada
#{live-sn-subText}# usaría los parámetros de arranque: #{persistent}#
#{persistent-subtext=subText}#.

3~ Remasterización parcial

La modificación en tiempo de ejecución de la tmpfs podría ser guardada
usando una instantánea en vivo en un squashfs y añadirla a un cd
remasterizando la iso en el caso de un cd-r o añadiendo una sesión a un
cd/dvd(rw) multisesión; live-boot monta todo el sistema de ficheros /live en
orden o con el parámetro del módulo de arranque.
