:B~ Personalización del comportamiento en tiempo de ejecución.

1~customizing-run-time-behaviours Personalización del comportamiento en
tiempo de ejecución.

Toda la configuración que se hace en tiempo de ejecución es realizada por
live-config. Éstas son algunas de las opciones más comunes de live-config en
las que los usuarios están más interesados. Se puede encontrar una lista
completa de todas las posibilidades en la página del manual de live-config.

2~ Personalización del usuario por defecto del sistema en vivo

Una consideración importante es que el usuario por defecto del sistema en
vivo es creado por live-boot en el arranque y no live-build durante la
creación de la imagen. Ésto no sólo influye dónde se introducen los
materiales relacionados con este usuario durante la creación de la imagen
tal y como se explica en {Includes locales en
Live/chroot}#live-chroot-local-includes sino también a cualquier grupo y a
los permisos asociados con el usuario por defecto del sistema en vivo.

Se puede especificar grupos adicionales a los que pertenecerá el usuario por
defecto del sistema en vivo preconfigurando el valor debconf
#{passwd/user-default-groups}#. Por ejemplo, para agregar el usuario al
grupo #{fuse}# añadir el siguiente código en un fichero en el directorio
#{config/chroot_local-preseed}#.

code{

 user-setup passwd/user-default-groups string audio cdrom dip floppy video plugdev netdev powerdev scanner bluetooth fuse

}code

2~customizing-locale-and-language Personalización de las variantes locales e
idioma

Cuando el sistema en vivo arranca, el idioma está implicado en tres pasos:

_* Generar las variantes locales

_* Establecer la distribución del teclado para el consola

_* Establecer la distribución del teclado para el entorno gráfico X

La variante local predeterminada en la creación de un sistema en vivo es
"locales=en_US.UTF-8". Para definir la variante local que se debe generar,
se puede utilizar el parámetro #{locales}# en la opción
#{--bootappend-live}# de #{lb config}#, p.ej.

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

Este parámetro también se puede utilizar en la línea de comandos del
kernel. Se puede especificar una variante local usando una palabra completa
#{language_country.encoding}#.

Tanto la configuración del teclado de la consola y del entorno gráfico X
dependen del parámetro #{keyboard-layouts}# de la opción
#{--bootappend-live}#. Se pueden encontrar opciones válidas de la
disposición del teclado en #{/usr/share/X11/xkb/rules/base.xml}# (bastante
limitado a los códigos de país de dos letras). Para hallar el valor (los dos
letras) que corresponde a un idioma se puede buscar el nombre en inglés de
la nación donde se habla el idioma, por ejemplo:

code{

 $ grep -i sweden -C3 /usr/share/X11/xkb/rules/base.xml | grep name
 <name>se</name>

}code

Por ejemplo, para obtener los ficheros de la variante local de la
disposición del teclado alemán y suizo-alemán en X usar:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

Se puede ver una lista de los valores de teclados válidos para la consola
con el siguiente comando:

code{

 $ for i in $(find /usr/share/keymaps/ -iname "*kmap.gz"); \
     do basename $i | head -c -9; echo; done | sort | less

}code

Alternativamente, se puede usar el paquete #{console-setup}# una herramienta
que permite configurar la disposición de la consola utilizando definiciones
X (XKB), a continuación, se puede configurar el teclado con mayor precisión
con las variables #{keyboard-layouts}#, #{keyboard-variant}#,
#{keyboard-options}# y #{keyboard-model}#;  live-boot también usará estos
parámetros para la configuración de X. Por ejemplo, para establecer un
sistema francés con una distribución de teclas francés-Dvorak (llamado Bepo)
en un teclado TypeMatrix, tanto en consola X como X11, se puede utilizar:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variant=bepo keyboard-model=tm2030usb"

}code

2~persistence  Persistencia (Modo guardar cambios)

Un paradigma de un cd en vivo («live cd» N. del T.) es ser un sistema
pre-instalado que funciona desde medios de almacenamiento de sólo lectura,
como un CD-ROM, donde los cambios y las modificaciones no se guardan tras
reiniciar el sistema en que se ejecuta.

Un sistema Debian Live es una generalización de este paradigma pero que es
compatible con otros medios de almacenamiento, no sólo en CDs. Aún así, en
su comportamiento predeterminado, se debe considerar un sistema de sólo
lectura y todos los cambios en tiempo de ejecución del sistema se pierden al
apagar el equipo.

La persistencia (o modo guardar cambios) es un nombre común que se dá a los
diferentes tipos de soluciones para guardar algunos o todos los cambios
realizados durante la ejecución tras reiniciar el sistema. Para entender
cómo funciona es útil saber que incluso si el sistema se inicia y se ejecuta
desde los medios de almacenamiento de sólo lectura, las modificaciones de
los ficheros y directorios se escriben en medios de escritura, por lo
general en la memoria ram (tmpfs) y los datos guardados en la ram no se
guardan tras reiniciar.

Los datos almacenados en esta memoria ram se pueden guardar en un soporte
grabable como un disco duro, una memoria USB, un recurso compartido de red o
incluso en una sesión de un CD/DVD regrabable en multisesión. Todos estos
medios son compatibles con Debian Live de diferentes maneras, y todos menos
el último requieren un parámetro de arranque especial que se especificará en
el momento del arranque: #{persistent}#.

3~ Persistencia total

Por «Persistencia total» se entiende la utilización de una partición de
escritura en lugar de usar un tmpfs (sistema de ficheros temporal) para
guardar los cambios realizados a los medios de sólo lectura (con el sistema
copiar-al-escribir o COW «copy-on-write» N. del T.). Para utilizar esta
función se debe crear una partición grabable vacía con la etiqueta «live-rw»
formateada con un sistema de ficheros compatible en el medio usado para
arracar el sistema en vivo. En el momento de arrancar se debe iniciar el
sistema con el parámetro de arranque 'persistent'. Esta partición puede ser
una partición ext2 en el disco duro o en una memoria USB creada con, por
ejemplo:

code{

 # mkfs.ext2 -L live-rw /dev/sdb1

}code

Ver {Usar el espacio libre en el dispositivo USB}#using-usb-extra-space.

Si ya existe una partición en el dispositivo, sólo se tiene que cambiar la
etiqueta con uno de los siguientes:

code{

 # tune2fs -L live-rw /dev/sdb1 # for ext2,3,4 filesystems

}code

Pero ya que los usuarios de un sistema en vivo no siempre pueden utilizar
una partición del disco duro, y teniendo en cuenta que la mayoría de
memorias USB tienen velocidades de escritura lentas, la persistencia total
también puede ser usada con ficheros imagen, de este modo se puede crear un
fichero que represente una partición y poner ese fichero imagen incluso en
una partición NTFS de un sistema operativo no nativo, con algo similar a
esto:

code{

 $ dd if=/dev/null of=live-rw bs=1G seek=1 # for a 1GB sized image file
 $ /sbin/mkfs.ext2 -F live-rw

}code

A continuación, copiar el fichero #{live-rw}# a un partición grabable y
reiniciar el sistema con el parámetro de arranque «persistent».

3~ Montar Home de forma automática

Si durante el arranque se encuentra una partición (sistema de ficheros) con
un fichero imagen o una partición con la etiqueta #{home-rw}# el sistema de
ficheros será montado de forma automática como #{/home}#, lo que permite la
persistencia de los ficheros que pertenecen a, por ejemplo, el usuario por
defecto. Se puede combinar con persistencia total.

3~ Instantáneas

Las instantáneas son colecciones de ficheros y directorios que no se montan
durante la ejecución, pero que se copian desde un dispositivo persistente al
sistema (tmpfs) en el arranque y que se resincroniza en el reinicio/apagado
del sistema.  El contenido de una instantánea puede residir en una partición
o en un fichero imagen (como los tipos mencionados anteriormente) con la
etiqueta #{live-sn}#, pero el valor predeterminado es un archivo cpio simple
denominado #{live-sn.cpio.gz}#. Como en el caso anterior, en el momento del
arranque los dispositivos conectados al sistema se recorren buscando una
partición o un fichero llamado así. Una interrupción de la alimentación en
tiempo de ejecución podría conducir a la pérdida de datos, por lo tanto, se
puede usar la herramienta #{live-snapshot --refresh}# para sincronizar
cambios importantes. Este tipo de persistencia es la menos agresiva con
dispositivos tipo flash y el más rápido de todos los sistemas de
persistencia, ya que no escribe continuamente en los medios de
almacenamiento.

Existe también una versión de la instantánea /home y su etiqueta es
#{home-sn.*}#; que funciona igual que la instantánea principal, pero sólo se
aplica a /home.

Las instantáneas actualmente no pueden manejar el borrado de ficheros pero
la persistencia total y el montaje automático sí pueden.

3~ SubText persistente

Si un usuario necesita un almacenamiento persistente múltiple del mismo tipo
para diferentes lugares o pruebas, tales como #{live-rw-nonwork}# y
#{live-rw-work}#, el parámetro de arranque #{persistent-subtext}# usado
junto con el parámetro de arranque #{persistent}# permitirá medios de
almacenamiento persistentes múltiples pero únicos. Un ejemplo sería si un
usuario desea utilizar una partición persistente etiquetada
#{live-sn-subText}# usaría los parámetros de arranque de: #{persistent}#
#{persistent-subtext=subText}#.

3~ Remasterización parcial

La modificación en tiempo de ejecución de la tmpfs podría ser guardada
usando una instantánea en vivo en un squashfs y añadirla a un cd
remasterizando la iso en el caso de un cd-r o añadiendo una sesión a un
cd/dvd(rw) multisesión; live-boot monta todo el sistema de ficheros /live en
orden o con el parámetro del módulo de arranque.
