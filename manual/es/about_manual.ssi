:B~ Acerca de este manual

1~about-manual Acerca de este manual

El objetivo principal de este manual es servir como único punto de acceso a
toda la documentación referente al projecto Debian Live y en particular al
sofware que el proyecto crea para Debian 7.0 "wheezy". Se puede encontrar
siempre una versión actualizada en http://live.debian.net/

live-manual está principalmente enfocado a ayudar en la creación de un
sistema en vivo y no está dirigido al usuario final de estos sistemas. Un
usuario final puede encontrar información útil en las siguentes secciones:
{Conceptos básicos}#the-basics que cubre la preparación de las imágenes para
arrancar un sistema desde un medio de almacenamiento o desde una red
local. {Personalización del comportamiento en tiempo de
ejecución}#customizing-run-time-behaviours que describe algunas de las
opciones que pueden especificarse en el indicador de arranque, como pueden
ser la selección de la distribución del teclado, las variantes locales o la
persistencia.

Algunos de los comandos mencionados en el texto deben ser ejecutados con
privilegios de superusuario, que pueden ser obtenidos accediendo a la cuenta
de root mediante la orden #{su}# o mediante la orden #{sudo}#. Para
distinguir las ordenes que deben ser ejecutadas como usuario no privilegiado
de las que si requieren privilegios de superusuario se ha prefijado con
#{$}# las primeras y con #{#}# las segundas. Estos símbolos no son parte de
la orden.

2~ Para el impaciente.

Aunque se cree que todo lo descrito en este manual es importante para la
mayoría de los usuarios, es cierto que hay mucho material a interiorizar y
que los usuarios desean experimentar con las herramientas de forma rápida y
satisfactoria antes de entrar en detalles. Por lo tanto, se sugiere leer
siguiendo el siguiente orden.

Primero leer el capítulo {Acerca de este manual}#about-manual, desde el
principio y terminando en la sección {Términos}#terms. Después saltar hasta
los tres tutoriales que están al principio de la sección {Ejemplos}#examples
pensados para aprender a configurar y construir imágenes de sistemas en vivo
de forma básica. Se deberá leer primero {Uso de los
ejemplos}#using-the-examples, seguido de {Tutorial 1: Una imagen
estándar}#tutorial-1 y {Tutorial 2: Una utilidad de navegador
web}#tutorial-2, para finalizar con {Tutorial 3: Una imagen
personalizada}#tutorial-3. Al final de estos tutoriales, el lector tendrá
una visión de lo que se puede hacer con Debian Live.

Se anima a profundizar en el estudio del manual con la lectura detenida del
siguiente capítulo: {Conceptos básicos}#the-basics, y de una manera más
somera el capítulo {La creación de una imagen
netboot}#building-netboot-image, para acabar con la lectura de {Descripción
general de la personalización}#customization-overview y los capítulos que le
siguen. Se espera que, en este punto, el lector esté lo suficientemente
motivado con lo que se puede hacer con Debian Live para leer el resto del
manual, de principio a fin.

2~terms Términos

_* *{Sistema en vivo}*: Se entiende por sistema en vivo aquel sistema
operativo que se puede arrancar sin instalación previa en el disco duro. Un
sistema en vivo no altera ningún sistema operativo previamente instalado ni
ningún fichero existente en el disco duro de la máquina a menos que se le
instruya para hacerlo. Los sistemas en vivo son arrancados típicamente desde
medios extraíbles como CD, DVD o llaves USB. Algunos pueden también arrancar
desde la red local.

_* *{Debian Live}*: Es un subproyecto de Debian que mantiene, entre otros,
los paquetes Debian live-boot, live-build, live-config y live-manual.

_* *{Sistema Debian Live}*: Es un sistema en vivo que utiliza programas del
sistema operativo Debian y que puede ser arrancado desde medios extraíbles
como CD, DVD o llaves USB, desde red local (mediante imágenes netboot) o
desde Internet (utilizando la opción de arranque #{fetch=URL}#).

_* *{Sistema huésped}*: Es el conjunto de herramientas y equipo utilizado
para crear el sistema en vivo.

_* *{Sistema objetivo}*: Es el conjunto de herramientas y equipo donde se
ejecutará el sistema en vivo.

_* *{live-boot}*: Es una colección de scripts que serán responsables de
arrancar el sistema en vivo. live-boot fue anteriormente una parte del
paquete /{live-initramfs}/.

_* *{live-build}*: Es una colección de scripts utilizados para construir
sistemas Debian Live personalizados. live-build fue conocido anteriormente
como /{live-helper}/, y en una versión anterior como /{live-package}/.

_* *{live-config}*: Es una colección de scripts utilizados para configurar
un sistema en vivo durante el proceso de arranque. live-config fue
anteriormente parte del paquete /{live-initramfs}/.

_* *{live-manual}*: Este documento forma parte de un paquete llamado
live-manual.

_* *{Instalador de Debian (Debian Installer o d-i)}*: Es el mecanismo
oficial de instalación para la distribución Debian.

_* *{Parámetros de arranque}*: Parámetros que son entregados al gestor de
arranque (bootloader) para modificar el comportamiento del kernel o del
conjunto de scripts live-config. Son llamados también Parámetros de kernel u
Opciones de arranque.

_* *{chroot}*: El programa /{chroot}/, #{chroot(8)}#, permite ejecutar
diferentes instancias de un entorno GNU/Linux en un solo sistema de manera
simultánea sin necesidad de reiniciar el sistema.

_* *{Imagen binaria}*: Es un fichero binario que contiene el sistema en
vivo. Su nombre puede ser binary.iso o binary.img dependiendo de su formato.

_* *{Distribución objetivo}*: Es la versión de la distribución Debian en la
cual estará basado el sistema en vivo que puede diferir de la versión de la
distribución en el sistema huésped.

_* *{stable/testing/unstable}*: La distribución *{stable}* contiene la
última distribución Debian oficialmente publicada. La distribución
*{testing}* está en la rampa de salida para ser la próxima distribución
*{stable}*. La principal ventaja de utilizar esta distribución es que tiene
versiones de programas más recientes si se compara con la versión
*{stable}*. La distribución *{unstable}* es dónde se realiza el desarrollo
de Debian. Generalmente esta distribución es usada por los desarrolladores y
aquellos que les gusta vivir al filo de lo imposible. A lo largo del manual,
se usan sus  nombres en clave, como por ejemplo wheezy o sid, ya que es lo
que las mismas herramientas reconocen. 

2~ Autores

Lista de autores (en orden alfabético):

_* Ben Armstrong

_* Brendan Sleight

_* Carlos Zuferri

_* Chris Lamb

_* Daniel Baumann

_* Franklin Piat

_* Jonas Stein

_* Kai Hendry

_* Marco Amadori

_* Mathieu Geli

_* Matthias Kirschner

_* Richard Nelson

_* Trent W. Buck

2~how-to-contribute Cómo contribuir en este documento

This manual is intended as a community project and all proposals for
improvements and contributions are extremely welcome. Please see the section
{Contributing to the project}#contributing-to-project for detailed
information on how to fetch the commit key and make good commits.

3~ Aplicar cambios

In order to make changes to the English manual you have to edit the right
files in #{manual/en/}# but prior to the submission of your contribution,
please preview your work. To preview the live-manual, ensure the packages
needed for building it are installed by executing:

code{

 # apt-get install make po4a sisu-complete libnokogiri-ruby

}code

Se puede realizar la construcción del manual posicionándose en el directorio
de nivel superior, o sea, en el directorio clonado mediante Git y ejecutando
la siguiente orden:

code{

 $ make build

}code

Ya que la construcción del manual para todos los idiomas soportados tarda un
rato, puede ser mejor crear un solo idioma. Esto puede realizarse ejecutando
la siguiente orden:

code{

 $ make build LANGUAGES=en

}code

Es posible generar el documento por formato:

code{

 $ make build FORMATS=pdf

}code

O combinar ambos, por ejemplo:

code{

 $ make build LANGUAGES=it FORMATS=html

}code

After revising your work and making sure that everything is fine, do not use
#{make commit}# unless you are updating translations in the commit, and in
that case, do not mix changes to the English manual and translations in the
same commit, but use separate commits for each. See the
{Translation}#translation section for more details.

3~translation Traducción

Para comenzar la traducción de un idioma nuevo, se deben seguir los
siguientes pasos:

_* Traducir los ficheros *{about_manual.ssi.pot}*, *{about_project.ssi.pot}*
y *{index.html.in.pot}* al idioma deseado con cualquier editor (como puede
ser /{poedit}/). Enviar los ficheros #{.po}# traducidos a la lista de correo
para que el equipo de traducción pueda revisar su integridad.

_* Para activar una nueva lengua en el autobuild basta con añadir los
ficheros traducidos inicialmente a #{manual/po/${LANGUAGE}/}# y ejecutar
#{make commit}#. Y entonces editar #{manual/_sisu/home/index.html}#.

_* Una vez que el nuevo idioma haya sido añadido, se puede continuar la
traducción de los ficheros po restantes en #{manual/po/}# de manera
aleatoria.

_* No se debe olvidar la ejecución del comando #{make commit}# para asegurar
que los manuales traducidos son actualizados desde los ficheros
.po. Entonces se puede revisar los cambios ejecutando #{make build}# antes
de realizar la entrega mediante #{git add .}#, #{git commit -m
"Translating..."}# y #{git push}#.

After running #{make commit}# you will see some text scroll by. They are
basically informative messages about the processing status and also some
hints about what can be done in order to improve live-manual. Unless you see
a fatal error, you can usually proceed and submit your contribution.

live-manual comes with two utilities that can greatly help translators to
find untranslated and fuzzy strings. The first one is "make check". It
launches a po file integrity check script that tells you in detail how many
untranslated and fuzzy strings there are in each po file. It stops whenever
it finds a fatal error and verbosely informs about what the problem is. The
second one, the "make translate" target, only acts upon fuzzy strings but it
helps you to find and fix them one by one.

*{Nota:}* Se puede utilizar #{make clean}# para limpiar el árbol git antes de enviar los cambios. Este paso no es obligatorio, gracias al fichero .gitignore, pero es una buena práctica para evitar enviar ficheros involuntariamente.
