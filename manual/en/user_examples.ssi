:B~ Examples

1~examples Examples

This chapter covers example builds for specific use cases with Debian Live. If you are new to building your own Debian Live images, we recommend you first look at the three tutorials in sequence, as each one teaches new techniques that will help you use and understand the remaining examples.

2~using-the-examples Using the examples

Note that for the sake of brevity, in all of these examples we do not specify a local mirror to use for the build. You can either add the options to #{lb config}# each time you use the command, or else establish a default for your build system by creating #{/etc/live/build.conf}# and putting your preferred mirror in it as in the following example:

code{

LB_MIRROR_BOOTSTRAP="http://mirror/debian"
LB_MIRROR_CHROOT="http://mirror/debian"

}code

2~tutorial-1 Tutorial 1: A standard image

*{Use case:}* Create a simple first image, learning the basics of live-build

In this tutorial, we will build a default ISO hybrid Debian Live image containing only base packages (no Xorg) and some Debian Live support packages, as a first exercise in using live-build.

You can't get much simpler than this:

code{

$ mkdir tutorial1 ; cd tutorial1 ; lb config

}code

Examine the contents of the #{config/}# directory if you wish. You will see stored here a skeletal configuration, ready to customize or, in this case, use immediately to build a default image.

Now, as superuser, build the image, saving a log as you build with #{tee}#.

code{

# lb_build 2>&1 | tee binary.log

}code

Assuming all goes well, after a while, the current directory will contain #{binary-hybrid.iso}#. This ISO hybrid image can be booted directly in a virtual machine as described in {Testing an ISO image with Qemu}#testing-iso-with-qemu and {Testing an ISO image with virtualbox-ose}#testing-iso-with-virtualbox, or else imaged onto optical media or a USB flash device as described in {Burning an ISO image to a physical medium}#burning-iso-image and {Copying USB/HDD image to a USB stick}#copying-usb-hdd-image, respectively.

2~tutorial-2 Tutorial 2: A web browser utility

*{Use case}* Create a web browser utility image, learning how to apply customizations

In this tutorial, we will create an image suitable for use as a web browser utility, serving as an introduction to customizing Debian Live images.

code{

mkdir tutorial2 ; cd tutorial2 ; lb config -p lxde --packages iceweasel

}code

Our choice of LXDE for this example reflects our desire to provide a minimal desktop environment, since the focus of the image is the single use we have in mind, the web browser. We could go even further and provide a default configuration for the web browser in #{config/chroot_local-includes/etc/iceweasel/profile/}#, or additional support packages for viewing various kinds of web content, but we leave this as an exercise for the reader.

Build the image, keeping a log as in {Tutorial 1}#tutorial-1:

code{

# lb build 2>&1 | tee binary.log

}code

2~tutorial-3 Tutorial 3: A personalized image

*{Use case}* Create a project to build a personalized image, containing your favourite software to take with you on a USB stick wherever you go, and evolving in successive revisions as your needs and preferences change.

FIXME

2~ A VNC Kiosk Client

Create an image with live-build to boot directly to a VNC server.

_* Make a build directory: #{$ mkdir vncBuild}#

_* Move to the build directory: #{$ cd vncBuild}#

Example to config the build directory to include gdm metacity xtightvncviewer: #{$ lb config --packages "gdm3 metacity xtightvncviewer"}#

Create a folder /etc/skel folder for a custom .xsession for the default user: #{$ mkdir -p config/chroot_local-includes/etc/skel}#

Create the .xsession for the default user: #{$ touch config/chroot_local-includes/etc/skel/.xsession}#

Edit the .xsession file to launch metacity and start xvncviewer with something similar to the below:

code{

#!/bin/sh

/usr/bin/metacity &
/usr/bin/vncviewer xxx.xxx.xxx.xxx:PORT

exit

}code

_* Build the image: #{# lb build}#

_* Enjoy.

2~ A base image for a 128M USB key

*{Use case}* Create a standard image with some components removed in order to fit on a 128M USB key with space left over to use as you see fit.

When optimizing an image to fit a certain media size, you need to understand the tradeoffs you are making between size and functionality. In this example, we trim only so much as to make room for additional material within a 128M media size, but without doing anything to destroy integrity of the packages contained within, such as the purging of locale data via the #{localepurge}# package, or other such "intrusive" optimizations. Of particular note, you should not use #{--bootstrap-flavour minimal}# unless you really know what you're doing, as omitting priority #{important}# packages will most likely produce a broken live system.

code{

$ lb config -k 486 -p minimal --binary-indices false --memtest none --apt-recommends false --includes none

}code

Now, build the image in the usual way:

code{

# lb build 2>&1 | tee binary.log

}code

On the author's system at time of writing, the above configuration produced a 78Mbyte image. This compares favourably with the 166Mbyte image produced by the default configuration in {Tutorial 1}#tutorial-1.

The biggest space-saver here, compared to building a standard image on an #{i386}# architecture system, is to select only the #{486}# kernel flavour instead of the default #{-k "486 686"}#. Leaving off APT's indices with #{--binary-indices false}# also saves a fair amount of space, the tradeoff being that you need to #{apt-get update}# before using apt in the live system. Choosing the #{minimal}# package list leaves out the large #{locales}# package and associated utilities. Dropping recommended packages with #{--apt-recommends false}# saves some additional space, at the expense of omitting some packages you might otherwise expect to be there, such as #{firmware-linux-free}# which may be needed to support certain hardware. The remaining options shave off additional small amounts of space. It's up to you to decide if the functionality that is sacrificed with each optimization is worth the loss in functionality.

