:B~ Customizing run time behaviours

1~customizing-run-time-behaviours Customizing run time behaviours

All configuration that is done during run time is done by live-config. Here
are some of the most common options of live-config that users are interested
in. A full list of all possibilities can be found in the manpage of
live-config.

2~ Customizing the live user

One important consideration is that the live user is created by live-boot at
boot time, not by live-build at build time. This not only influences where
materials relating to the live user are introduced in your build, as
discussed in {Live/chroot local includes}#live-chroot-local-includes, but
also any groups and permissions associated with the live user.

You can specify additional groups that the live user will belong to by
preseeding the #{passwd/user-default-groups}# debconf value. For example, to
add the live user to the #{fuse}# group, add the following preseed under
#{config/preseed/}# for the chroot stage:

code{

 $ lb config
 $ echo user-setup passwd/user-default-groups string audio cdrom \
   dip floppy video plugdev netdev powerdev scanner bluetooth fuse \
   >> config/preseed/my.preseed.chroot

}code

It is also possible to change the default username "user" and the default
password "live". If you want to do that for any reason, you can easily
achieve it as follows:

To change the default username you can simply specify it in your config:

code{

 $ lb config --bootappend-live "username=live-user"

}code

One possible way of changing the default password is by means of a hook as
described in {Boot-time hooks}#boot-time-hooks. In order to do that you can
use the "passwd" hook from #{/usr/share/doc/live-config/examples/hooks}#,
prefix it accordingly (e.g. 200-passwd) and add it to
#{config/includes.chroot/lib/live/config/}#

2~customizing-locale-and-language Customizing locale and language

When the live system boots, language is involved in three steps:

_* the locale generation

_* setting the keyboard layout for the console

_* setting the keyboard layout for X

The default locale when building a Live system is "locales=en_US.UTF-8". To
define the locale that should be generated, use the #{locales}# parameter in
the #{--bootappend-live}# option of #{lb config}#, e.g.

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8"

}code

This parameter can also be used at the kernel command line. You can specify
a locale by a full #{language_country.encoding}# word.

Both the console and X keyboard configuration depend on the
#{keyboard-layouts}# parameter of the #{--bootappend-live}# option. Valid
options for X keyboard layouts can be found in
#{/usr/share/X11/xkb/rules/base.xml}# (rather limited to two-letters country
codes). To find the value (the two characters) corresponding to a language
try searching for the english name of the nation where the language is
spoken, e.g:

code{

 $ grep -i sweden -C3 /usr/share/X11/xkb/rules/base.xml | grep name
 <name>se</name>

}code

To get the locale files for German and Swiss German keyboard layout in X
use:

code{

 $ lb config --bootappend-live "locales=de_CH.UTF-8 keyboard-layouts=ch"

}code

A list of the valid values of the keyboards for the console can be figured
with the following command:

code{

 $ for i in $(find /usr/share/keymaps/ -iname "*kmap.gz"); \
     do basename $i | head -c -9; echo; done | sort | less

}code

Alternatively, you can use the #{console-setup}# package, a tool to let you
configure console layout using X (XKB) definitions; you can then set your
keyboard layout more precisely with #{keyboard-layouts}#,
#{keyboard-variant}#, #{keyboard-options}# and #{keyboard-model}# variables;
live-boot will use also these parameters for X configuration. For example,
to set up a French system with a French-Dvorak layout (called Bepo) on a
TypeMatrix keyboard, both in console and X11, use:

code{

 $ lb config --bootappend-live \
     "locales=fr_FR.UTF-8 keyboard-layouts=fr keyboard-variant=bepo keyboard-model=tm2030usb"

}code

2~persistence Persistence

A live cd paradigm is a pre-installed system which runs from read-only
media, like a cdrom, where writes and modifications do not survive reboots
of the host hardware which runs it.

A Debian Live system is a generalization of this paradigm and thus supports
other media in addition to CDs; but still, in its default behaviour, it
should be considered read-only and all the run-time evolutions of the system
are lost at shutdown.

'Persistence' is a common name for different kinds of solutions for saving
across reboots some, or all, of this run-time evolution of the system. To
understand how it works it would be handy to know that even if the system is
booted and run from read-only media, modifications to the files and
directories are written on writable media, typically a ram disk (tmpfs) and
ram disks' data do not survive reboots.

The data stored on this ramdisk should be saved on a writable persistent
medium like local storage media, a network share or even a session of a
multisession (re)writable CD/DVD. All these media are supported in Debian
Live in different ways, and all but the last one require a special boot
parameter to be specified at boot time: #{persistence}#.

If the boot parameter #{persistence}# is set (and #{nopersistence}# is not
set), local storage media (e.g. hard disks, USB drives) will be probed for
persistence volumes during boot. It is possible to restrict which types of
persistence volumes to use by specifying certain boot parameters described
in the live-boot(7) man page. A persistence volume is any of the following:

_* a partition, identified by its GPT name.

_* a filesystem, identified by its filesystem label.

_* an image file located on the root of any readable filesystem (even an
NTFS partition of a foreign OS), identified by its file name. In this case
the file name must also use the containing filesystem as the file extension,
e.g. "persistence.ext4".

The volume label for overlays must be #{persistence}#. And in order to fully
customize the volume's persistence there must be a file named
#{live-persistence.conf}#. See {The live-persistence.conf
file}#live-persistence-conf

Here are some examples of how to prepare a volume to be used for
persistence. It can be, for instance, an ext4 partition on a hard disk or on
a usb key created with, e.g.:

code{

 # mkfs.ext4 -L persistence /dev/sdb1

}code

See also {Using the space left on a USB stick}#using-usb-extra-space.

If you already have a partition on your device, you could just change the
label with one of the following:

code{

 $ tune2fs -L persistence /dev/sdb1 # for ext2,3,4 filesystems

}code

Here's an example of how to create an ext4-based image file used for
persistence:

code{

 $ dd if=/dev/null of=persistence bs=1G seek=1 # for a 1GB sized image file
 $ /sbin/mkfs.ext4 -F persistence

}code

Then copy the #{persistence}# file to the root of a writable partition.

3~live-persistence-conf The live-persistence.conf file

A volume with the label #{persistence}# can be configured to make arbitrary
directories persistent. The file #{live-persistence.conf}#, located on the
volume's filesystem root, controls which directories it makes persistent,
and in which way.

How custom overlay mounts are configured is described in full detail in the
live-persistence.conf(5) man page, but a simple example should be sufficient
for most uses. Let's say we want to make our home directory and APT cache
persistent in an ext4 filesystem on the /dev/sdb1 partition:

code{

 $ mkfs.ext4 -L persistence /dev/sdb1
 $ mount -t ext4 /dev/sdb1 /mnt
 $ echo "/home" >> /mnt/live-persistence.conf
 $ echo "/var/cache/apt" >> /mnt/live-persistence.conf

}code

Then we reboot. During the first boot the contents of #{/home}# and
#{/var/cache/apt}# will be copied into the persistence volume, and from then
on all changes to these directories will live in the persistence
volume. Please note that any paths listed in the #{live-persistence.conf}#
file cannot contain white spaces or the special #{.}# and #{..}# path
components. Also, neither #{/live}# (or any of its sub-directories) nor
#{/}# can be made persistent using custom mounts.

Several different custom overlay volumes (with their own
#{live-persistence.conf}# files) can be used at the same time, but if
several volumes make the same directory persistent, only one of them will be
used. If any two mounts are "nested" (i.e. one is a sub-directory of the
other) the parent will be mounted before the child so no mount will be
hidden by the other. Nested custom mounts are problematic if they are listed
in the same #{live-persistence.conf}# file. See the live-persistence.conf(5)
man page for how to handle that case if you really need it (hint: you
usually don't).

3~ Persistence SubText

If a user would need multiple persistence storage of the same type for
different locations or testing, such as #{persistence-nonwork}# and
#{persistence-work}#, the boot parameter #{persistence-subtext}# used in
conjunction with the boot parameter #{persistence}# will allow for multiple
but unique persistence media. An example would be if a user wanted to use a
persistence partition labeled #{persistence-subText}# they would use the
boot parameters of: #{persistence}# #{persistence-subtext=subText}#.
