:B~ Exemples

1~examples Exemples

En aquest capítol s'inclouen exemples de construccions per a casos d'ús
específics amb Debian Live. Si s'és nou en la construcció d'imatges de
Debian Live pròpies, us suggerim mirar els tres tutorials en seqüència, ja
que cada un ensenya noves tècniques que ajuden a utilitzar i entendre els
exemples restants.

2~using-the-examples Ús dels exemples

Per utilitzar aquests exemples es necessita un sistema de construcció que
compleixi les exigències enumerades a {Requisits}#requirements y que tingui
live-build instaŀlat com es descriu a {Instaŀlació de
live-build}#installing-live-build.

Cal notar que, per abreujar, en aquests exemples no s'especifica un mirall
local per utilitzar en la construcció. Es poden accelerar les descàrregues
considerablement si s'utilitza un mirall local. Es pot especificar les
opcions quan s'utilitza #{lb config}#, com es descriu a {Miralls de
distribució utilitzats en temps de
construcció}#distribution-mirrors-build-time, o per a major comoditat,
establir el valor predeterminat per al sistema de construcció en el fitxer
#{/etc/live/build.conf}#. Només cal crear aquest fitxer i establir a les
variables al mirall preferit. Tots els altres miralls que s'utilitzin en la
construcció adoptaran valors per defecte segons aquests valors. Per exemple:

code{

 LB_MIRROR_BOOTSTRAP="http://mirror/debian/"
 LB_MIRROR_CHROOT_SECURITY="http://mirror/debian-security/"
 LB_MIRROR_CHROOT_BACKPORTS="http://mirror/debian-updates/"

}code

2~tutorial-1 Tutorial 1: Una imatge per defecte

*{Cas d'ús:}* Crear una primera imatge senzilla, aprenent els conceptes bàsics de live-build.

En aquest tutorial, anem a construir una imatge ISO híbrida per defecte de
Debian Live que contingui només els paquets de base (no té Xorg) i altres
paquets de suport de Debian Live, com un primer exercici en l'ús de
live-build.

No pot ser més senzill que això:

code{

 $ mkdir tutorial1 ; cd tutorial1 ; lb config

}code

Examinar el contingut del directori #{config/}# si es vol. Es veurà
emmagatzemada aquí una configuració en esquelet, a punt per ser
personalitzada o, en aquest cas, per ser utilitzada immediatament per
construir una imatge per defecte.

Ara, com a superusuari, construir la imatge, guardant un log del que es
construeix amb #{tee}#.

code{

 # lb build 2>&1 | tee build.log

}code

Suposant que tot va bé, després d'una estona, el directori actual contindrà
una #{binary.hybrid.iso}#. Aquesta imatge ISO híbrida es pot arrencar en una
màquina virtual tal com s'explica a {Provar una imatge ISO amb
Qemu}#testing-iso-with-qemu i {Provar una imatge ISO amb
virtualbox}#testing-iso-with-virtualbox, o bé copiada a un dispositiu USB
com es descriu a {Gravar una imatge ISO en un medi físic}#burning-iso-image
i {Còpiar una imatge ISO híbrida en un dispositiu
USB}#copying-iso-hybrid-to-usb, respectivament.

2~tutorial-2 Tutorial 2: Una utilitat de navegador web

*{Cas d'ús:}* Crear una imatge d'una utilitat de navegador web, aprenent a aplicar personalitzacions.

En aquest tutorial, anem a crear una imatge adequada per al seu ús com a una
utilitat de navegador web, que serveix com introducció a la personalització
de les imatges de Debian Live.

code{

 $ mkdir tutorial2
 $ cd tutorial2
 $ echo "task-lxde-desktop iceweasel" >> config/package-lists/my.list.chroot

}code

La nostra elecció de LXDE per a aquest exemple reflecteix el nostre desig
d'oferir un entorn d'escriptori mínim, ja que l'objectiu de la imatge és
l'únic ús que tenim al cap, el navegador web. Podríem anar encara més lluny
i oferir una configuració per defecte per al navegador web a
#{config/includes.chroot/etc/iceweasel/profile/}#, o paquets addicionals de
suport per a la visualització de diversos tipus de contingut web, però
deixem això com a un exercici per al lector.

Construir la imatge, de nou com a superusuari, guardant un log com al
{Tutorial 1}#tutorial-1:

code{

 # lb build 2>&1 | tee build.log

}code

Un cop més, verificar que la imatge està bé i provar-la, com al {Tutorial
1}#tutorial-1.

2~tutorial-3 Tutorial 3: Una imatge personalitzada

*{Cas d'ús:}* Crear un projecte per construir una imatge personalitzada, que contingui el programari favorit per portar en una memòria USB allà on es vagi i que evolucionarà en revisions successives tal i com les necessitats i les preferències canvien.

Com la nostra imatge personalitzada canviarà durant un nombre de revisions i
volem fer un seguiment d'aquests canvis, provar coses experimentals i
possiblement revertir-les si les coses no surten bé, anem a mantenir la
nostra configuració en el popular sistema de control de versions
#{git}#. També utilitzarem les millors pràctiques de configuració automàtica
mitjançant scripts #{auto}# com s'explica a {Gestió d'una
configuració}#managing-a-configuration.

3~ Primera revisió

code{

 $ mkdir -p tutorial3/auto
 $ cp /usr/share/doc/live-build/examples/auto/* tutorial3/auto/
 $ cd tutorial3

}code

Editar #{auto/config}# de la manera següent:

code{

 #!/bin/sh

 lb config noauto \
     --architectures i386 \
     --linux-flavours 686-pae \
     "${@}"

}code

Executar #{lb config}# per crear l'arbre de configuració, utilitzant el
script #{auto/config}# que s'acaba de crear:

code{

 $ lb config

}code

Ara, omplir la llista local de paquets:

code{

 $ echo "task-lxde-desktop iceweasel xchat" >> config/package-lists/my.list.chroot

}code

En primer lloc, amb #{--architectures i386}# s'assegura que al nostre
sistema de construcció #{amd64}# podem construir una versió de 32 bits
adequada per al seu ús en la majoria de màquines. En segon lloc, fem servir
#{--linux-flavours 686-pae}# perquè no creiem que utilitzarem aquesta imatge
en sistemes molt més vells. En tercer lloc, hem triat la tasca metapaquet
/{lxde}/ per donar-nos un escriptori mínim. I, finalment, hem afegit dos
paquets inicials favorits: /{iceweasel}/ i /{xchat}/.

Ara, construir la imatge:

code{

 # lb build

}code

Tenir en compte que a diferència dels dos primers tutorials, ja no s'ha
d'escriure #{2>&1 | tee build.log}# ja que ara s'inclou al script
#{auto/build}#.

Quan s'ha provat la imatge (com al {Tutorial 1}#tutorial-1) i s'està
satisfet del seu funcionament, és el moment d'iniciar el repositòri #{git}#,
afegint només els scripts auto que s'han creat, i llavors fer el primer
lliurament:

code{

 $ git init
 $ cp /usr/share/doc/live-build/examples/gitignore .gitignore
 $ git add .
 $ git commit -a -m "Initial import."

}code

3~ Segona revisió

En aquesta revisió, anem a netejar després de la primera construcció, afegir
el paquet /{vlc}/ a la nostra configuració, reconstruir, provar i fer el
lliurament.

L'ordre #{lb clean}# netejarà tots els fitxers generats en la construcció
anterior a excepció del cache, el que estalvia haver de tornar a descarregar
els paquets. Això assegura que el #{lb build}# següent tornarà a executar
totes les etapes per regenerar els fitxers de la nostra nova configuració.

code{

 # lb clean

}code

Ara afegim el paquet /{vlc}/ al llistat de paquets local a
#{config/package-lists/my.list.chroot}#:

code{

 $ echo vlc >> config/package-lists/my.list.chroot

}code

Construir de nou:

code{

# lb build

}code

Provar, i quan s'estigui satisfet, fer el lliurament de la propera revisió:

code{

 $ git commit -a -m "Adding vlc media player."

}code

Per descomptat, es possible fer canvis més complicats en la configuració,
potser afegint fitxers en els subdirectoris de #{config/}#. Quan es fa un
lliurament de les noves revisions, s'ha de tenir cura de no editar a mà o
incloure en el lliurament els fitxers de nivell superior de #{config}# que
contenen variables #{LB_*}#, ja que són productes de construcció també, i
sempre són netejats per #{lb clean}# i tornats a crear per #{lb config}# a
través dels seus respectius scripts #{auto}#.

Hem arribat al final de la nostra sèrie de tutorials. Molts més tipus de
personalització són possibles, amb les poques característiques explorades en
aquests senzills exemples, es poden crear una varietat gairebé infinita
d'imatges diferents. Els exemples que queden d'aquesta secció tracten
diferents casos d'ús extrets de les experiències recollides dels usuaris de
Debian Live.

2~ Un client per a un quiosc VNC

*{Cas d'ús:}* Crear una imatge amb live-build per connectar-se directament a un servidor VNC al arrencar.

Fer un directori de treball i crear una configuració d'esquelet en el seu
interior, desactivant els «recommends» per fer un sistema mínim. I a
continuació, crear dues llistes inicials de paquets: La primera generada per
un script proporcionat per live-build anomenat #{Packages}# (veure {Generar
llistes de paquets}#generated-package-lists), i la segona incloent-hi
/{xorg}/, /{gdm3}/, /{metacity}/ i /{xvnc4viewer}/.

code{

 $ mkdir vnc-kiosk-client
 $ cd vnc-kiosk-client
 $ lb config -a i386 -k 686-pae --apt-recommends false
 $ echo '! Packages Priority standard' > config/package-lists/standard.list.chroot
 $ echo "xorg gdm3 metacity xvnc4viewer" > config/package-lists/my.list.chroot

}code

Com s'explica a {Afinar APT per estalviar espai}#tweaking-apt-to-save-space
pot ser que s'hagi de tornar a afegir alguns paquets recomanats per fer que
la imatge funcioni correctament.

Una manera fàcil d'enumerar els recommends és utilitzar /{apt-cache}/. Per
exemple:

code{

 $ apt-cache depends live-config live-boot

}code

En aquest exemple, ens vam assabentar que havíem de tornar a incloure
diversos paquets recomanats per live-config i live-boot: #{user-setup}#
perquè funcioni l'autologin i #{sudo}# com a programa essencial per apagar
el sistema. A més, podria ser útil afegir #{live-tools}# per poder copiar la
imatge en la memòria RAM i #{eject}# per expulsar, finalment, els medis en
viu. Per tant:

code{

 $ echo "live-tools user-setup sudo eject" > config/package-lists/recommends.list.chroot

}code

Després, crear el directori #{/etc/skel}# a #{config/includes.chroot}# i
​​posar un fitxer #{.xsession}# personalitzat per a l'usuari per defecte que
posarà en marxa /{metacity}/ i iniciarà /{xvncviewer}/, connectant al port
#{5901}# d'un servidor ubicat a #{192.168.1.2}#:

code{

 $ mkdir -p config/includes.chroot/etc/skel
 $ cat > config/includes.chroot/etc/skel/.xsession << EOF
 #!/bin/sh

 /usr/bin/metacity &
 /usr/bin/xvncviewer 192.168.1.2:1

 exit
 EOF

}code

Construir la imatge:

code{

 # lb build

}code

Gaudir-ne.

2~ Una imatge bàsica per a un dispositiu USB de 128MB

*{Cas d'ús:}* Crear una imatge per defecte amb alguns components eliminats per tal que càpiga en una clau USB de 128MB amb un petit espai de sobres per utilitzar com millor us sembli.

Al optimitzar una imatge per adaptar-la a una mida determinada, cal
comprendre la compensació que s'estan fent entre la mida i la
funcionalitat. En aquest exemple, retallem tant només per donar cabuda a
material addicional dins d'una mida de 128MB, però sense fer res per
destruir la integritat dels paquets continguts, com la depuració de les
dades de localització a través del paquet /{localepurge}/ o altres
optimitzacions "intrusives". De particular interès, utilitzem
#{--debootstrap-options}# per crear un sistema mínim des de zero.

code{

 $ lb config -k 486 --apt-indices false --apt-recommends false --debootstrap-options "--variant=minbase" --firmware-chroot false --memtest none

}code

Per fer que la imatge funcioni correctament, hem de tornar a afegir, com a
mínim, dos paquets recomanats, que es queden fora per l'opció
#{--apt-recommends false}#. Veure { Afinar APT per estalviar
espai}#tweaking-apt-to-save-space

code{

 $ echo "user-setup sudo" > config/package-lists/recommends.list.chroot

}code

Ara, crear la imatge de la forma habitual:

code{

 # lb build 2>&1 | tee build.log

}code

On the author's system at the time of writing this, the above configuration
produced a 77MB image. This compares favourably with the 177MB image
produced by the default configuration in {Tutorial 1}#tutorial-1.

The biggest space-saver here, compared to building a default image on an
#{i386}# architecture system, is to select only the #{486}# kernel flavour
instead of the default #{-k "486 686-pae"}#. Leaving off APT's indices with
#{--apt-indices false}# also saves a fair amount of space, the tradeoff
being that you need to do an #{apt-get update}# before using /{apt}/ in the
live system. Dropping recommended packages with #{--apt-recommends false}#
saves some additional space, at the expense of omitting some packages you
might otherwise expect to be there. #{--debootstrap-options
"--variant=minbase"}# bootstraps a minimal system from the start. Not
automatically including firmware packages with #{--firmware-chroot false}#
saves some space too. And finally, #{--memtest none}# prevents the
installation of a memory tester.

*{Note:}* A minimal system can also be achieved using hooks, like for example the #{stripped.chroot}# hook found in #{/usr/share/doc/live-build/examples/hooks}#. It may shave off additional small amounts of space and produce an image of 62MB. However, it does so by removal of documentation and other files from packages installed on the system. This violates the integrity of those packages and that, as the comment header warns, may have unforeseen consequences. That is why using a minimal /{debootstrap}/ is the recommended way of achieving this goal.

2~ A localized GNOME desktop and installer

*{Use case:}* Create a GNOME desktop image, localized for Switzerland and including an installer.

We want to make an iso-hybrid image for i386 architecture using our
preferred desktop, in this case GNOME, containing all of the same packages
that would be installed by the standard Debian installer for GNOME.

El nostre primer problema és descobrir els noms de les tasques del
llenguatge apropiades. En l'actualitat, live-build no ens pot ajudar amb
això. Tot i que es podria tenir sort i trobar-ho per assaig i error, hi ha
una eina, #{grep-dctrl}#, per extreure les descripcions de les tasques de
tasksel-data. Per preparar-ho tot, assegurar-se de tenir totes dues coses:

code{

 # apt-get install dctrl-tools tasksel-data

}code

Ara podem buscar les tasques apropiades, primer amb:

code{

 $ grep-dctrl -FTest-lang de /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: german

}code

By this command, we discover the task is called, plainly enough, german. Now
to find the related tasks:

code{

 $ grep-dctrl -FEnhances german /usr/share/tasksel/descs/debian-tasks.desc -sTask
 Task: german-desktop
 Task: german-kde-desktop

}code

At boot time we will generate the *{de_CH.UTF-8}* locale and select the
*{ch}* keyboard layout. Now let's put the pieces together. Recalling from
{Using metapackages}#using-metapackages that task metapackages are prefixed
#{task-}#, we just specify these language boot parameters, then add standard
priority packages and all our discovered task metapackages to our package
list as follows:

code{

 $ mkdir live-ch-gnome
 $ cd live-ch-gnome
 $ lb config \
     -a i386 \
     -k 486 \
     --bootappend-live "boot=live config locales=de_CH.UTF-8 keyboard-layouts=ch" \
     --debian-installer live
 $ echo '! Packages Priority standard' > config/package-lists/standard.list.chroot
 $ echo task-gnome-desktop task-german task-german-desktop >> config/package-lists/desktop.list.chroot
 $ echo debian-installer-launcher >> config/package-lists/installer.list.chroot

}code

Tenir en compte que s'ha inclòs el paquet debian-installer-launcher per
llançar l'instaŀlador des de l'escriptori en viu, i també s'especifica el
nucli 486, ja que actualment és necessari que l'instaŀlador i el nucli del
sistema viu coincideixin perquè el llançador funcioni correctament.
